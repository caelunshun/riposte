// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riposte.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_riposte_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_riposte_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_riposte_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_riposte_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[39]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_riposte_2eproto;
class AdminStartGame;
struct AdminStartGameDefaultTypeInternal;
extern AdminStartGameDefaultTypeInternal _AdminStartGame_default_instance_;
class AnyClient;
struct AnyClientDefaultTypeInternal;
extern AnyClientDefaultTypeInternal _AnyClient_default_instance_;
class AnyServer;
struct AnyServerDefaultTypeInternal;
extern AnyServerDefaultTypeInternal _AnyServer_default_instance_;
class BuildTask;
struct BuildTaskDefaultTypeInternal;
extern BuildTaskDefaultTypeInternal _BuildTask_default_instance_;
class BuildTaskKind;
struct BuildTaskKindDefaultTypeInternal;
extern BuildTaskKindDefaultTypeInternal _BuildTaskKind_default_instance_;
class BuildingBuildTask;
struct BuildingBuildTaskDefaultTypeInternal;
extern BuildingBuildTaskDefaultTypeInternal _BuildingBuildTask_default_instance_;
class Capability;
struct CapabilityDefaultTypeInternal;
extern CapabilityDefaultTypeInternal _Capability_default_instance_;
class CarryUnitsCapability;
struct CarryUnitsCapabilityDefaultTypeInternal;
extern CarryUnitsCapabilityDefaultTypeInternal _CarryUnitsCapability_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class ComputePath;
struct ComputePathDefaultTypeInternal;
extern ComputePathDefaultTypeInternal _ComputePath_default_instance_;
class FoundCityCapability;
struct FoundCityCapabilityDefaultTypeInternal;
extern FoundCityCapabilityDefaultTypeInternal _FoundCityCapability_default_instance_;
class Improvement;
struct ImprovementDefaultTypeInternal;
extern ImprovementDefaultTypeInternal _Improvement_default_instance_;
class KickPlayer;
struct KickPlayerDefaultTypeInternal;
extern KickPlayerDefaultTypeInternal _KickPlayer_default_instance_;
class LobbyError;
struct LobbyErrorDefaultTypeInternal;
extern LobbyErrorDefaultTypeInternal _LobbyError_default_instance_;
class MoveUnit;
struct MoveUnitDefaultTypeInternal;
extern MoveUnitDefaultTypeInternal _MoveUnit_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PathComputed;
struct PathComputedDefaultTypeInternal;
extern PathComputedDefaultTypeInternal _PathComputed_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class Pos;
struct PosDefaultTypeInternal;
extern PosDefaultTypeInternal _Pos_default_instance_;
class ResearchingTech;
struct ResearchingTechDefaultTypeInternal;
extern ResearchingTechDefaultTypeInternal _ResearchingTech_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class SetCityBuildTask;
struct SetCityBuildTaskDefaultTypeInternal;
extern SetCityBuildTaskDefaultTypeInternal _SetCityBuildTask_default_instance_;
class SetEconomySettings;
struct SetEconomySettingsDefaultTypeInternal;
extern SetEconomySettingsDefaultTypeInternal _SetEconomySettings_default_instance_;
class SetLeader;
struct SetLeaderDefaultTypeInternal;
extern SetLeaderDefaultTypeInternal _SetLeader_default_instance_;
class SetResearch;
struct SetResearchDefaultTypeInternal;
extern SetResearchDefaultTypeInternal _SetResearch_default_instance_;
class SetWorkerTask;
struct SetWorkerTaskDefaultTypeInternal;
extern SetWorkerTaskDefaultTypeInternal _SetWorkerTask_default_instance_;
class StartGame;
struct StartGameDefaultTypeInternal;
extern StartGameDefaultTypeInternal _StartGame_default_instance_;
class Tile;
struct TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class UnitBuildTask;
struct UnitBuildTaskDefaultTypeInternal;
extern UnitBuildTaskDefaultTypeInternal _UnitBuildTask_default_instance_;
class UpdateCity;
struct UpdateCityDefaultTypeInternal;
extern UpdateCityDefaultTypeInternal _UpdateCity_default_instance_;
class UpdateGlobalData;
struct UpdateGlobalDataDefaultTypeInternal;
extern UpdateGlobalDataDefaultTypeInternal _UpdateGlobalData_default_instance_;
class UpdateMap;
struct UpdateMapDefaultTypeInternal;
extern UpdateMapDefaultTypeInternal _UpdateMap_default_instance_;
class UpdatePlayer;
struct UpdatePlayerDefaultTypeInternal;
extern UpdatePlayerDefaultTypeInternal _UpdatePlayer_default_instance_;
class UpdateUnit;
struct UpdateUnitDefaultTypeInternal;
extern UpdateUnitDefaultTypeInternal _UpdateUnit_default_instance_;
class WorkerCapability;
struct WorkerCapabilityDefaultTypeInternal;
extern WorkerCapabilityDefaultTypeInternal _WorkerCapability_default_instance_;
class WorkerTask;
struct WorkerTaskDefaultTypeInternal;
extern WorkerTaskDefaultTypeInternal _WorkerTask_default_instance_;
class WorkerTaskImprovement;
struct WorkerTaskImprovementDefaultTypeInternal;
extern WorkerTaskImprovementDefaultTypeInternal _WorkerTaskImprovement_default_instance_;
class WorkerTaskKind;
struct WorkerTaskKindDefaultTypeInternal;
extern WorkerTaskKindDefaultTypeInternal _WorkerTaskKind_default_instance_;
class Yield;
struct YieldDefaultTypeInternal;
extern YieldDefaultTypeInternal _Yield_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AdminStartGame* Arena::CreateMaybeMessage<::AdminStartGame>(Arena*);
template<> ::AnyClient* Arena::CreateMaybeMessage<::AnyClient>(Arena*);
template<> ::AnyServer* Arena::CreateMaybeMessage<::AnyServer>(Arena*);
template<> ::BuildTask* Arena::CreateMaybeMessage<::BuildTask>(Arena*);
template<> ::BuildTaskKind* Arena::CreateMaybeMessage<::BuildTaskKind>(Arena*);
template<> ::BuildingBuildTask* Arena::CreateMaybeMessage<::BuildingBuildTask>(Arena*);
template<> ::Capability* Arena::CreateMaybeMessage<::Capability>(Arena*);
template<> ::CarryUnitsCapability* Arena::CreateMaybeMessage<::CarryUnitsCapability>(Arena*);
template<> ::ClientInfo* Arena::CreateMaybeMessage<::ClientInfo>(Arena*);
template<> ::ComputePath* Arena::CreateMaybeMessage<::ComputePath>(Arena*);
template<> ::FoundCityCapability* Arena::CreateMaybeMessage<::FoundCityCapability>(Arena*);
template<> ::Improvement* Arena::CreateMaybeMessage<::Improvement>(Arena*);
template<> ::KickPlayer* Arena::CreateMaybeMessage<::KickPlayer>(Arena*);
template<> ::LobbyError* Arena::CreateMaybeMessage<::LobbyError>(Arena*);
template<> ::MoveUnit* Arena::CreateMaybeMessage<::MoveUnit>(Arena*);
template<> ::Path* Arena::CreateMaybeMessage<::Path>(Arena*);
template<> ::PathComputed* Arena::CreateMaybeMessage<::PathComputed>(Arena*);
template<> ::PlayerInfo* Arena::CreateMaybeMessage<::PlayerInfo>(Arena*);
template<> ::Pos* Arena::CreateMaybeMessage<::Pos>(Arena*);
template<> ::ResearchingTech* Arena::CreateMaybeMessage<::ResearchingTech>(Arena*);
template<> ::ServerInfo* Arena::CreateMaybeMessage<::ServerInfo>(Arena*);
template<> ::SetCityBuildTask* Arena::CreateMaybeMessage<::SetCityBuildTask>(Arena*);
template<> ::SetEconomySettings* Arena::CreateMaybeMessage<::SetEconomySettings>(Arena*);
template<> ::SetLeader* Arena::CreateMaybeMessage<::SetLeader>(Arena*);
template<> ::SetResearch* Arena::CreateMaybeMessage<::SetResearch>(Arena*);
template<> ::SetWorkerTask* Arena::CreateMaybeMessage<::SetWorkerTask>(Arena*);
template<> ::StartGame* Arena::CreateMaybeMessage<::StartGame>(Arena*);
template<> ::Tile* Arena::CreateMaybeMessage<::Tile>(Arena*);
template<> ::UnitBuildTask* Arena::CreateMaybeMessage<::UnitBuildTask>(Arena*);
template<> ::UpdateCity* Arena::CreateMaybeMessage<::UpdateCity>(Arena*);
template<> ::UpdateGlobalData* Arena::CreateMaybeMessage<::UpdateGlobalData>(Arena*);
template<> ::UpdateMap* Arena::CreateMaybeMessage<::UpdateMap>(Arena*);
template<> ::UpdatePlayer* Arena::CreateMaybeMessage<::UpdatePlayer>(Arena*);
template<> ::UpdateUnit* Arena::CreateMaybeMessage<::UpdateUnit>(Arena*);
template<> ::WorkerCapability* Arena::CreateMaybeMessage<::WorkerCapability>(Arena*);
template<> ::WorkerTask* Arena::CreateMaybeMessage<::WorkerTask>(Arena*);
template<> ::WorkerTaskImprovement* Arena::CreateMaybeMessage<::WorkerTaskImprovement>(Arena*);
template<> ::WorkerTaskKind* Arena::CreateMaybeMessage<::WorkerTaskKind>(Arena*);
template<> ::Yield* Arena::CreateMaybeMessage<::Yield>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Era : int {
  Ancient = 0,
  Classical = 1,
  Medieval = 2,
  Renaissance = 3,
  Industrial = 4,
  Modern = 5,
  Future = 6,
  Era_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Era_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Era_IsValid(int value);
constexpr Era Era_MIN = Ancient;
constexpr Era Era_MAX = Future;
constexpr int Era_ARRAYSIZE = Era_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Era_descriptor();
template<typename T>
inline const std::string& Era_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Era>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Era_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Era_descriptor(), enum_t_value);
}
inline bool Era_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Era* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Era>(
    Era_descriptor(), name, value);
}
enum Terrain : int {
  Grassland = 0,
  Desert = 1,
  Ocean = 2,
  Plains = 3,
  Terrain_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Terrain_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Terrain_IsValid(int value);
constexpr Terrain Terrain_MIN = Grassland;
constexpr Terrain Terrain_MAX = Plains;
constexpr int Terrain_ARRAYSIZE = Terrain_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Terrain_descriptor();
template<typename T>
inline const std::string& Terrain_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Terrain>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Terrain_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Terrain_descriptor(), enum_t_value);
}
inline bool Terrain_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Terrain* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Terrain>(
    Terrain_descriptor(), name, value);
}
enum Visibility : int {
  Hidden = 0,
  Fogged = 1,
  Visible = 2,
  Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Visibility_IsValid(int value);
constexpr Visibility Visibility_MIN = Hidden;
constexpr Visibility Visibility_MAX = Visible;
constexpr int Visibility_ARRAYSIZE = Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_descriptor();
template<typename T>
inline const std::string& Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Visibility_descriptor(), enum_t_value);
}
inline bool Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility>(
    Visibility_descriptor(), name, value);
}
// ===================================================================

class Pos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Pos) */ {
 public:
  inline Pos() : Pos(nullptr) {}
  ~Pos() override;
  explicit constexpr Pos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pos(const Pos& from);
  Pos(Pos&& from) noexcept
    : Pos() {
    *this = ::std::move(from);
  }

  inline Pos& operator=(const Pos& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pos& operator=(Pos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pos& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pos* internal_default_instance() {
    return reinterpret_cast<const Pos*>(
               &_Pos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Pos& a, Pos& b) {
    a.Swap(&b);
  }
  inline void Swap(Pos* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pos* New() const final {
    return new Pos();
  }

  Pos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Pos& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Pos";
  }
  protected:
  explicit Pos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // uint32 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::uint32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::uint32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Pos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 x_;
  ::PROTOBUF_NAMESPACE_ID::uint32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class AnyClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AnyClient) */ {
 public:
  inline AnyClient() : AnyClient(nullptr) {}
  ~AnyClient() override;
  explicit constexpr AnyClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnyClient(const AnyClient& from);
  AnyClient(AnyClient&& from) noexcept
    : AnyClient() {
    *this = ::std::move(from);
  }

  inline AnyClient& operator=(const AnyClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyClient& operator=(AnyClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyClient& default_instance() {
    return *internal_default_instance();
  }
  enum PacketCase {
    kClientInfo = 1,
    PACKET_NOT_SET = 0,
  };

  static inline const AnyClient* internal_default_instance() {
    return reinterpret_cast<const AnyClient*>(
               &_AnyClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AnyClient& a, AnyClient& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyClient* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnyClient* New() const final {
    return new AnyClient();
  }

  AnyClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnyClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnyClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnyClient& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AnyClient";
  }
  protected:
  explicit AnyClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientInfoFieldNumber = 1,
  };
  // .ClientInfo clientInfo = 1;
  bool has_clientinfo() const;
  private:
  bool _internal_has_clientinfo() const;
  public:
  void clear_clientinfo();
  const ::ClientInfo& clientinfo() const;
  PROTOBUF_MUST_USE_RESULT ::ClientInfo* release_clientinfo();
  ::ClientInfo* mutable_clientinfo();
  void set_allocated_clientinfo(::ClientInfo* clientinfo);
  private:
  const ::ClientInfo& _internal_clientinfo() const;
  ::ClientInfo* _internal_mutable_clientinfo();
  public:
  void unsafe_arena_set_allocated_clientinfo(
      ::ClientInfo* clientinfo);
  ::ClientInfo* unsafe_arena_release_clientinfo();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:AnyClient)
 private:
  class _Internal;
  void set_has_clientinfo();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PacketUnion {
    constexpr PacketUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ClientInfo* clientinfo_;
  } packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class AnyServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AnyServer) */ {
 public:
  inline AnyServer() : AnyServer(nullptr) {}
  ~AnyServer() override;
  explicit constexpr AnyServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnyServer(const AnyServer& from);
  AnyServer(AnyServer&& from) noexcept
    : AnyServer() {
    *this = ::std::move(from);
  }

  inline AnyServer& operator=(const AnyServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyServer& operator=(AnyServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyServer& default_instance() {
    return *internal_default_instance();
  }
  enum PacketCase {
    kServerInfo = 1,
    kStartGame = 2,
    kLobbyError = 3,
    kUpdateGlobalData = 4,
    kUpdateMap = 5,
    kUpdateCity = 6,
    kUpdateUnit = 7,
    kUpdatePlayer = 8,
    kPathComputed = 9,
    PACKET_NOT_SET = 0,
  };

  static inline const AnyServer* internal_default_instance() {
    return reinterpret_cast<const AnyServer*>(
               &_AnyServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AnyServer& a, AnyServer& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyServer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnyServer* New() const final {
    return new AnyServer();
  }

  AnyServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnyServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnyServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnyServer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AnyServer";
  }
  protected:
  explicit AnyServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerInfoFieldNumber = 1,
    kStartGameFieldNumber = 2,
    kLobbyErrorFieldNumber = 3,
    kUpdateGlobalDataFieldNumber = 4,
    kUpdateMapFieldNumber = 5,
    kUpdateCityFieldNumber = 6,
    kUpdateUnitFieldNumber = 7,
    kUpdatePlayerFieldNumber = 8,
    kPathComputedFieldNumber = 9,
  };
  // .ServerInfo serverInfo = 1;
  bool has_serverinfo() const;
  private:
  bool _internal_has_serverinfo() const;
  public:
  void clear_serverinfo();
  const ::ServerInfo& serverinfo() const;
  PROTOBUF_MUST_USE_RESULT ::ServerInfo* release_serverinfo();
  ::ServerInfo* mutable_serverinfo();
  void set_allocated_serverinfo(::ServerInfo* serverinfo);
  private:
  const ::ServerInfo& _internal_serverinfo() const;
  ::ServerInfo* _internal_mutable_serverinfo();
  public:
  void unsafe_arena_set_allocated_serverinfo(
      ::ServerInfo* serverinfo);
  ::ServerInfo* unsafe_arena_release_serverinfo();

  // .StartGame startGame = 2;
  bool has_startgame() const;
  private:
  bool _internal_has_startgame() const;
  public:
  void clear_startgame();
  const ::StartGame& startgame() const;
  PROTOBUF_MUST_USE_RESULT ::StartGame* release_startgame();
  ::StartGame* mutable_startgame();
  void set_allocated_startgame(::StartGame* startgame);
  private:
  const ::StartGame& _internal_startgame() const;
  ::StartGame* _internal_mutable_startgame();
  public:
  void unsafe_arena_set_allocated_startgame(
      ::StartGame* startgame);
  ::StartGame* unsafe_arena_release_startgame();

  // .LobbyError lobbyError = 3;
  bool has_lobbyerror() const;
  private:
  bool _internal_has_lobbyerror() const;
  public:
  void clear_lobbyerror();
  const ::LobbyError& lobbyerror() const;
  PROTOBUF_MUST_USE_RESULT ::LobbyError* release_lobbyerror();
  ::LobbyError* mutable_lobbyerror();
  void set_allocated_lobbyerror(::LobbyError* lobbyerror);
  private:
  const ::LobbyError& _internal_lobbyerror() const;
  ::LobbyError* _internal_mutable_lobbyerror();
  public:
  void unsafe_arena_set_allocated_lobbyerror(
      ::LobbyError* lobbyerror);
  ::LobbyError* unsafe_arena_release_lobbyerror();

  // .UpdateGlobalData updateGlobalData = 4;
  bool has_updateglobaldata() const;
  private:
  bool _internal_has_updateglobaldata() const;
  public:
  void clear_updateglobaldata();
  const ::UpdateGlobalData& updateglobaldata() const;
  PROTOBUF_MUST_USE_RESULT ::UpdateGlobalData* release_updateglobaldata();
  ::UpdateGlobalData* mutable_updateglobaldata();
  void set_allocated_updateglobaldata(::UpdateGlobalData* updateglobaldata);
  private:
  const ::UpdateGlobalData& _internal_updateglobaldata() const;
  ::UpdateGlobalData* _internal_mutable_updateglobaldata();
  public:
  void unsafe_arena_set_allocated_updateglobaldata(
      ::UpdateGlobalData* updateglobaldata);
  ::UpdateGlobalData* unsafe_arena_release_updateglobaldata();

  // .UpdateMap updateMap = 5;
  bool has_updatemap() const;
  private:
  bool _internal_has_updatemap() const;
  public:
  void clear_updatemap();
  const ::UpdateMap& updatemap() const;
  PROTOBUF_MUST_USE_RESULT ::UpdateMap* release_updatemap();
  ::UpdateMap* mutable_updatemap();
  void set_allocated_updatemap(::UpdateMap* updatemap);
  private:
  const ::UpdateMap& _internal_updatemap() const;
  ::UpdateMap* _internal_mutable_updatemap();
  public:
  void unsafe_arena_set_allocated_updatemap(
      ::UpdateMap* updatemap);
  ::UpdateMap* unsafe_arena_release_updatemap();

  // .UpdateCity updateCity = 6;
  bool has_updatecity() const;
  private:
  bool _internal_has_updatecity() const;
  public:
  void clear_updatecity();
  const ::UpdateCity& updatecity() const;
  PROTOBUF_MUST_USE_RESULT ::UpdateCity* release_updatecity();
  ::UpdateCity* mutable_updatecity();
  void set_allocated_updatecity(::UpdateCity* updatecity);
  private:
  const ::UpdateCity& _internal_updatecity() const;
  ::UpdateCity* _internal_mutable_updatecity();
  public:
  void unsafe_arena_set_allocated_updatecity(
      ::UpdateCity* updatecity);
  ::UpdateCity* unsafe_arena_release_updatecity();

  // .UpdateUnit updateUnit = 7;
  bool has_updateunit() const;
  private:
  bool _internal_has_updateunit() const;
  public:
  void clear_updateunit();
  const ::UpdateUnit& updateunit() const;
  PROTOBUF_MUST_USE_RESULT ::UpdateUnit* release_updateunit();
  ::UpdateUnit* mutable_updateunit();
  void set_allocated_updateunit(::UpdateUnit* updateunit);
  private:
  const ::UpdateUnit& _internal_updateunit() const;
  ::UpdateUnit* _internal_mutable_updateunit();
  public:
  void unsafe_arena_set_allocated_updateunit(
      ::UpdateUnit* updateunit);
  ::UpdateUnit* unsafe_arena_release_updateunit();

  // .UpdatePlayer updatePlayer = 8;
  bool has_updateplayer() const;
  private:
  bool _internal_has_updateplayer() const;
  public:
  void clear_updateplayer();
  const ::UpdatePlayer& updateplayer() const;
  PROTOBUF_MUST_USE_RESULT ::UpdatePlayer* release_updateplayer();
  ::UpdatePlayer* mutable_updateplayer();
  void set_allocated_updateplayer(::UpdatePlayer* updateplayer);
  private:
  const ::UpdatePlayer& _internal_updateplayer() const;
  ::UpdatePlayer* _internal_mutable_updateplayer();
  public:
  void unsafe_arena_set_allocated_updateplayer(
      ::UpdatePlayer* updateplayer);
  ::UpdatePlayer* unsafe_arena_release_updateplayer();

  // .PathComputed pathComputed = 9;
  bool has_pathcomputed() const;
  private:
  bool _internal_has_pathcomputed() const;
  public:
  void clear_pathcomputed();
  const ::PathComputed& pathcomputed() const;
  PROTOBUF_MUST_USE_RESULT ::PathComputed* release_pathcomputed();
  ::PathComputed* mutable_pathcomputed();
  void set_allocated_pathcomputed(::PathComputed* pathcomputed);
  private:
  const ::PathComputed& _internal_pathcomputed() const;
  ::PathComputed* _internal_mutable_pathcomputed();
  public:
  void unsafe_arena_set_allocated_pathcomputed(
      ::PathComputed* pathcomputed);
  ::PathComputed* unsafe_arena_release_pathcomputed();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:AnyServer)
 private:
  class _Internal;
  void set_has_serverinfo();
  void set_has_startgame();
  void set_has_lobbyerror();
  void set_has_updateglobaldata();
  void set_has_updatemap();
  void set_has_updatecity();
  void set_has_updateunit();
  void set_has_updateplayer();
  void set_has_pathcomputed();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PacketUnion {
    constexpr PacketUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ServerInfo* serverinfo_;
    ::StartGame* startgame_;
    ::LobbyError* lobbyerror_;
    ::UpdateGlobalData* updateglobaldata_;
    ::UpdateMap* updatemap_;
    ::UpdateCity* updatecity_;
    ::UpdateUnit* updateunit_;
    ::UpdatePlayer* updateplayer_;
    ::PathComputed* pathcomputed_;
  } packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  ~ClientInfo() override;
  explicit constexpr ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientInfo* New() const final {
    return new ClientInfo();
  }

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() override;
  explicit constexpr ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const final {
    return new ServerInfo();
  }

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPlayersFieldNumber = 2,
    kPlayerIDFieldNumber = 1,
  };
  // repeated .PlayerInfo currentPlayers = 2;
  int currentplayers_size() const;
  private:
  int _internal_currentplayers_size() const;
  public:
  void clear_currentplayers();
  ::PlayerInfo* mutable_currentplayers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
      mutable_currentplayers();
  private:
  const ::PlayerInfo& _internal_currentplayers(int index) const;
  ::PlayerInfo* _internal_add_currentplayers();
  public:
  const ::PlayerInfo& currentplayers(int index) const;
  ::PlayerInfo* add_currentplayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
      currentplayers() const;

  // int32 playerID = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo > currentplayers_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class KickPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KickPlayer) */ {
 public:
  inline KickPlayer() : KickPlayer(nullptr) {}
  ~KickPlayer() override;
  explicit constexpr KickPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPlayer(const KickPlayer& from);
  KickPlayer(KickPlayer&& from) noexcept
    : KickPlayer() {
    *this = ::std::move(from);
  }

  inline KickPlayer& operator=(const KickPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPlayer& operator=(KickPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KickPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPlayer* internal_default_instance() {
    return reinterpret_cast<const KickPlayer*>(
               &_KickPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(KickPlayer& a, KickPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KickPlayer* New() const final {
    return new KickPlayer();
  }

  KickPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KickPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KickPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KickPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KickPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KickPlayer";
  }
  protected:
  explicit KickPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_MUST_USE_RESULT std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:KickPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetLeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetLeader) */ {
 public:
  inline SetLeader() : SetLeader(nullptr) {}
  ~SetLeader() override;
  explicit constexpr SetLeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLeader(const SetLeader& from);
  SetLeader(SetLeader&& from) noexcept
    : SetLeader() {
    *this = ::std::move(from);
  }

  inline SetLeader& operator=(const SetLeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLeader& operator=(SetLeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLeader* internal_default_instance() {
    return reinterpret_cast<const SetLeader*>(
               &_SetLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetLeader& a, SetLeader& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLeader* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetLeader* New() const final {
    return new SetLeader();
  }

  SetLeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetLeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetLeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetLeader";
  }
  protected:
  explicit SetLeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCivIDFieldNumber = 1,
    kLeaderFieldNumber = 2,
  };
  // string civID = 1;
  void clear_civid();
  const std::string& civid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_civid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_civid();
  PROTOBUF_MUST_USE_RESULT std::string* release_civid();
  void set_allocated_civid(std::string* civid);
  private:
  const std::string& _internal_civid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_civid(const std::string& value);
  std::string* _internal_mutable_civid();
  public:

  // string leader = 2;
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // @@protoc_insertion_point(class_scope:SetLeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr civid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class AdminStartGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminStartGame) */ {
 public:
  inline AdminStartGame() : AdminStartGame(nullptr) {}
  ~AdminStartGame() override;
  explicit constexpr AdminStartGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminStartGame(const AdminStartGame& from);
  AdminStartGame(AdminStartGame&& from) noexcept
    : AdminStartGame() {
    *this = ::std::move(from);
  }

  inline AdminStartGame& operator=(const AdminStartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminStartGame& operator=(AdminStartGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminStartGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminStartGame* internal_default_instance() {
    return reinterpret_cast<const AdminStartGame*>(
               &_AdminStartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AdminStartGame& a, AdminStartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminStartGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminStartGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdminStartGame* New() const final {
    return new AdminStartGame();
  }

  AdminStartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdminStartGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminStartGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdminStartGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminStartGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminStartGame";
  }
  protected:
  explicit AdminStartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AdminStartGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class LobbyError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LobbyError) */ {
 public:
  inline LobbyError() : LobbyError(nullptr) {}
  ~LobbyError() override;
  explicit constexpr LobbyError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyError(const LobbyError& from);
  LobbyError(LobbyError&& from) noexcept
    : LobbyError() {
    *this = ::std::move(from);
  }

  inline LobbyError& operator=(const LobbyError& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyError& operator=(LobbyError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyError& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyError* internal_default_instance() {
    return reinterpret_cast<const LobbyError*>(
               &_LobbyError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LobbyError& a, LobbyError& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LobbyError* New() const final {
    return new LobbyError();
  }

  LobbyError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LobbyError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LobbyError";
  }
  protected:
  explicit LobbyError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:LobbyError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class StartGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StartGame) */ {
 public:
  inline StartGame() : StartGame(nullptr) {}
  ~StartGame() override;
  explicit constexpr StartGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartGame(const StartGame& from);
  StartGame(StartGame&& from) noexcept
    : StartGame() {
    *this = ::std::move(from);
  }

  inline StartGame& operator=(const StartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartGame& operator=(StartGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartGame* internal_default_instance() {
    return reinterpret_cast<const StartGame*>(
               &_StartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StartGame& a, StartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(StartGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartGame* New() const final {
    return new StartGame();
  }

  StartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartGame";
  }
  protected:
  explicit StartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:StartGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit constexpr PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return new PlayerInfo();
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kCivIDFieldNumber = 2,
    kLeaderNameFieldNumber = 3,
    kScoreFieldNumber = 4,
    kIdFieldNumber = 5,
    kIsAdminFieldNumber = 6,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string civID = 2;
  void clear_civid();
  const std::string& civid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_civid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_civid();
  PROTOBUF_MUST_USE_RESULT std::string* release_civid();
  void set_allocated_civid(std::string* civid);
  private:
  const std::string& _internal_civid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_civid(const std::string& value);
  std::string* _internal_mutable_civid();
  public:

  // string leaderName = 3;
  void clear_leadername();
  const std::string& leadername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leadername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leadername();
  PROTOBUF_MUST_USE_RESULT std::string* release_leadername();
  void set_allocated_leadername(std::string* leadername);
  private:
  const std::string& _internal_leadername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leadername(const std::string& value);
  std::string* _internal_mutable_leadername();
  public:

  // int32 score = 4;
  void clear_score();
  ::PROTOBUF_NAMESPACE_ID::int32 score() const;
  void set_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_score() const;
  void _internal_set_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 id = 5;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isAdmin = 6;
  void clear_isadmin();
  bool isadmin() const;
  void set_isadmin(bool value);
  private:
  bool _internal_isadmin() const;
  void _internal_set_isadmin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr civid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leadername_;
  ::PROTOBUF_NAMESPACE_ID::int32 score_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  bool isadmin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateGlobalData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateGlobalData) */ {
 public:
  inline UpdateGlobalData() : UpdateGlobalData(nullptr) {}
  ~UpdateGlobalData() override;
  explicit constexpr UpdateGlobalData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateGlobalData(const UpdateGlobalData& from);
  UpdateGlobalData(UpdateGlobalData&& from) noexcept
    : UpdateGlobalData() {
    *this = ::std::move(from);
  }

  inline UpdateGlobalData& operator=(const UpdateGlobalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateGlobalData& operator=(UpdateGlobalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateGlobalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateGlobalData* internal_default_instance() {
    return reinterpret_cast<const UpdateGlobalData*>(
               &_UpdateGlobalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateGlobalData& a, UpdateGlobalData& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateGlobalData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateGlobalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateGlobalData* New() const final {
    return new UpdateGlobalData();
  }

  UpdateGlobalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateGlobalData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateGlobalData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateGlobalData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateGlobalData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateGlobalData";
  }
  protected:
  explicit UpdateGlobalData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kTurnFieldNumber = 2,
    kEraFieldNumber = 3,
  };
  // repeated .PlayerInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
      mutable_players();
  private:
  const ::PlayerInfo& _internal_players(int index) const;
  ::PlayerInfo* _internal_add_players();
  public:
  const ::PlayerInfo& players(int index) const;
  ::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
      players() const;

  // int32 turn = 2;
  void clear_turn();
  ::PROTOBUF_NAMESPACE_ID::int32 turn() const;
  void set_turn(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_turn() const;
  void _internal_set_turn(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .Era era = 3;
  void clear_era();
  ::Era era() const;
  void set_era(::Era value);
  private:
  ::Era _internal_era() const;
  void _internal_set_era(::Era value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateGlobalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo > players_;
  ::PROTOBUF_NAMESPACE_ID::int32 turn_;
  int era_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Improvement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Improvement) */ {
 public:
  inline Improvement() : Improvement(nullptr) {}
  ~Improvement() override;
  explicit constexpr Improvement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Improvement(const Improvement& from);
  Improvement(Improvement&& from) noexcept
    : Improvement() {
    *this = ::std::move(from);
  }

  inline Improvement& operator=(const Improvement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Improvement& operator=(Improvement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Improvement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Improvement* internal_default_instance() {
    return reinterpret_cast<const Improvement*>(
               &_Improvement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Improvement& a, Improvement& b) {
    a.Swap(&b);
  }
  inline void Swap(Improvement* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Improvement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Improvement* New() const final {
    return new Improvement();
  }

  Improvement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Improvement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Improvement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Improvement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Improvement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Improvement";
  }
  protected:
  explicit Improvement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCottageLevelFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string cottageLevel = 2;
  void clear_cottagelevel();
  const std::string& cottagelevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cottagelevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cottagelevel();
  PROTOBUF_MUST_USE_RESULT std::string* release_cottagelevel();
  void set_allocated_cottagelevel(std::string* cottagelevel);
  private:
  const std::string& _internal_cottagelevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cottagelevel(const std::string& value);
  std::string* _internal_mutable_cottagelevel();
  public:

  // @@protoc_insertion_point(class_scope:Improvement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cottagelevel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Yield final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Yield) */ {
 public:
  inline Yield() : Yield(nullptr) {}
  ~Yield() override;
  explicit constexpr Yield(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Yield(const Yield& from);
  Yield(Yield&& from) noexcept
    : Yield() {
    *this = ::std::move(from);
  }

  inline Yield& operator=(const Yield& from) {
    CopyFrom(from);
    return *this;
  }
  inline Yield& operator=(Yield&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Yield& default_instance() {
    return *internal_default_instance();
  }
  static inline const Yield* internal_default_instance() {
    return reinterpret_cast<const Yield*>(
               &_Yield_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Yield& a, Yield& b) {
    a.Swap(&b);
  }
  inline void Swap(Yield* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Yield* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Yield* New() const final {
    return new Yield();
  }

  Yield* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Yield>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Yield& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Yield& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Yield* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Yield";
  }
  protected:
  explicit Yield(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHammersFieldNumber = 1,
    kCommerceFieldNumber = 2,
    kFoodFieldNumber = 3,
  };
  // int32 hammers = 1;
  void clear_hammers();
  ::PROTOBUF_NAMESPACE_ID::int32 hammers() const;
  void set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hammers() const;
  void _internal_set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 commerce = 2;
  void clear_commerce();
  ::PROTOBUF_NAMESPACE_ID::int32 commerce() const;
  void set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_commerce() const;
  void _internal_set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 food = 3;
  void clear_food();
  ::PROTOBUF_NAMESPACE_ID::int32 food() const;
  void set_food(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_food() const;
  void _internal_set_food(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Yield)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 hammers_;
  ::PROTOBUF_NAMESPACE_ID::int32 commerce_;
  ::PROTOBUF_NAMESPACE_ID::int32 food_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Tile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {}
  ~Tile() override;
  explicit constexpr Tile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tile* New() const final {
    return new Tile();
  }

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Tile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImprovementsFieldNumber = 4,
    kYieldFieldNumber = 5,
    kTerrainFieldNumber = 1,
    kForestedFieldNumber = 2,
    kHilledFieldNumber = 3,
    kHasOwnerFieldNumber = 7,
    kIsWorkedFieldNumber = 8,
    kOwnerIDFieldNumber = 6,
  };
  // repeated .Improvement improvements = 4;
  int improvements_size() const;
  private:
  int _internal_improvements_size() const;
  public:
  void clear_improvements();
  ::Improvement* mutable_improvements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >*
      mutable_improvements();
  private:
  const ::Improvement& _internal_improvements(int index) const;
  ::Improvement* _internal_add_improvements();
  public:
  const ::Improvement& improvements(int index) const;
  ::Improvement* add_improvements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >&
      improvements() const;

  // .Yield yield = 5;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;
  public:
  void clear_yield();
  const ::Yield& yield() const;
  PROTOBUF_MUST_USE_RESULT ::Yield* release_yield();
  ::Yield* mutable_yield();
  void set_allocated_yield(::Yield* yield);
  private:
  const ::Yield& _internal_yield() const;
  ::Yield* _internal_mutable_yield();
  public:
  void unsafe_arena_set_allocated_yield(
      ::Yield* yield);
  ::Yield* unsafe_arena_release_yield();

  // .Terrain terrain = 1;
  void clear_terrain();
  ::Terrain terrain() const;
  void set_terrain(::Terrain value);
  private:
  ::Terrain _internal_terrain() const;
  void _internal_set_terrain(::Terrain value);
  public:

  // bool forested = 2;
  void clear_forested();
  bool forested() const;
  void set_forested(bool value);
  private:
  bool _internal_forested() const;
  void _internal_set_forested(bool value);
  public:

  // bool hilled = 3;
  void clear_hilled();
  bool hilled() const;
  void set_hilled(bool value);
  private:
  bool _internal_hilled() const;
  void _internal_set_hilled(bool value);
  public:

  // bool hasOwner = 7;
  void clear_hasowner();
  bool hasowner() const;
  void set_hasowner(bool value);
  private:
  bool _internal_hasowner() const;
  void _internal_set_hasowner(bool value);
  public:

  // bool isWorked = 8;
  void clear_isworked();
  bool isworked() const;
  void set_isworked(bool value);
  private:
  bool _internal_isworked() const;
  void _internal_set_isworked(bool value);
  public:

  // int32 ownerID = 6;
  void clear_ownerid();
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid() const;
  void set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ownerid() const;
  void _internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Tile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement > improvements_;
  ::Yield* yield_;
  int terrain_;
  bool forested_;
  bool hilled_;
  bool hasowner_;
  bool isworked_;
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateMap) */ {
 public:
  inline UpdateMap() : UpdateMap(nullptr) {}
  ~UpdateMap() override;
  explicit constexpr UpdateMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMap(const UpdateMap& from);
  UpdateMap(UpdateMap&& from) noexcept
    : UpdateMap() {
    *this = ::std::move(from);
  }

  inline UpdateMap& operator=(const UpdateMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMap& operator=(UpdateMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMap* internal_default_instance() {
    return reinterpret_cast<const UpdateMap*>(
               &_UpdateMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateMap& a, UpdateMap& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMap* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateMap* New() const final {
    return new UpdateMap();
  }

  UpdateMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateMap";
  }
  protected:
  explicit UpdateMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 3,
    kVisibilityFieldNumber = 4,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // repeated .Tile tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::Tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
      mutable_tiles();
  private:
  const ::Tile& _internal_tiles(int index) const;
  ::Tile* _internal_add_tiles();
  public:
  const ::Tile& tiles(int index) const;
  ::Tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
      tiles() const;

  // repeated .Visibility visibility = 4;
  int visibility_size() const;
  private:
  int _internal_visibility_size() const;
  public:
  void clear_visibility();
  private:
  ::Visibility _internal_visibility(int index) const;
  void _internal_add_visibility(::Visibility value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_visibility();
  public:
  ::Visibility visibility(int index) const;
  void set_visibility(int index, ::Visibility value);
  void add_visibility(::Visibility value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& visibility() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_visibility();

  // uint32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile > tiles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> visibility_;
  mutable std::atomic<int> _visibility_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UnitBuildTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UnitBuildTask) */ {
 public:
  inline UnitBuildTask() : UnitBuildTask(nullptr) {}
  ~UnitBuildTask() override;
  explicit constexpr UnitBuildTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnitBuildTask(const UnitBuildTask& from);
  UnitBuildTask(UnitBuildTask&& from) noexcept
    : UnitBuildTask() {
    *this = ::std::move(from);
  }

  inline UnitBuildTask& operator=(const UnitBuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitBuildTask& operator=(UnitBuildTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnitBuildTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnitBuildTask* internal_default_instance() {
    return reinterpret_cast<const UnitBuildTask*>(
               &_UnitBuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UnitBuildTask& a, UnitBuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitBuildTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitBuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitBuildTask* New() const final {
    return new UnitBuildTask();
  }

  UnitBuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitBuildTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnitBuildTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnitBuildTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitBuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UnitBuildTask";
  }
  protected:
  explicit UnitBuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitKindIDFieldNumber = 1,
  };
  // string unitKindID = 1;
  void clear_unitkindid();
  const std::string& unitkindid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unitkindid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unitkindid();
  PROTOBUF_MUST_USE_RESULT std::string* release_unitkindid();
  void set_allocated_unitkindid(std::string* unitkindid);
  private:
  const std::string& _internal_unitkindid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unitkindid(const std::string& value);
  std::string* _internal_mutable_unitkindid();
  public:

  // @@protoc_insertion_point(class_scope:UnitBuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unitkindid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class BuildingBuildTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildingBuildTask) */ {
 public:
  inline BuildingBuildTask() : BuildingBuildTask(nullptr) {}
  ~BuildingBuildTask() override;
  explicit constexpr BuildingBuildTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuildingBuildTask(const BuildingBuildTask& from);
  BuildingBuildTask(BuildingBuildTask&& from) noexcept
    : BuildingBuildTask() {
    *this = ::std::move(from);
  }

  inline BuildingBuildTask& operator=(const BuildingBuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildingBuildTask& operator=(BuildingBuildTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuildingBuildTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildingBuildTask* internal_default_instance() {
    return reinterpret_cast<const BuildingBuildTask*>(
               &_BuildingBuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BuildingBuildTask& a, BuildingBuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildingBuildTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildingBuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildingBuildTask* New() const final {
    return new BuildingBuildTask();
  }

  BuildingBuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildingBuildTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuildingBuildTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BuildingBuildTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildingBuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildingBuildTask";
  }
  protected:
  explicit BuildingBuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildingNameFieldNumber = 1,
  };
  // string buildingName = 1;
  void clear_buildingname();
  const std::string& buildingname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buildingname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buildingname();
  PROTOBUF_MUST_USE_RESULT std::string* release_buildingname();
  void set_allocated_buildingname(std::string* buildingname);
  private:
  const std::string& _internal_buildingname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buildingname(const std::string& value);
  std::string* _internal_mutable_buildingname();
  public:

  // @@protoc_insertion_point(class_scope:BuildingBuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buildingname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class BuildTaskKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildTaskKind) */ {
 public:
  inline BuildTaskKind() : BuildTaskKind(nullptr) {}
  ~BuildTaskKind() override;
  explicit constexpr BuildTaskKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuildTaskKind(const BuildTaskKind& from);
  BuildTaskKind(BuildTaskKind&& from) noexcept
    : BuildTaskKind() {
    *this = ::std::move(from);
  }

  inline BuildTaskKind& operator=(const BuildTaskKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildTaskKind& operator=(BuildTaskKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuildTaskKind& default_instance() {
    return *internal_default_instance();
  }
  enum TaskCase {
    kUnit = 1,
    kBuilding = 2,
    TASK_NOT_SET = 0,
  };

  static inline const BuildTaskKind* internal_default_instance() {
    return reinterpret_cast<const BuildTaskKind*>(
               &_BuildTaskKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BuildTaskKind& a, BuildTaskKind& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildTaskKind* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildTaskKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildTaskKind* New() const final {
    return new BuildTaskKind();
  }

  BuildTaskKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildTaskKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuildTaskKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BuildTaskKind& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildTaskKind* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildTaskKind";
  }
  protected:
  explicit BuildTaskKind(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kBuildingFieldNumber = 2,
  };
  // .UnitBuildTask unit = 1;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const ::UnitBuildTask& unit() const;
  PROTOBUF_MUST_USE_RESULT ::UnitBuildTask* release_unit();
  ::UnitBuildTask* mutable_unit();
  void set_allocated_unit(::UnitBuildTask* unit);
  private:
  const ::UnitBuildTask& _internal_unit() const;
  ::UnitBuildTask* _internal_mutable_unit();
  public:
  void unsafe_arena_set_allocated_unit(
      ::UnitBuildTask* unit);
  ::UnitBuildTask* unsafe_arena_release_unit();

  // .BuildingBuildTask building = 2;
  bool has_building() const;
  private:
  bool _internal_has_building() const;
  public:
  void clear_building();
  const ::BuildingBuildTask& building() const;
  PROTOBUF_MUST_USE_RESULT ::BuildingBuildTask* release_building();
  ::BuildingBuildTask* mutable_building();
  void set_allocated_building(::BuildingBuildTask* building);
  private:
  const ::BuildingBuildTask& _internal_building() const;
  ::BuildingBuildTask* _internal_mutable_building();
  public:
  void unsafe_arena_set_allocated_building(
      ::BuildingBuildTask* building);
  ::BuildingBuildTask* unsafe_arena_release_building();

  void clear_task();
  TaskCase task_case() const;
  // @@protoc_insertion_point(class_scope:BuildTaskKind)
 private:
  class _Internal;
  void set_has_unit();
  void set_has_building();

  inline bool has_task() const;
  inline void clear_has_task();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TaskUnion {
    constexpr TaskUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::UnitBuildTask* unit_;
    ::BuildingBuildTask* building_;
  } task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class BuildTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildTask) */ {
 public:
  inline BuildTask() : BuildTask(nullptr) {}
  ~BuildTask() override;
  explicit constexpr BuildTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuildTask(const BuildTask& from);
  BuildTask(BuildTask&& from) noexcept
    : BuildTask() {
    *this = ::std::move(from);
  }

  inline BuildTask& operator=(const BuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildTask& operator=(BuildTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuildTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildTask* internal_default_instance() {
    return reinterpret_cast<const BuildTask*>(
               &_BuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BuildTask& a, BuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildTask* New() const final {
    return new BuildTask();
  }

  BuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuildTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BuildTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildTask";
  }
  protected:
  explicit BuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kProgressFieldNumber = 2,
    kCostFieldNumber = 3,
  };
  // .BuildTaskKind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const ::BuildTaskKind& kind() const;
  PROTOBUF_MUST_USE_RESULT ::BuildTaskKind* release_kind();
  ::BuildTaskKind* mutable_kind();
  void set_allocated_kind(::BuildTaskKind* kind);
  private:
  const ::BuildTaskKind& _internal_kind() const;
  ::BuildTaskKind* _internal_mutable_kind();
  public:
  void unsafe_arena_set_allocated_kind(
      ::BuildTaskKind* kind);
  ::BuildTaskKind* unsafe_arena_release_kind();

  // int32 progress = 2;
  void clear_progress();
  ::PROTOBUF_NAMESPACE_ID::int32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_progress() const;
  void _internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cost = 3;
  void clear_cost();
  ::PROTOBUF_NAMESPACE_ID::int32 cost() const;
  void set_cost(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cost() const;
  void _internal_set_cost(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::BuildTaskKind* kind_;
  ::PROTOBUF_NAMESPACE_ID::int32 progress_;
  ::PROTOBUF_NAMESPACE_ID::int32 cost_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateCity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateCity) */ {
 public:
  inline UpdateCity() : UpdateCity(nullptr) {}
  ~UpdateCity() override;
  explicit constexpr UpdateCity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCity(const UpdateCity& from);
  UpdateCity(UpdateCity&& from) noexcept
    : UpdateCity() {
    *this = ::std::move(from);
  }

  inline UpdateCity& operator=(const UpdateCity& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCity& operator=(UpdateCity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCity& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCity* internal_default_instance() {
    return reinterpret_cast<const UpdateCity*>(
               &_UpdateCity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateCity& a, UpdateCity& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCity* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateCity* New() const final {
    return new UpdateCity();
  }

  UpdateCity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateCity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateCity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateCity";
  }
  protected:
  explicit UpdateCity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildingNamesFieldNumber = 9,
    kNameFieldNumber = 2,
    kPosFieldNumber = 1,
    kBuildTaskFieldNumber = 4,
    kYieldFieldNumber = 5,
    kOwnerIDFieldNumber = 3,
    kCultureFieldNumber = 6,
    kCultureNeededFieldNumber = 7,
    kIdFieldNumber = 8,
    kPopulationFieldNumber = 10,
    kStoredFoodFieldNumber = 11,
    kFoodNeededForGrowthFieldNumber = 12,
    kConsumedFoodFieldNumber = 13,
  };
  // repeated string buildingNames = 9;
  int buildingnames_size() const;
  private:
  int _internal_buildingnames_size() const;
  public:
  void clear_buildingnames();
  const std::string& buildingnames(int index) const;
  std::string* mutable_buildingnames(int index);
  void set_buildingnames(int index, const std::string& value);
  void set_buildingnames(int index, std::string&& value);
  void set_buildingnames(int index, const char* value);
  void set_buildingnames(int index, const char* value, size_t size);
  std::string* add_buildingnames();
  void add_buildingnames(const std::string& value);
  void add_buildingnames(std::string&& value);
  void add_buildingnames(const char* value);
  void add_buildingnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& buildingnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_buildingnames();
  private:
  const std::string& _internal_buildingnames(int index) const;
  std::string* _internal_add_buildingnames();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Pos pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Pos& pos() const;
  PROTOBUF_MUST_USE_RESULT ::Pos* release_pos();
  ::Pos* mutable_pos();
  void set_allocated_pos(::Pos* pos);
  private:
  const ::Pos& _internal_pos() const;
  ::Pos* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Pos* pos);
  ::Pos* unsafe_arena_release_pos();

  // .BuildTask buildTask = 4;
  bool has_buildtask() const;
  private:
  bool _internal_has_buildtask() const;
  public:
  void clear_buildtask();
  const ::BuildTask& buildtask() const;
  PROTOBUF_MUST_USE_RESULT ::BuildTask* release_buildtask();
  ::BuildTask* mutable_buildtask();
  void set_allocated_buildtask(::BuildTask* buildtask);
  private:
  const ::BuildTask& _internal_buildtask() const;
  ::BuildTask* _internal_mutable_buildtask();
  public:
  void unsafe_arena_set_allocated_buildtask(
      ::BuildTask* buildtask);
  ::BuildTask* unsafe_arena_release_buildtask();

  // .Yield yield = 5;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;
  public:
  void clear_yield();
  const ::Yield& yield() const;
  PROTOBUF_MUST_USE_RESULT ::Yield* release_yield();
  ::Yield* mutable_yield();
  void set_allocated_yield(::Yield* yield);
  private:
  const ::Yield& _internal_yield() const;
  ::Yield* _internal_mutable_yield();
  public:
  void unsafe_arena_set_allocated_yield(
      ::Yield* yield);
  ::Yield* unsafe_arena_release_yield();

  // int32 ownerID = 3;
  void clear_ownerid();
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid() const;
  void set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ownerid() const;
  void _internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 culture = 6;
  void clear_culture();
  ::PROTOBUF_NAMESPACE_ID::int32 culture() const;
  void set_culture(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_culture() const;
  void _internal_set_culture(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cultureNeeded = 7;
  void clear_cultureneeded();
  ::PROTOBUF_NAMESPACE_ID::int32 cultureneeded() const;
  void set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cultureneeded() const;
  void _internal_set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 id = 8;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 population = 10;
  void clear_population();
  ::PROTOBUF_NAMESPACE_ID::int32 population() const;
  void set_population(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_population() const;
  void _internal_set_population(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 storedFood = 11;
  void clear_storedfood();
  ::PROTOBUF_NAMESPACE_ID::int32 storedfood() const;
  void set_storedfood(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_storedfood() const;
  void _internal_set_storedfood(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 foodNeededForGrowth = 12;
  void clear_foodneededforgrowth();
  ::PROTOBUF_NAMESPACE_ID::int32 foodneededforgrowth() const;
  void set_foodneededforgrowth(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_foodneededforgrowth() const;
  void _internal_set_foodneededforgrowth(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 consumedFood = 13;
  void clear_consumedfood();
  ::PROTOBUF_NAMESPACE_ID::int32 consumedfood() const;
  void set_consumedfood(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_consumedfood() const;
  void _internal_set_consumedfood(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateCity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> buildingnames_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Pos* pos_;
  ::BuildTask* buildtask_;
  ::Yield* yield_;
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 culture_;
  ::PROTOBUF_NAMESPACE_ID::int32 cultureneeded_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 population_;
  ::PROTOBUF_NAMESPACE_ID::int32 storedfood_;
  ::PROTOBUF_NAMESPACE_ID::int32 foodneededforgrowth_;
  ::PROTOBUF_NAMESPACE_ID::int32 consumedfood_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit constexpr Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return new Path();
  }

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Path& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 1,
  };
  // repeated uint32 positions = 1;
  int positions_size() const;
  private:
  int _internal_positions_size() const;
  public:
  void clear_positions();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_positions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_positions() const;
  void _internal_add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_positions();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 positions(int index) const;
  void set_positions(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_positions();

  // @@protoc_insertion_point(class_scope:Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > positions_;
  mutable std::atomic<int> _positions_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class FoundCityCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FoundCityCapability) */ {
 public:
  inline FoundCityCapability() : FoundCityCapability(nullptr) {}
  ~FoundCityCapability() override;
  explicit constexpr FoundCityCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FoundCityCapability(const FoundCityCapability& from);
  FoundCityCapability(FoundCityCapability&& from) noexcept
    : FoundCityCapability() {
    *this = ::std::move(from);
  }

  inline FoundCityCapability& operator=(const FoundCityCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline FoundCityCapability& operator=(FoundCityCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FoundCityCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const FoundCityCapability* internal_default_instance() {
    return reinterpret_cast<const FoundCityCapability*>(
               &_FoundCityCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FoundCityCapability& a, FoundCityCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(FoundCityCapability* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FoundCityCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FoundCityCapability* New() const final {
    return new FoundCityCapability();
  }

  FoundCityCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FoundCityCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FoundCityCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FoundCityCapability& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FoundCityCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FoundCityCapability";
  }
  protected:
  explicit FoundCityCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:FoundCityCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerTaskImprovement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerTaskImprovement) */ {
 public:
  inline WorkerTaskImprovement() : WorkerTaskImprovement(nullptr) {}
  ~WorkerTaskImprovement() override;
  explicit constexpr WorkerTaskImprovement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerTaskImprovement(const WorkerTaskImprovement& from);
  WorkerTaskImprovement(WorkerTaskImprovement&& from) noexcept
    : WorkerTaskImprovement() {
    *this = ::std::move(from);
  }

  inline WorkerTaskImprovement& operator=(const WorkerTaskImprovement& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerTaskImprovement& operator=(WorkerTaskImprovement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerTaskImprovement& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerTaskImprovement* internal_default_instance() {
    return reinterpret_cast<const WorkerTaskImprovement*>(
               &_WorkerTaskImprovement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WorkerTaskImprovement& a, WorkerTaskImprovement& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerTaskImprovement* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerTaskImprovement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerTaskImprovement* New() const final {
    return new WorkerTaskImprovement();
  }

  WorkerTaskImprovement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerTaskImprovement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerTaskImprovement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerTaskImprovement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerTaskImprovement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerTaskImprovement";
  }
  protected:
  explicit WorkerTaskImprovement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImprovementIDFieldNumber = 1,
  };
  // string improvementID = 1;
  void clear_improvementid();
  const std::string& improvementid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_improvementid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_improvementid();
  PROTOBUF_MUST_USE_RESULT std::string* release_improvementid();
  void set_allocated_improvementid(std::string* improvementid);
  private:
  const std::string& _internal_improvementid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_improvementid(const std::string& value);
  std::string* _internal_mutable_improvementid();
  public:

  // @@protoc_insertion_point(class_scope:WorkerTaskImprovement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr improvementid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerTaskKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerTaskKind) */ {
 public:
  inline WorkerTaskKind() : WorkerTaskKind(nullptr) {}
  ~WorkerTaskKind() override;
  explicit constexpr WorkerTaskKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerTaskKind(const WorkerTaskKind& from);
  WorkerTaskKind(WorkerTaskKind&& from) noexcept
    : WorkerTaskKind() {
    *this = ::std::move(from);
  }

  inline WorkerTaskKind& operator=(const WorkerTaskKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerTaskKind& operator=(WorkerTaskKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerTaskKind& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kBuildImprovement = 1,
    KIND_NOT_SET = 0,
  };

  static inline const WorkerTaskKind* internal_default_instance() {
    return reinterpret_cast<const WorkerTaskKind*>(
               &_WorkerTaskKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WorkerTaskKind& a, WorkerTaskKind& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerTaskKind* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerTaskKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerTaskKind* New() const final {
    return new WorkerTaskKind();
  }

  WorkerTaskKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerTaskKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerTaskKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerTaskKind& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerTaskKind* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerTaskKind";
  }
  protected:
  explicit WorkerTaskKind(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildImprovementFieldNumber = 1,
  };
  // .WorkerTaskImprovement buildImprovement = 1;
  bool has_buildimprovement() const;
  private:
  bool _internal_has_buildimprovement() const;
  public:
  void clear_buildimprovement();
  const ::WorkerTaskImprovement& buildimprovement() const;
  PROTOBUF_MUST_USE_RESULT ::WorkerTaskImprovement* release_buildimprovement();
  ::WorkerTaskImprovement* mutable_buildimprovement();
  void set_allocated_buildimprovement(::WorkerTaskImprovement* buildimprovement);
  private:
  const ::WorkerTaskImprovement& _internal_buildimprovement() const;
  ::WorkerTaskImprovement* _internal_mutable_buildimprovement();
  public:
  void unsafe_arena_set_allocated_buildimprovement(
      ::WorkerTaskImprovement* buildimprovement);
  ::WorkerTaskImprovement* unsafe_arena_release_buildimprovement();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:WorkerTaskKind)
 private:
  class _Internal;
  void set_has_buildimprovement();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::WorkerTaskImprovement* buildimprovement_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerTask) */ {
 public:
  inline WorkerTask() : WorkerTask(nullptr) {}
  ~WorkerTask() override;
  explicit constexpr WorkerTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerTask(const WorkerTask& from);
  WorkerTask(WorkerTask&& from) noexcept
    : WorkerTask() {
    *this = ::std::move(from);
  }

  inline WorkerTask& operator=(const WorkerTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerTask& operator=(WorkerTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerTask* internal_default_instance() {
    return reinterpret_cast<const WorkerTask*>(
               &_WorkerTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(WorkerTask& a, WorkerTask& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerTask* New() const final {
    return new WorkerTask();
  }

  WorkerTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerTask";
  }
  protected:
  explicit WorkerTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKindFieldNumber = 3,
    kTurnsLeftFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .WorkerTaskKind kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const ::WorkerTaskKind& kind() const;
  PROTOBUF_MUST_USE_RESULT ::WorkerTaskKind* release_kind();
  ::WorkerTaskKind* mutable_kind();
  void set_allocated_kind(::WorkerTaskKind* kind);
  private:
  const ::WorkerTaskKind& _internal_kind() const;
  ::WorkerTaskKind* _internal_mutable_kind();
  public:
  void unsafe_arena_set_allocated_kind(
      ::WorkerTaskKind* kind);
  ::WorkerTaskKind* unsafe_arena_release_kind();

  // int32 turnsLeft = 2;
  void clear_turnsleft();
  ::PROTOBUF_NAMESPACE_ID::int32 turnsleft() const;
  void set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_turnsleft() const;
  void _internal_set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::WorkerTaskKind* kind_;
  ::PROTOBUF_NAMESPACE_ID::int32 turnsleft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerCapability) */ {
 public:
  inline WorkerCapability() : WorkerCapability(nullptr) {}
  ~WorkerCapability() override;
  explicit constexpr WorkerCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerCapability(const WorkerCapability& from);
  WorkerCapability(WorkerCapability&& from) noexcept
    : WorkerCapability() {
    *this = ::std::move(from);
  }

  inline WorkerCapability& operator=(const WorkerCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerCapability& operator=(WorkerCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerCapability* internal_default_instance() {
    return reinterpret_cast<const WorkerCapability*>(
               &_WorkerCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(WorkerCapability& a, WorkerCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerCapability* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerCapability* New() const final {
    return new WorkerCapability();
  }

  WorkerCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerCapability& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerCapability";
  }
  protected:
  explicit WorkerCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPossibleTasksFieldNumber = 2,
    kCurrentTaskFieldNumber = 1,
  };
  // repeated .WorkerTask possibleTasks = 2;
  int possibletasks_size() const;
  private:
  int _internal_possibletasks_size() const;
  public:
  void clear_possibletasks();
  ::WorkerTask* mutable_possibletasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >*
      mutable_possibletasks();
  private:
  const ::WorkerTask& _internal_possibletasks(int index) const;
  ::WorkerTask* _internal_add_possibletasks();
  public:
  const ::WorkerTask& possibletasks(int index) const;
  ::WorkerTask* add_possibletasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >&
      possibletasks() const;

  // .WorkerTask currentTask = 1;
  bool has_currenttask() const;
  private:
  bool _internal_has_currenttask() const;
  public:
  void clear_currenttask();
  const ::WorkerTask& currenttask() const;
  PROTOBUF_MUST_USE_RESULT ::WorkerTask* release_currenttask();
  ::WorkerTask* mutable_currenttask();
  void set_allocated_currenttask(::WorkerTask* currenttask);
  private:
  const ::WorkerTask& _internal_currenttask() const;
  ::WorkerTask* _internal_mutable_currenttask();
  public:
  void unsafe_arena_set_allocated_currenttask(
      ::WorkerTask* currenttask);
  ::WorkerTask* unsafe_arena_release_currenttask();

  // @@protoc_insertion_point(class_scope:WorkerCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask > possibletasks_;
  ::WorkerTask* currenttask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class CarryUnitsCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarryUnitsCapability) */ {
 public:
  inline CarryUnitsCapability() : CarryUnitsCapability(nullptr) {}
  ~CarryUnitsCapability() override;
  explicit constexpr CarryUnitsCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarryUnitsCapability(const CarryUnitsCapability& from);
  CarryUnitsCapability(CarryUnitsCapability&& from) noexcept
    : CarryUnitsCapability() {
    *this = ::std::move(from);
  }

  inline CarryUnitsCapability& operator=(const CarryUnitsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarryUnitsCapability& operator=(CarryUnitsCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarryUnitsCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarryUnitsCapability* internal_default_instance() {
    return reinterpret_cast<const CarryUnitsCapability*>(
               &_CarryUnitsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CarryUnitsCapability& a, CarryUnitsCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(CarryUnitsCapability* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarryUnitsCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarryUnitsCapability* New() const final {
    return new CarryUnitsCapability();
  }

  CarryUnitsCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarryUnitsCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarryUnitsCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CarryUnitsCapability& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarryUnitsCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarryUnitsCapability";
  }
  protected:
  explicit CarryUnitsCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarryingUnitIDsFieldNumber = 1,
  };
  // repeated int32 carryingUnitIDs = 1;
  int carryingunitids_size() const;
  private:
  int _internal_carryingunitids_size() const;
  public:
  void clear_carryingunitids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_carryingunitids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_carryingunitids() const;
  void _internal_add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_carryingunitids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 carryingunitids(int index) const;
  void set_carryingunitids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      carryingunitids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_carryingunitids();

  // @@protoc_insertion_point(class_scope:CarryUnitsCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > carryingunitids_;
  mutable std::atomic<int> _carryingunitids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Capability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Capability) */ {
 public:
  inline Capability() : Capability(nullptr) {}
  ~Capability() override;
  explicit constexpr Capability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Capability(const Capability& from);
  Capability(Capability&& from) noexcept
    : Capability() {
    *this = ::std::move(from);
  }

  inline Capability& operator=(const Capability& from) {
    CopyFrom(from);
    return *this;
  }
  inline Capability& operator=(Capability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Capability& default_instance() {
    return *internal_default_instance();
  }
  enum CapCase {
    kFoundCity = 1,
    kWorker = 2,
    kCarryUnits = 3,
    CAP_NOT_SET = 0,
  };

  static inline const Capability* internal_default_instance() {
    return reinterpret_cast<const Capability*>(
               &_Capability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Capability& a, Capability& b) {
    a.Swap(&b);
  }
  inline void Swap(Capability* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Capability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Capability* New() const final {
    return new Capability();
  }

  Capability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Capability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Capability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Capability& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Capability";
  }
  protected:
  explicit Capability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFoundCityFieldNumber = 1,
    kWorkerFieldNumber = 2,
    kCarryUnitsFieldNumber = 3,
  };
  // .FoundCityCapability foundCity = 1;
  bool has_foundcity() const;
  private:
  bool _internal_has_foundcity() const;
  public:
  void clear_foundcity();
  const ::FoundCityCapability& foundcity() const;
  PROTOBUF_MUST_USE_RESULT ::FoundCityCapability* release_foundcity();
  ::FoundCityCapability* mutable_foundcity();
  void set_allocated_foundcity(::FoundCityCapability* foundcity);
  private:
  const ::FoundCityCapability& _internal_foundcity() const;
  ::FoundCityCapability* _internal_mutable_foundcity();
  public:
  void unsafe_arena_set_allocated_foundcity(
      ::FoundCityCapability* foundcity);
  ::FoundCityCapability* unsafe_arena_release_foundcity();

  // .WorkerCapability worker = 2;
  bool has_worker() const;
  private:
  bool _internal_has_worker() const;
  public:
  void clear_worker();
  const ::WorkerCapability& worker() const;
  PROTOBUF_MUST_USE_RESULT ::WorkerCapability* release_worker();
  ::WorkerCapability* mutable_worker();
  void set_allocated_worker(::WorkerCapability* worker);
  private:
  const ::WorkerCapability& _internal_worker() const;
  ::WorkerCapability* _internal_mutable_worker();
  public:
  void unsafe_arena_set_allocated_worker(
      ::WorkerCapability* worker);
  ::WorkerCapability* unsafe_arena_release_worker();

  // .CarryUnitsCapability carryUnits = 3;
  bool has_carryunits() const;
  private:
  bool _internal_has_carryunits() const;
  public:
  void clear_carryunits();
  const ::CarryUnitsCapability& carryunits() const;
  PROTOBUF_MUST_USE_RESULT ::CarryUnitsCapability* release_carryunits();
  ::CarryUnitsCapability* mutable_carryunits();
  void set_allocated_carryunits(::CarryUnitsCapability* carryunits);
  private:
  const ::CarryUnitsCapability& _internal_carryunits() const;
  ::CarryUnitsCapability* _internal_mutable_carryunits();
  public:
  void unsafe_arena_set_allocated_carryunits(
      ::CarryUnitsCapability* carryunits);
  ::CarryUnitsCapability* unsafe_arena_release_carryunits();

  void clear_cap();
  CapCase cap_case() const;
  // @@protoc_insertion_point(class_scope:Capability)
 private:
  class _Internal;
  void set_has_foundcity();
  void set_has_worker();
  void set_has_carryunits();

  inline bool has_cap() const;
  inline void clear_has_cap();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CapUnion {
    constexpr CapUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::FoundCityCapability* foundcity_;
    ::WorkerCapability* worker_;
    ::CarryUnitsCapability* carryunits_;
  } cap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateUnit) */ {
 public:
  inline UpdateUnit() : UpdateUnit(nullptr) {}
  ~UpdateUnit() override;
  explicit constexpr UpdateUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUnit(const UpdateUnit& from);
  UpdateUnit(UpdateUnit&& from) noexcept
    : UpdateUnit() {
    *this = ::std::move(from);
  }

  inline UpdateUnit& operator=(const UpdateUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUnit& operator=(UpdateUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUnit* internal_default_instance() {
    return reinterpret_cast<const UpdateUnit*>(
               &_UpdateUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateUnit& a, UpdateUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUnit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateUnit* New() const final {
    return new UpdateUnit();
  }

  UpdateUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateUnit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateUnit";
  }
  protected:
  explicit UpdateUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 7,
    kKindIDFieldNumber = 2,
    kPosFieldNumber = 1,
    kFollowingPathFieldNumber = 6,
    kHealthFieldNumber = 4,
    kMovementLeftFieldNumber = 5,
    kOwnerIDFieldNumber = 3,
    kIdFieldNumber = 8,
    kStrengthFieldNumber = 9,
  };
  // repeated .Capability capabilities = 7;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  ::Capability* mutable_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >*
      mutable_capabilities();
  private:
  const ::Capability& _internal_capabilities(int index) const;
  ::Capability* _internal_add_capabilities();
  public:
  const ::Capability& capabilities(int index) const;
  ::Capability* add_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >&
      capabilities() const;

  // string kindID = 2;
  void clear_kindid();
  const std::string& kindid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kindid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kindid();
  PROTOBUF_MUST_USE_RESULT std::string* release_kindid();
  void set_allocated_kindid(std::string* kindid);
  private:
  const std::string& _internal_kindid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kindid(const std::string& value);
  std::string* _internal_mutable_kindid();
  public:

  // .Pos pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Pos& pos() const;
  PROTOBUF_MUST_USE_RESULT ::Pos* release_pos();
  ::Pos* mutable_pos();
  void set_allocated_pos(::Pos* pos);
  private:
  const ::Pos& _internal_pos() const;
  ::Pos* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Pos* pos);
  ::Pos* unsafe_arena_release_pos();

  // .Path followingPath = 6;
  bool has_followingpath() const;
  private:
  bool _internal_has_followingpath() const;
  public:
  void clear_followingpath();
  const ::Path& followingpath() const;
  PROTOBUF_MUST_USE_RESULT ::Path* release_followingpath();
  ::Path* mutable_followingpath();
  void set_allocated_followingpath(::Path* followingpath);
  private:
  const ::Path& _internal_followingpath() const;
  ::Path* _internal_mutable_followingpath();
  public:
  void unsafe_arena_set_allocated_followingpath(
      ::Path* followingpath);
  ::Path* unsafe_arena_release_followingpath();

  // double health = 4;
  void clear_health();
  double health() const;
  void set_health(double value);
  private:
  double _internal_health() const;
  void _internal_set_health(double value);
  public:

  // double movementLeft = 5;
  void clear_movementleft();
  double movementleft() const;
  void set_movementleft(double value);
  private:
  double _internal_movementleft() const;
  void _internal_set_movementleft(double value);
  public:

  // int32 ownerID = 3;
  void clear_ownerid();
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid() const;
  void set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ownerid() const;
  void _internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 id = 8;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double strength = 9;
  void clear_strength();
  double strength() const;
  void set_strength(double value);
  private:
  double _internal_strength() const;
  void _internal_set_strength(double value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability > capabilities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kindid_;
  ::Pos* pos_;
  ::Path* followingpath_;
  double health_;
  double movementleft_;
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  double strength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ResearchingTech final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResearchingTech) */ {
 public:
  inline ResearchingTech() : ResearchingTech(nullptr) {}
  ~ResearchingTech() override;
  explicit constexpr ResearchingTech(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResearchingTech(const ResearchingTech& from);
  ResearchingTech(ResearchingTech&& from) noexcept
    : ResearchingTech() {
    *this = ::std::move(from);
  }

  inline ResearchingTech& operator=(const ResearchingTech& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResearchingTech& operator=(ResearchingTech&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResearchingTech& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResearchingTech* internal_default_instance() {
    return reinterpret_cast<const ResearchingTech*>(
               &_ResearchingTech_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResearchingTech& a, ResearchingTech& b) {
    a.Swap(&b);
  }
  inline void Swap(ResearchingTech* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResearchingTech* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResearchingTech* New() const final {
    return new ResearchingTech();
  }

  ResearchingTech* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResearchingTech>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResearchingTech& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResearchingTech& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResearchingTech* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResearchingTech";
  }
  protected:
  explicit ResearchingTech(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechIDFieldNumber = 1,
    kProgressFieldNumber = 2,
  };
  // string techID = 1;
  void clear_techid();
  const std::string& techid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_techid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_techid();
  PROTOBUF_MUST_USE_RESULT std::string* release_techid();
  void set_allocated_techid(std::string* techid);
  private:
  const std::string& _internal_techid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_techid(const std::string& value);
  std::string* _internal_mutable_techid();
  public:

  // int32 progress = 2;
  void clear_progress();
  ::PROTOBUF_NAMESPACE_ID::int32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_progress() const;
  void _internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ResearchingTech)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr techid_;
  ::PROTOBUF_NAMESPACE_ID::int32 progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdatePlayer) */ {
 public:
  inline UpdatePlayer() : UpdatePlayer(nullptr) {}
  ~UpdatePlayer() override;
  explicit constexpr UpdatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePlayer(const UpdatePlayer& from);
  UpdatePlayer(UpdatePlayer&& from) noexcept
    : UpdatePlayer() {
    *this = ::std::move(from);
  }

  inline UpdatePlayer& operator=(const UpdatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayer& operator=(UpdatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayer* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayer*>(
               &_UpdatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdatePlayer& a, UpdatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayer* New() const final {
    return new UpdatePlayer();
  }

  UpdatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdatePlayer";
  }
  protected:
  explicit UpdatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnlockedTechIDsFieldNumber = 11,
    kPossibleResearchesFieldNumber = 12,
    kUsernameFieldNumber = 2,
    kResearchingTechFieldNumber = 9,
    kIdFieldNumber = 1,
    kBaseRevenueFieldNumber = 3,
    kBeakerRevenueFieldNumber = 4,
    kGoldRevenueFieldNumber = 5,
    kExpensesFieldNumber = 6,
    kNetGoldFieldNumber = 7,
    kGoldFieldNumber = 8,
    kCapitalCityIDFieldNumber = 10,
  };
  // repeated string unlockedTechIDs = 11;
  int unlockedtechids_size() const;
  private:
  int _internal_unlockedtechids_size() const;
  public:
  void clear_unlockedtechids();
  const std::string& unlockedtechids(int index) const;
  std::string* mutable_unlockedtechids(int index);
  void set_unlockedtechids(int index, const std::string& value);
  void set_unlockedtechids(int index, std::string&& value);
  void set_unlockedtechids(int index, const char* value);
  void set_unlockedtechids(int index, const char* value, size_t size);
  std::string* add_unlockedtechids();
  void add_unlockedtechids(const std::string& value);
  void add_unlockedtechids(std::string&& value);
  void add_unlockedtechids(const char* value);
  void add_unlockedtechids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unlockedtechids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unlockedtechids();
  private:
  const std::string& _internal_unlockedtechids(int index) const;
  std::string* _internal_add_unlockedtechids();
  public:

  // repeated string possibleResearches = 12;
  int possibleresearches_size() const;
  private:
  int _internal_possibleresearches_size() const;
  public:
  void clear_possibleresearches();
  const std::string& possibleresearches(int index) const;
  std::string* mutable_possibleresearches(int index);
  void set_possibleresearches(int index, const std::string& value);
  void set_possibleresearches(int index, std::string&& value);
  void set_possibleresearches(int index, const char* value);
  void set_possibleresearches(int index, const char* value, size_t size);
  std::string* add_possibleresearches();
  void add_possibleresearches(const std::string& value);
  void add_possibleresearches(std::string&& value);
  void add_possibleresearches(const char* value);
  void add_possibleresearches(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& possibleresearches() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_possibleresearches();
  private:
  const std::string& _internal_possibleresearches(int index) const;
  std::string* _internal_add_possibleresearches();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .ResearchingTech researchingTech = 9;
  bool has_researchingtech() const;
  private:
  bool _internal_has_researchingtech() const;
  public:
  void clear_researchingtech();
  const ::ResearchingTech& researchingtech() const;
  PROTOBUF_MUST_USE_RESULT ::ResearchingTech* release_researchingtech();
  ::ResearchingTech* mutable_researchingtech();
  void set_allocated_researchingtech(::ResearchingTech* researchingtech);
  private:
  const ::ResearchingTech& _internal_researchingtech() const;
  ::ResearchingTech* _internal_mutable_researchingtech();
  public:
  void unsafe_arena_set_allocated_researchingtech(
      ::ResearchingTech* researchingtech);
  ::ResearchingTech* unsafe_arena_release_researchingtech();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 baseRevenue = 3;
  void clear_baserevenue();
  ::PROTOBUF_NAMESPACE_ID::int32 baserevenue() const;
  void set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_baserevenue() const;
  void _internal_set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 beakerRevenue = 4;
  void clear_beakerrevenue();
  ::PROTOBUF_NAMESPACE_ID::int32 beakerrevenue() const;
  void set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_beakerrevenue() const;
  void _internal_set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 goldRevenue = 5;
  void clear_goldrevenue();
  ::PROTOBUF_NAMESPACE_ID::int32 goldrevenue() const;
  void set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_goldrevenue() const;
  void _internal_set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 expenses = 6;
  void clear_expenses();
  ::PROTOBUF_NAMESPACE_ID::int32 expenses() const;
  void set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_expenses() const;
  void _internal_set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 netGold = 7;
  void clear_netgold();
  ::PROTOBUF_NAMESPACE_ID::int32 netgold() const;
  void set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_netgold() const;
  void _internal_set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 gold = 8;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 capitalCityID = 10;
  void clear_capitalcityid();
  ::PROTOBUF_NAMESPACE_ID::int32 capitalcityid() const;
  void set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_capitalcityid() const;
  void _internal_set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:UpdatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unlockedtechids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> possibleresearches_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::ResearchingTech* researchingtech_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 baserevenue_;
  ::PROTOBUF_NAMESPACE_ID::int32 beakerrevenue_;
  ::PROTOBUF_NAMESPACE_ID::int32 goldrevenue_;
  ::PROTOBUF_NAMESPACE_ID::int32 expenses_;
  ::PROTOBUF_NAMESPACE_ID::int32 netgold_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  ::PROTOBUF_NAMESPACE_ID::int32 capitalcityid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class PathComputed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PathComputed) */ {
 public:
  inline PathComputed() : PathComputed(nullptr) {}
  ~PathComputed() override;
  explicit constexpr PathComputed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathComputed(const PathComputed& from);
  PathComputed(PathComputed&& from) noexcept
    : PathComputed() {
    *this = ::std::move(from);
  }

  inline PathComputed& operator=(const PathComputed& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathComputed& operator=(PathComputed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathComputed& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathComputed* internal_default_instance() {
    return reinterpret_cast<const PathComputed*>(
               &_PathComputed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(PathComputed& a, PathComputed& b) {
    a.Swap(&b);
  }
  inline void Swap(PathComputed* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathComputed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PathComputed* New() const final {
    return new PathComputed();
  }

  PathComputed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PathComputed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathComputed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PathComputed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathComputed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PathComputed";
  }
  protected:
  explicit PathComputed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kPathIDFieldNumber = 1,
  };
  // .Path path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::Path& path() const;
  PROTOBUF_MUST_USE_RESULT ::Path* release_path();
  ::Path* mutable_path();
  void set_allocated_path(::Path* path);
  private:
  const ::Path& _internal_path() const;
  ::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::Path* path);
  ::Path* unsafe_arena_release_path();

  // int32 pathID = 1;
  void clear_pathid();
  ::PROTOBUF_NAMESPACE_ID::int32 pathid() const;
  void set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pathid() const;
  void _internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PathComputed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Path* path_;
  ::PROTOBUF_NAMESPACE_ID::int32 pathid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class MoveUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MoveUnit) */ {
 public:
  inline MoveUnit() : MoveUnit(nullptr) {}
  ~MoveUnit() override;
  explicit constexpr MoveUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveUnit(const MoveUnit& from);
  MoveUnit(MoveUnit&& from) noexcept
    : MoveUnit() {
    *this = ::std::move(from);
  }

  inline MoveUnit& operator=(const MoveUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveUnit& operator=(MoveUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveUnit* internal_default_instance() {
    return reinterpret_cast<const MoveUnit*>(
               &_MoveUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MoveUnit& a, MoveUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveUnit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveUnit* New() const final {
    return new MoveUnit();
  }

  MoveUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveUnit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MoveUnit";
  }
  protected:
  explicit MoveUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPosFieldNumber = 2,
    kUnitIDFieldNumber = 1,
  };
  // .Pos newPos = 2;
  bool has_newpos() const;
  private:
  bool _internal_has_newpos() const;
  public:
  void clear_newpos();
  const ::Pos& newpos() const;
  PROTOBUF_MUST_USE_RESULT ::Pos* release_newpos();
  ::Pos* mutable_newpos();
  void set_allocated_newpos(::Pos* newpos);
  private:
  const ::Pos& _internal_newpos() const;
  ::Pos* _internal_mutable_newpos();
  public:
  void unsafe_arena_set_allocated_newpos(
      ::Pos* newpos);
  ::Pos* unsafe_arena_release_newpos();

  // int32 unitID = 1;
  void clear_unitid();
  ::PROTOBUF_NAMESPACE_ID::int32 unitid() const;
  void set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_unitid() const;
  void _internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:MoveUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Pos* newpos_;
  ::PROTOBUF_NAMESPACE_ID::int32 unitid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetCityBuildTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetCityBuildTask) */ {
 public:
  inline SetCityBuildTask() : SetCityBuildTask(nullptr) {}
  ~SetCityBuildTask() override;
  explicit constexpr SetCityBuildTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCityBuildTask(const SetCityBuildTask& from);
  SetCityBuildTask(SetCityBuildTask&& from) noexcept
    : SetCityBuildTask() {
    *this = ::std::move(from);
  }

  inline SetCityBuildTask& operator=(const SetCityBuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCityBuildTask& operator=(SetCityBuildTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCityBuildTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCityBuildTask* internal_default_instance() {
    return reinterpret_cast<const SetCityBuildTask*>(
               &_SetCityBuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SetCityBuildTask& a, SetCityBuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCityBuildTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCityBuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetCityBuildTask* New() const final {
    return new SetCityBuildTask();
  }

  SetCityBuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetCityBuildTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCityBuildTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetCityBuildTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCityBuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetCityBuildTask";
  }
  protected:
  explicit SetCityBuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 2,
    kCityIDFieldNumber = 1,
  };
  // .BuildTaskKind task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::BuildTaskKind& task() const;
  PROTOBUF_MUST_USE_RESULT ::BuildTaskKind* release_task();
  ::BuildTaskKind* mutable_task();
  void set_allocated_task(::BuildTaskKind* task);
  private:
  const ::BuildTaskKind& _internal_task() const;
  ::BuildTaskKind* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::BuildTaskKind* task);
  ::BuildTaskKind* unsafe_arena_release_task();

  // int32 cityID = 1;
  void clear_cityid();
  ::PROTOBUF_NAMESPACE_ID::int32 cityid() const;
  void set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cityid() const;
  void _internal_set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SetCityBuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::BuildTaskKind* task_;
  ::PROTOBUF_NAMESPACE_ID::int32 cityid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetWorkerTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetWorkerTask) */ {
 public:
  inline SetWorkerTask() : SetWorkerTask(nullptr) {}
  ~SetWorkerTask() override;
  explicit constexpr SetWorkerTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetWorkerTask(const SetWorkerTask& from);
  SetWorkerTask(SetWorkerTask&& from) noexcept
    : SetWorkerTask() {
    *this = ::std::move(from);
  }

  inline SetWorkerTask& operator=(const SetWorkerTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetWorkerTask& operator=(SetWorkerTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetWorkerTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetWorkerTask* internal_default_instance() {
    return reinterpret_cast<const SetWorkerTask*>(
               &_SetWorkerTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SetWorkerTask& a, SetWorkerTask& b) {
    a.Swap(&b);
  }
  inline void Swap(SetWorkerTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetWorkerTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetWorkerTask* New() const final {
    return new SetWorkerTask();
  }

  SetWorkerTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetWorkerTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetWorkerTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetWorkerTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetWorkerTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetWorkerTask";
  }
  protected:
  explicit SetWorkerTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 2,
    kWorkerIDFieldNumber = 1,
  };
  // .WorkerTask task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::WorkerTask& task() const;
  PROTOBUF_MUST_USE_RESULT ::WorkerTask* release_task();
  ::WorkerTask* mutable_task();
  void set_allocated_task(::WorkerTask* task);
  private:
  const ::WorkerTask& _internal_task() const;
  ::WorkerTask* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::WorkerTask* task);
  ::WorkerTask* unsafe_arena_release_task();

  // int32 workerID = 1;
  void clear_workerid();
  ::PROTOBUF_NAMESPACE_ID::int32 workerid() const;
  void set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_workerid() const;
  void _internal_set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SetWorkerTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::WorkerTask* task_;
  ::PROTOBUF_NAMESPACE_ID::int32 workerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ComputePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ComputePath) */ {
 public:
  inline ComputePath() : ComputePath(nullptr) {}
  ~ComputePath() override;
  explicit constexpr ComputePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputePath(const ComputePath& from);
  ComputePath(ComputePath&& from) noexcept
    : ComputePath() {
    *this = ::std::move(from);
  }

  inline ComputePath& operator=(const ComputePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputePath& operator=(ComputePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputePath& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputePath* internal_default_instance() {
    return reinterpret_cast<const ComputePath*>(
               &_ComputePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ComputePath& a, ComputePath& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputePath* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComputePath* New() const final {
    return new ComputePath();
  }

  ComputePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComputePath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputePath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComputePath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputePath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ComputePath";
  }
  protected:
  explicit ComputePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kUnitIDFieldNumber = 1,
    kPathIDFieldNumber = 4,
  };
  // .Pos from = 2;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::Pos& from() const;
  PROTOBUF_MUST_USE_RESULT ::Pos* release_from();
  ::Pos* mutable_from();
  void set_allocated_from(::Pos* from);
  private:
  const ::Pos& _internal_from() const;
  ::Pos* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::Pos* from);
  ::Pos* unsafe_arena_release_from();

  // .Pos to = 3;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::Pos& to() const;
  PROTOBUF_MUST_USE_RESULT ::Pos* release_to();
  ::Pos* mutable_to();
  void set_allocated_to(::Pos* to);
  private:
  const ::Pos& _internal_to() const;
  ::Pos* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::Pos* to);
  ::Pos* unsafe_arena_release_to();

  // int32 unitID = 1;
  void clear_unitid();
  ::PROTOBUF_NAMESPACE_ID::int32 unitid() const;
  void set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_unitid() const;
  void _internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 pathID = 4;
  void clear_pathid();
  ::PROTOBUF_NAMESPACE_ID::int32 pathid() const;
  void set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pathid() const;
  void _internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ComputePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Pos* from_;
  ::Pos* to_;
  ::PROTOBUF_NAMESPACE_ID::int32 unitid_;
  ::PROTOBUF_NAMESPACE_ID::int32 pathid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetEconomySettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetEconomySettings) */ {
 public:
  inline SetEconomySettings() : SetEconomySettings(nullptr) {}
  ~SetEconomySettings() override;
  explicit constexpr SetEconomySettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEconomySettings(const SetEconomySettings& from);
  SetEconomySettings(SetEconomySettings&& from) noexcept
    : SetEconomySettings() {
    *this = ::std::move(from);
  }

  inline SetEconomySettings& operator=(const SetEconomySettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEconomySettings& operator=(SetEconomySettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEconomySettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEconomySettings* internal_default_instance() {
    return reinterpret_cast<const SetEconomySettings*>(
               &_SetEconomySettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SetEconomySettings& a, SetEconomySettings& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEconomySettings* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEconomySettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetEconomySettings* New() const final {
    return new SetEconomySettings();
  }

  SetEconomySettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetEconomySettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEconomySettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetEconomySettings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEconomySettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetEconomySettings";
  }
  protected:
  explicit SetEconomySettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeakerPercentFieldNumber = 1,
  };
  // int32 beakerPercent = 1;
  void clear_beakerpercent();
  ::PROTOBUF_NAMESPACE_ID::int32 beakerpercent() const;
  void set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_beakerpercent() const;
  void _internal_set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SetEconomySettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 beakerpercent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetResearch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetResearch) */ {
 public:
  inline SetResearch() : SetResearch(nullptr) {}
  ~SetResearch() override;
  explicit constexpr SetResearch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetResearch(const SetResearch& from);
  SetResearch(SetResearch&& from) noexcept
    : SetResearch() {
    *this = ::std::move(from);
  }

  inline SetResearch& operator=(const SetResearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResearch& operator=(SetResearch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetResearch& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetResearch* internal_default_instance() {
    return reinterpret_cast<const SetResearch*>(
               &_SetResearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SetResearch& a, SetResearch& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResearch* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetResearch* New() const final {
    return new SetResearch();
  }

  SetResearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetResearch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetResearch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetResearch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResearch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetResearch";
  }
  protected:
  explicit SetResearch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechIDFieldNumber = 1,
  };
  // string techID = 1;
  void clear_techid();
  const std::string& techid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_techid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_techid();
  PROTOBUF_MUST_USE_RESULT std::string* release_techid();
  void set_allocated_techid(std::string* techid);
  private:
  const std::string& _internal_techid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_techid(const std::string& value);
  std::string* _internal_mutable_techid();
  public:

  // @@protoc_insertion_point(class_scope:SetResearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr techid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Pos

// uint32 x = 1;
inline void Pos::clear_x() {
  x_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::x() const {
  // @@protoc_insertion_point(field_get:Pos.x)
  return _internal_x();
}
inline void Pos::_internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  x_ = value;
}
inline void Pos::set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Pos.x)
}

// uint32 y = 2;
inline void Pos::clear_y() {
  y_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::y() const {
  // @@protoc_insertion_point(field_get:Pos.y)
  return _internal_y();
}
inline void Pos::_internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  y_ = value;
}
inline void Pos::set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Pos.y)
}

// -------------------------------------------------------------------

// AnyClient

// .ClientInfo clientInfo = 1;
inline bool AnyClient::_internal_has_clientinfo() const {
  return packet_case() == kClientInfo;
}
inline bool AnyClient::has_clientinfo() const {
  return _internal_has_clientinfo();
}
inline void AnyClient::set_has_clientinfo() {
  _oneof_case_[0] = kClientInfo;
}
inline void AnyClient::clear_clientinfo() {
  if (_internal_has_clientinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.clientinfo_;
    }
    clear_has_packet();
  }
}
inline ::ClientInfo* AnyClient::release_clientinfo() {
  // @@protoc_insertion_point(field_release:AnyClient.clientInfo)
  if (_internal_has_clientinfo()) {
    clear_has_packet();
      ::ClientInfo* temp = packet_.clientinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.clientinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientInfo& AnyClient::_internal_clientinfo() const {
  return _internal_has_clientinfo()
      ? *packet_.clientinfo_
      : reinterpret_cast< ::ClientInfo&>(::_ClientInfo_default_instance_);
}
inline const ::ClientInfo& AnyClient::clientinfo() const {
  // @@protoc_insertion_point(field_get:AnyClient.clientInfo)
  return _internal_clientinfo();
}
inline ::ClientInfo* AnyClient::unsafe_arena_release_clientinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyClient.clientInfo)
  if (_internal_has_clientinfo()) {
    clear_has_packet();
    ::ClientInfo* temp = packet_.clientinfo_;
    packet_.clientinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyClient::unsafe_arena_set_allocated_clientinfo(::ClientInfo* clientinfo) {
  clear_packet();
  if (clientinfo) {
    set_has_clientinfo();
    packet_.clientinfo_ = clientinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyClient.clientInfo)
}
inline ::ClientInfo* AnyClient::_internal_mutable_clientinfo() {
  if (!_internal_has_clientinfo()) {
    clear_packet();
    set_has_clientinfo();
    packet_.clientinfo_ = CreateMaybeMessage< ::ClientInfo >(GetArenaForAllocation());
  }
  return packet_.clientinfo_;
}
inline ::ClientInfo* AnyClient::mutable_clientinfo() {
  ::ClientInfo* _msg = _internal_mutable_clientinfo();
  // @@protoc_insertion_point(field_mutable:AnyClient.clientInfo)
  return _msg;
}

inline bool AnyClient::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void AnyClient::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline AnyClient::PacketCase AnyClient::packet_case() const {
  return AnyClient::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnyServer

// .ServerInfo serverInfo = 1;
inline bool AnyServer::_internal_has_serverinfo() const {
  return packet_case() == kServerInfo;
}
inline bool AnyServer::has_serverinfo() const {
  return _internal_has_serverinfo();
}
inline void AnyServer::set_has_serverinfo() {
  _oneof_case_[0] = kServerInfo;
}
inline void AnyServer::clear_serverinfo() {
  if (_internal_has_serverinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.serverinfo_;
    }
    clear_has_packet();
  }
}
inline ::ServerInfo* AnyServer::release_serverinfo() {
  // @@protoc_insertion_point(field_release:AnyServer.serverInfo)
  if (_internal_has_serverinfo()) {
    clear_has_packet();
      ::ServerInfo* temp = packet_.serverinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.serverinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerInfo& AnyServer::_internal_serverinfo() const {
  return _internal_has_serverinfo()
      ? *packet_.serverinfo_
      : reinterpret_cast< ::ServerInfo&>(::_ServerInfo_default_instance_);
}
inline const ::ServerInfo& AnyServer::serverinfo() const {
  // @@protoc_insertion_point(field_get:AnyServer.serverInfo)
  return _internal_serverinfo();
}
inline ::ServerInfo* AnyServer::unsafe_arena_release_serverinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.serverInfo)
  if (_internal_has_serverinfo()) {
    clear_has_packet();
    ::ServerInfo* temp = packet_.serverinfo_;
    packet_.serverinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_serverinfo(::ServerInfo* serverinfo) {
  clear_packet();
  if (serverinfo) {
    set_has_serverinfo();
    packet_.serverinfo_ = serverinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.serverInfo)
}
inline ::ServerInfo* AnyServer::_internal_mutable_serverinfo() {
  if (!_internal_has_serverinfo()) {
    clear_packet();
    set_has_serverinfo();
    packet_.serverinfo_ = CreateMaybeMessage< ::ServerInfo >(GetArenaForAllocation());
  }
  return packet_.serverinfo_;
}
inline ::ServerInfo* AnyServer::mutable_serverinfo() {
  ::ServerInfo* _msg = _internal_mutable_serverinfo();
  // @@protoc_insertion_point(field_mutable:AnyServer.serverInfo)
  return _msg;
}

// .StartGame startGame = 2;
inline bool AnyServer::_internal_has_startgame() const {
  return packet_case() == kStartGame;
}
inline bool AnyServer::has_startgame() const {
  return _internal_has_startgame();
}
inline void AnyServer::set_has_startgame() {
  _oneof_case_[0] = kStartGame;
}
inline void AnyServer::clear_startgame() {
  if (_internal_has_startgame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.startgame_;
    }
    clear_has_packet();
  }
}
inline ::StartGame* AnyServer::release_startgame() {
  // @@protoc_insertion_point(field_release:AnyServer.startGame)
  if (_internal_has_startgame()) {
    clear_has_packet();
      ::StartGame* temp = packet_.startgame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.startgame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StartGame& AnyServer::_internal_startgame() const {
  return _internal_has_startgame()
      ? *packet_.startgame_
      : reinterpret_cast< ::StartGame&>(::_StartGame_default_instance_);
}
inline const ::StartGame& AnyServer::startgame() const {
  // @@protoc_insertion_point(field_get:AnyServer.startGame)
  return _internal_startgame();
}
inline ::StartGame* AnyServer::unsafe_arena_release_startgame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.startGame)
  if (_internal_has_startgame()) {
    clear_has_packet();
    ::StartGame* temp = packet_.startgame_;
    packet_.startgame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_startgame(::StartGame* startgame) {
  clear_packet();
  if (startgame) {
    set_has_startgame();
    packet_.startgame_ = startgame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.startGame)
}
inline ::StartGame* AnyServer::_internal_mutable_startgame() {
  if (!_internal_has_startgame()) {
    clear_packet();
    set_has_startgame();
    packet_.startgame_ = CreateMaybeMessage< ::StartGame >(GetArenaForAllocation());
  }
  return packet_.startgame_;
}
inline ::StartGame* AnyServer::mutable_startgame() {
  ::StartGame* _msg = _internal_mutable_startgame();
  // @@protoc_insertion_point(field_mutable:AnyServer.startGame)
  return _msg;
}

// .LobbyError lobbyError = 3;
inline bool AnyServer::_internal_has_lobbyerror() const {
  return packet_case() == kLobbyError;
}
inline bool AnyServer::has_lobbyerror() const {
  return _internal_has_lobbyerror();
}
inline void AnyServer::set_has_lobbyerror() {
  _oneof_case_[0] = kLobbyError;
}
inline void AnyServer::clear_lobbyerror() {
  if (_internal_has_lobbyerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.lobbyerror_;
    }
    clear_has_packet();
  }
}
inline ::LobbyError* AnyServer::release_lobbyerror() {
  // @@protoc_insertion_point(field_release:AnyServer.lobbyError)
  if (_internal_has_lobbyerror()) {
    clear_has_packet();
      ::LobbyError* temp = packet_.lobbyerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.lobbyerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LobbyError& AnyServer::_internal_lobbyerror() const {
  return _internal_has_lobbyerror()
      ? *packet_.lobbyerror_
      : reinterpret_cast< ::LobbyError&>(::_LobbyError_default_instance_);
}
inline const ::LobbyError& AnyServer::lobbyerror() const {
  // @@protoc_insertion_point(field_get:AnyServer.lobbyError)
  return _internal_lobbyerror();
}
inline ::LobbyError* AnyServer::unsafe_arena_release_lobbyerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.lobbyError)
  if (_internal_has_lobbyerror()) {
    clear_has_packet();
    ::LobbyError* temp = packet_.lobbyerror_;
    packet_.lobbyerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_lobbyerror(::LobbyError* lobbyerror) {
  clear_packet();
  if (lobbyerror) {
    set_has_lobbyerror();
    packet_.lobbyerror_ = lobbyerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.lobbyError)
}
inline ::LobbyError* AnyServer::_internal_mutable_lobbyerror() {
  if (!_internal_has_lobbyerror()) {
    clear_packet();
    set_has_lobbyerror();
    packet_.lobbyerror_ = CreateMaybeMessage< ::LobbyError >(GetArenaForAllocation());
  }
  return packet_.lobbyerror_;
}
inline ::LobbyError* AnyServer::mutable_lobbyerror() {
  ::LobbyError* _msg = _internal_mutable_lobbyerror();
  // @@protoc_insertion_point(field_mutable:AnyServer.lobbyError)
  return _msg;
}

// .UpdateGlobalData updateGlobalData = 4;
inline bool AnyServer::_internal_has_updateglobaldata() const {
  return packet_case() == kUpdateGlobalData;
}
inline bool AnyServer::has_updateglobaldata() const {
  return _internal_has_updateglobaldata();
}
inline void AnyServer::set_has_updateglobaldata() {
  _oneof_case_[0] = kUpdateGlobalData;
}
inline void AnyServer::clear_updateglobaldata() {
  if (_internal_has_updateglobaldata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.updateglobaldata_;
    }
    clear_has_packet();
  }
}
inline ::UpdateGlobalData* AnyServer::release_updateglobaldata() {
  // @@protoc_insertion_point(field_release:AnyServer.updateGlobalData)
  if (_internal_has_updateglobaldata()) {
    clear_has_packet();
      ::UpdateGlobalData* temp = packet_.updateglobaldata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updateglobaldata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateGlobalData& AnyServer::_internal_updateglobaldata() const {
  return _internal_has_updateglobaldata()
      ? *packet_.updateglobaldata_
      : reinterpret_cast< ::UpdateGlobalData&>(::_UpdateGlobalData_default_instance_);
}
inline const ::UpdateGlobalData& AnyServer::updateglobaldata() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateGlobalData)
  return _internal_updateglobaldata();
}
inline ::UpdateGlobalData* AnyServer::unsafe_arena_release_updateglobaldata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateGlobalData)
  if (_internal_has_updateglobaldata()) {
    clear_has_packet();
    ::UpdateGlobalData* temp = packet_.updateglobaldata_;
    packet_.updateglobaldata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updateglobaldata(::UpdateGlobalData* updateglobaldata) {
  clear_packet();
  if (updateglobaldata) {
    set_has_updateglobaldata();
    packet_.updateglobaldata_ = updateglobaldata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateGlobalData)
}
inline ::UpdateGlobalData* AnyServer::_internal_mutable_updateglobaldata() {
  if (!_internal_has_updateglobaldata()) {
    clear_packet();
    set_has_updateglobaldata();
    packet_.updateglobaldata_ = CreateMaybeMessage< ::UpdateGlobalData >(GetArenaForAllocation());
  }
  return packet_.updateglobaldata_;
}
inline ::UpdateGlobalData* AnyServer::mutable_updateglobaldata() {
  ::UpdateGlobalData* _msg = _internal_mutable_updateglobaldata();
  // @@protoc_insertion_point(field_mutable:AnyServer.updateGlobalData)
  return _msg;
}

// .UpdateMap updateMap = 5;
inline bool AnyServer::_internal_has_updatemap() const {
  return packet_case() == kUpdateMap;
}
inline bool AnyServer::has_updatemap() const {
  return _internal_has_updatemap();
}
inline void AnyServer::set_has_updatemap() {
  _oneof_case_[0] = kUpdateMap;
}
inline void AnyServer::clear_updatemap() {
  if (_internal_has_updatemap()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.updatemap_;
    }
    clear_has_packet();
  }
}
inline ::UpdateMap* AnyServer::release_updatemap() {
  // @@protoc_insertion_point(field_release:AnyServer.updateMap)
  if (_internal_has_updatemap()) {
    clear_has_packet();
      ::UpdateMap* temp = packet_.updatemap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updatemap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateMap& AnyServer::_internal_updatemap() const {
  return _internal_has_updatemap()
      ? *packet_.updatemap_
      : reinterpret_cast< ::UpdateMap&>(::_UpdateMap_default_instance_);
}
inline const ::UpdateMap& AnyServer::updatemap() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateMap)
  return _internal_updatemap();
}
inline ::UpdateMap* AnyServer::unsafe_arena_release_updatemap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateMap)
  if (_internal_has_updatemap()) {
    clear_has_packet();
    ::UpdateMap* temp = packet_.updatemap_;
    packet_.updatemap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updatemap(::UpdateMap* updatemap) {
  clear_packet();
  if (updatemap) {
    set_has_updatemap();
    packet_.updatemap_ = updatemap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateMap)
}
inline ::UpdateMap* AnyServer::_internal_mutable_updatemap() {
  if (!_internal_has_updatemap()) {
    clear_packet();
    set_has_updatemap();
    packet_.updatemap_ = CreateMaybeMessage< ::UpdateMap >(GetArenaForAllocation());
  }
  return packet_.updatemap_;
}
inline ::UpdateMap* AnyServer::mutable_updatemap() {
  ::UpdateMap* _msg = _internal_mutable_updatemap();
  // @@protoc_insertion_point(field_mutable:AnyServer.updateMap)
  return _msg;
}

// .UpdateCity updateCity = 6;
inline bool AnyServer::_internal_has_updatecity() const {
  return packet_case() == kUpdateCity;
}
inline bool AnyServer::has_updatecity() const {
  return _internal_has_updatecity();
}
inline void AnyServer::set_has_updatecity() {
  _oneof_case_[0] = kUpdateCity;
}
inline void AnyServer::clear_updatecity() {
  if (_internal_has_updatecity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.updatecity_;
    }
    clear_has_packet();
  }
}
inline ::UpdateCity* AnyServer::release_updatecity() {
  // @@protoc_insertion_point(field_release:AnyServer.updateCity)
  if (_internal_has_updatecity()) {
    clear_has_packet();
      ::UpdateCity* temp = packet_.updatecity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updatecity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateCity& AnyServer::_internal_updatecity() const {
  return _internal_has_updatecity()
      ? *packet_.updatecity_
      : reinterpret_cast< ::UpdateCity&>(::_UpdateCity_default_instance_);
}
inline const ::UpdateCity& AnyServer::updatecity() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateCity)
  return _internal_updatecity();
}
inline ::UpdateCity* AnyServer::unsafe_arena_release_updatecity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateCity)
  if (_internal_has_updatecity()) {
    clear_has_packet();
    ::UpdateCity* temp = packet_.updatecity_;
    packet_.updatecity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updatecity(::UpdateCity* updatecity) {
  clear_packet();
  if (updatecity) {
    set_has_updatecity();
    packet_.updatecity_ = updatecity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateCity)
}
inline ::UpdateCity* AnyServer::_internal_mutable_updatecity() {
  if (!_internal_has_updatecity()) {
    clear_packet();
    set_has_updatecity();
    packet_.updatecity_ = CreateMaybeMessage< ::UpdateCity >(GetArenaForAllocation());
  }
  return packet_.updatecity_;
}
inline ::UpdateCity* AnyServer::mutable_updatecity() {
  ::UpdateCity* _msg = _internal_mutable_updatecity();
  // @@protoc_insertion_point(field_mutable:AnyServer.updateCity)
  return _msg;
}

// .UpdateUnit updateUnit = 7;
inline bool AnyServer::_internal_has_updateunit() const {
  return packet_case() == kUpdateUnit;
}
inline bool AnyServer::has_updateunit() const {
  return _internal_has_updateunit();
}
inline void AnyServer::set_has_updateunit() {
  _oneof_case_[0] = kUpdateUnit;
}
inline void AnyServer::clear_updateunit() {
  if (_internal_has_updateunit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.updateunit_;
    }
    clear_has_packet();
  }
}
inline ::UpdateUnit* AnyServer::release_updateunit() {
  // @@protoc_insertion_point(field_release:AnyServer.updateUnit)
  if (_internal_has_updateunit()) {
    clear_has_packet();
      ::UpdateUnit* temp = packet_.updateunit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updateunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateUnit& AnyServer::_internal_updateunit() const {
  return _internal_has_updateunit()
      ? *packet_.updateunit_
      : reinterpret_cast< ::UpdateUnit&>(::_UpdateUnit_default_instance_);
}
inline const ::UpdateUnit& AnyServer::updateunit() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateUnit)
  return _internal_updateunit();
}
inline ::UpdateUnit* AnyServer::unsafe_arena_release_updateunit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateUnit)
  if (_internal_has_updateunit()) {
    clear_has_packet();
    ::UpdateUnit* temp = packet_.updateunit_;
    packet_.updateunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updateunit(::UpdateUnit* updateunit) {
  clear_packet();
  if (updateunit) {
    set_has_updateunit();
    packet_.updateunit_ = updateunit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateUnit)
}
inline ::UpdateUnit* AnyServer::_internal_mutable_updateunit() {
  if (!_internal_has_updateunit()) {
    clear_packet();
    set_has_updateunit();
    packet_.updateunit_ = CreateMaybeMessage< ::UpdateUnit >(GetArenaForAllocation());
  }
  return packet_.updateunit_;
}
inline ::UpdateUnit* AnyServer::mutable_updateunit() {
  ::UpdateUnit* _msg = _internal_mutable_updateunit();
  // @@protoc_insertion_point(field_mutable:AnyServer.updateUnit)
  return _msg;
}

// .UpdatePlayer updatePlayer = 8;
inline bool AnyServer::_internal_has_updateplayer() const {
  return packet_case() == kUpdatePlayer;
}
inline bool AnyServer::has_updateplayer() const {
  return _internal_has_updateplayer();
}
inline void AnyServer::set_has_updateplayer() {
  _oneof_case_[0] = kUpdatePlayer;
}
inline void AnyServer::clear_updateplayer() {
  if (_internal_has_updateplayer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.updateplayer_;
    }
    clear_has_packet();
  }
}
inline ::UpdatePlayer* AnyServer::release_updateplayer() {
  // @@protoc_insertion_point(field_release:AnyServer.updatePlayer)
  if (_internal_has_updateplayer()) {
    clear_has_packet();
      ::UpdatePlayer* temp = packet_.updateplayer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updateplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdatePlayer& AnyServer::_internal_updateplayer() const {
  return _internal_has_updateplayer()
      ? *packet_.updateplayer_
      : reinterpret_cast< ::UpdatePlayer&>(::_UpdatePlayer_default_instance_);
}
inline const ::UpdatePlayer& AnyServer::updateplayer() const {
  // @@protoc_insertion_point(field_get:AnyServer.updatePlayer)
  return _internal_updateplayer();
}
inline ::UpdatePlayer* AnyServer::unsafe_arena_release_updateplayer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updatePlayer)
  if (_internal_has_updateplayer()) {
    clear_has_packet();
    ::UpdatePlayer* temp = packet_.updateplayer_;
    packet_.updateplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updateplayer(::UpdatePlayer* updateplayer) {
  clear_packet();
  if (updateplayer) {
    set_has_updateplayer();
    packet_.updateplayer_ = updateplayer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updatePlayer)
}
inline ::UpdatePlayer* AnyServer::_internal_mutable_updateplayer() {
  if (!_internal_has_updateplayer()) {
    clear_packet();
    set_has_updateplayer();
    packet_.updateplayer_ = CreateMaybeMessage< ::UpdatePlayer >(GetArenaForAllocation());
  }
  return packet_.updateplayer_;
}
inline ::UpdatePlayer* AnyServer::mutable_updateplayer() {
  ::UpdatePlayer* _msg = _internal_mutable_updateplayer();
  // @@protoc_insertion_point(field_mutable:AnyServer.updatePlayer)
  return _msg;
}

// .PathComputed pathComputed = 9;
inline bool AnyServer::_internal_has_pathcomputed() const {
  return packet_case() == kPathComputed;
}
inline bool AnyServer::has_pathcomputed() const {
  return _internal_has_pathcomputed();
}
inline void AnyServer::set_has_pathcomputed() {
  _oneof_case_[0] = kPathComputed;
}
inline void AnyServer::clear_pathcomputed() {
  if (_internal_has_pathcomputed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete packet_.pathcomputed_;
    }
    clear_has_packet();
  }
}
inline ::PathComputed* AnyServer::release_pathcomputed() {
  // @@protoc_insertion_point(field_release:AnyServer.pathComputed)
  if (_internal_has_pathcomputed()) {
    clear_has_packet();
      ::PathComputed* temp = packet_.pathcomputed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.pathcomputed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PathComputed& AnyServer::_internal_pathcomputed() const {
  return _internal_has_pathcomputed()
      ? *packet_.pathcomputed_
      : reinterpret_cast< ::PathComputed&>(::_PathComputed_default_instance_);
}
inline const ::PathComputed& AnyServer::pathcomputed() const {
  // @@protoc_insertion_point(field_get:AnyServer.pathComputed)
  return _internal_pathcomputed();
}
inline ::PathComputed* AnyServer::unsafe_arena_release_pathcomputed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.pathComputed)
  if (_internal_has_pathcomputed()) {
    clear_has_packet();
    ::PathComputed* temp = packet_.pathcomputed_;
    packet_.pathcomputed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_pathcomputed(::PathComputed* pathcomputed) {
  clear_packet();
  if (pathcomputed) {
    set_has_pathcomputed();
    packet_.pathcomputed_ = pathcomputed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.pathComputed)
}
inline ::PathComputed* AnyServer::_internal_mutable_pathcomputed() {
  if (!_internal_has_pathcomputed()) {
    clear_packet();
    set_has_pathcomputed();
    packet_.pathcomputed_ = CreateMaybeMessage< ::PathComputed >(GetArenaForAllocation());
  }
  return packet_.pathcomputed_;
}
inline ::PathComputed* AnyServer::mutable_pathcomputed() {
  ::PathComputed* _msg = _internal_mutable_pathcomputed();
  // @@protoc_insertion_point(field_mutable:AnyServer.pathComputed)
  return _msg;
}

inline bool AnyServer::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void AnyServer::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline AnyServer::PacketCase AnyServer::packet_case() const {
  return AnyServer::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientInfo

// string username = 1;
inline void ClientInfo::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ClientInfo::username() const {
  // @@protoc_insertion_point(field_get:ClientInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientInfo.username)
}
inline std::string* ClientInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:ClientInfo.username)
  return _s;
}
inline const std::string& ClientInfo::_internal_username() const {
  return username_.Get();
}
inline void ClientInfo::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_username() {
  // @@protoc_insertion_point(field_release:ClientInfo.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ClientInfo.username)
}

// -------------------------------------------------------------------

// ServerInfo

// int32 playerID = 1;
inline void ServerInfo::clear_playerid() {
  playerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfo::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfo::playerid() const {
  // @@protoc_insertion_point(field_get:ServerInfo.playerID)
  return _internal_playerid();
}
inline void ServerInfo::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playerid_ = value;
}
inline void ServerInfo::set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:ServerInfo.playerID)
}

// repeated .PlayerInfo currentPlayers = 2;
inline int ServerInfo::_internal_currentplayers_size() const {
  return currentplayers_.size();
}
inline int ServerInfo::currentplayers_size() const {
  return _internal_currentplayers_size();
}
inline void ServerInfo::clear_currentplayers() {
  currentplayers_.Clear();
}
inline ::PlayerInfo* ServerInfo::mutable_currentplayers(int index) {
  // @@protoc_insertion_point(field_mutable:ServerInfo.currentPlayers)
  return currentplayers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
ServerInfo::mutable_currentplayers() {
  // @@protoc_insertion_point(field_mutable_list:ServerInfo.currentPlayers)
  return &currentplayers_;
}
inline const ::PlayerInfo& ServerInfo::_internal_currentplayers(int index) const {
  return currentplayers_.Get(index);
}
inline const ::PlayerInfo& ServerInfo::currentplayers(int index) const {
  // @@protoc_insertion_point(field_get:ServerInfo.currentPlayers)
  return _internal_currentplayers(index);
}
inline ::PlayerInfo* ServerInfo::_internal_add_currentplayers() {
  return currentplayers_.Add();
}
inline ::PlayerInfo* ServerInfo::add_currentplayers() {
  ::PlayerInfo* _add = _internal_add_currentplayers();
  // @@protoc_insertion_point(field_add:ServerInfo.currentPlayers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
ServerInfo::currentplayers() const {
  // @@protoc_insertion_point(field_list:ServerInfo.currentPlayers)
  return currentplayers_;
}

// -------------------------------------------------------------------

// KickPlayer

// int32 id = 1;
inline void KickPlayer::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KickPlayer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KickPlayer::id() const {
  // @@protoc_insertion_point(field_get:KickPlayer.id)
  return _internal_id();
}
inline void KickPlayer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void KickPlayer::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:KickPlayer.id)
}

// string reason = 2;
inline void KickPlayer::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& KickPlayer::reason() const {
  // @@protoc_insertion_point(field_get:KickPlayer.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPlayer::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KickPlayer.reason)
}
inline std::string* KickPlayer::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:KickPlayer.reason)
  return _s;
}
inline const std::string& KickPlayer::_internal_reason() const {
  return reason_.Get();
}
inline void KickPlayer::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KickPlayer::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KickPlayer::release_reason() {
  // @@protoc_insertion_point(field_release:KickPlayer.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KickPlayer::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:KickPlayer.reason)
}

// -------------------------------------------------------------------

// SetLeader

// string civID = 1;
inline void SetLeader::clear_civid() {
  civid_.ClearToEmpty();
}
inline const std::string& SetLeader::civid() const {
  // @@protoc_insertion_point(field_get:SetLeader.civID)
  return _internal_civid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLeader::set_civid(ArgT0&& arg0, ArgT... args) {
 
 civid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetLeader.civID)
}
inline std::string* SetLeader::mutable_civid() {
  std::string* _s = _internal_mutable_civid();
  // @@protoc_insertion_point(field_mutable:SetLeader.civID)
  return _s;
}
inline const std::string& SetLeader::_internal_civid() const {
  return civid_.Get();
}
inline void SetLeader::_internal_set_civid(const std::string& value) {
  
  civid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetLeader::_internal_mutable_civid() {
  
  return civid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetLeader::release_civid() {
  // @@protoc_insertion_point(field_release:SetLeader.civID)
  return civid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetLeader::set_allocated_civid(std::string* civid) {
  if (civid != nullptr) {
    
  } else {
    
  }
  civid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), civid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SetLeader.civID)
}

// string leader = 2;
inline void SetLeader::clear_leader() {
  leader_.ClearToEmpty();
}
inline const std::string& SetLeader::leader() const {
  // @@protoc_insertion_point(field_get:SetLeader.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLeader::set_leader(ArgT0&& arg0, ArgT... args) {
 
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetLeader.leader)
}
inline std::string* SetLeader::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:SetLeader.leader)
  return _s;
}
inline const std::string& SetLeader::_internal_leader() const {
  return leader_.Get();
}
inline void SetLeader::_internal_set_leader(const std::string& value) {
  
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetLeader::_internal_mutable_leader() {
  
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetLeader::release_leader() {
  // @@protoc_insertion_point(field_release:SetLeader.leader)
  return leader_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetLeader::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    
  } else {
    
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SetLeader.leader)
}

// -------------------------------------------------------------------

// AdminStartGame

// -------------------------------------------------------------------

// LobbyError

// string message = 1;
inline void LobbyError::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& LobbyError::message() const {
  // @@protoc_insertion_point(field_get:LobbyError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LobbyError::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LobbyError.message)
}
inline std::string* LobbyError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:LobbyError.message)
  return _s;
}
inline const std::string& LobbyError::_internal_message() const {
  return message_.Get();
}
inline void LobbyError::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LobbyError::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LobbyError::release_message() {
  // @@protoc_insertion_point(field_release:LobbyError.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LobbyError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:LobbyError.message)
}

// -------------------------------------------------------------------

// StartGame

// -------------------------------------------------------------------

// PlayerInfo

// string username = 1;
inline void PlayerInfo::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& PlayerInfo::username() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerInfo.username)
}
inline std::string* PlayerInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:PlayerInfo.username)
  return _s;
}
inline const std::string& PlayerInfo::_internal_username() const {
  return username_.Get();
}
inline void PlayerInfo::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_username() {
  // @@protoc_insertion_point(field_release:PlayerInfo.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PlayerInfo.username)
}

// string civID = 2;
inline void PlayerInfo::clear_civid() {
  civid_.ClearToEmpty();
}
inline const std::string& PlayerInfo::civid() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.civID)
  return _internal_civid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_civid(ArgT0&& arg0, ArgT... args) {
 
 civid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerInfo.civID)
}
inline std::string* PlayerInfo::mutable_civid() {
  std::string* _s = _internal_mutable_civid();
  // @@protoc_insertion_point(field_mutable:PlayerInfo.civID)
  return _s;
}
inline const std::string& PlayerInfo::_internal_civid() const {
  return civid_.Get();
}
inline void PlayerInfo::_internal_set_civid(const std::string& value) {
  
  civid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_civid() {
  
  return civid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_civid() {
  // @@protoc_insertion_point(field_release:PlayerInfo.civID)
  return civid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerInfo::set_allocated_civid(std::string* civid) {
  if (civid != nullptr) {
    
  } else {
    
  }
  civid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), civid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PlayerInfo.civID)
}

// string leaderName = 3;
inline void PlayerInfo::clear_leadername() {
  leadername_.ClearToEmpty();
}
inline const std::string& PlayerInfo::leadername() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.leaderName)
  return _internal_leadername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_leadername(ArgT0&& arg0, ArgT... args) {
 
 leadername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerInfo.leaderName)
}
inline std::string* PlayerInfo::mutable_leadername() {
  std::string* _s = _internal_mutable_leadername();
  // @@protoc_insertion_point(field_mutable:PlayerInfo.leaderName)
  return _s;
}
inline const std::string& PlayerInfo::_internal_leadername() const {
  return leadername_.Get();
}
inline void PlayerInfo::_internal_set_leadername(const std::string& value) {
  
  leadername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_leadername() {
  
  return leadername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_leadername() {
  // @@protoc_insertion_point(field_release:PlayerInfo.leaderName)
  return leadername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerInfo::set_allocated_leadername(std::string* leadername) {
  if (leadername != nullptr) {
    
  } else {
    
  }
  leadername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leadername,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PlayerInfo.leaderName)
}

// int32 score = 4;
inline void PlayerInfo::clear_score() {
  score_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_score() const {
  return score_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::score() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.score)
  return _internal_score();
}
inline void PlayerInfo::_internal_set_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  score_ = value;
}
inline void PlayerInfo::set_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.score)
}

// int32 id = 5;
inline void PlayerInfo::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.id)
  return _internal_id();
}
inline void PlayerInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void PlayerInfo::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.id)
}

// bool isAdmin = 6;
inline void PlayerInfo::clear_isadmin() {
  isadmin_ = false;
}
inline bool PlayerInfo::_internal_isadmin() const {
  return isadmin_;
}
inline bool PlayerInfo::isadmin() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.isAdmin)
  return _internal_isadmin();
}
inline void PlayerInfo::_internal_set_isadmin(bool value) {
  
  isadmin_ = value;
}
inline void PlayerInfo::set_isadmin(bool value) {
  _internal_set_isadmin(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.isAdmin)
}

// -------------------------------------------------------------------

// UpdateGlobalData

// repeated .PlayerInfo players = 1;
inline int UpdateGlobalData::_internal_players_size() const {
  return players_.size();
}
inline int UpdateGlobalData::players_size() const {
  return _internal_players_size();
}
inline void UpdateGlobalData::clear_players() {
  players_.Clear();
}
inline ::PlayerInfo* UpdateGlobalData::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateGlobalData.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
UpdateGlobalData::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:UpdateGlobalData.players)
  return &players_;
}
inline const ::PlayerInfo& UpdateGlobalData::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::PlayerInfo& UpdateGlobalData::players(int index) const {
  // @@protoc_insertion_point(field_get:UpdateGlobalData.players)
  return _internal_players(index);
}
inline ::PlayerInfo* UpdateGlobalData::_internal_add_players() {
  return players_.Add();
}
inline ::PlayerInfo* UpdateGlobalData::add_players() {
  ::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:UpdateGlobalData.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
UpdateGlobalData::players() const {
  // @@protoc_insertion_point(field_list:UpdateGlobalData.players)
  return players_;
}

// int32 turn = 2;
inline void UpdateGlobalData::clear_turn() {
  turn_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateGlobalData::_internal_turn() const {
  return turn_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateGlobalData::turn() const {
  // @@protoc_insertion_point(field_get:UpdateGlobalData.turn)
  return _internal_turn();
}
inline void UpdateGlobalData::_internal_set_turn(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  turn_ = value;
}
inline void UpdateGlobalData::set_turn(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_turn(value);
  // @@protoc_insertion_point(field_set:UpdateGlobalData.turn)
}

// .Era era = 3;
inline void UpdateGlobalData::clear_era() {
  era_ = 0;
}
inline ::Era UpdateGlobalData::_internal_era() const {
  return static_cast< ::Era >(era_);
}
inline ::Era UpdateGlobalData::era() const {
  // @@protoc_insertion_point(field_get:UpdateGlobalData.era)
  return _internal_era();
}
inline void UpdateGlobalData::_internal_set_era(::Era value) {
  
  era_ = value;
}
inline void UpdateGlobalData::set_era(::Era value) {
  _internal_set_era(value);
  // @@protoc_insertion_point(field_set:UpdateGlobalData.era)
}

// -------------------------------------------------------------------

// Improvement

// string id = 1;
inline void Improvement::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Improvement::id() const {
  // @@protoc_insertion_point(field_get:Improvement.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Improvement::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Improvement.id)
}
inline std::string* Improvement::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Improvement.id)
  return _s;
}
inline const std::string& Improvement::_internal_id() const {
  return id_.Get();
}
inline void Improvement::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Improvement::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Improvement::release_id() {
  // @@protoc_insertion_point(field_release:Improvement.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Improvement::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Improvement.id)
}

// string cottageLevel = 2;
inline void Improvement::clear_cottagelevel() {
  cottagelevel_.ClearToEmpty();
}
inline const std::string& Improvement::cottagelevel() const {
  // @@protoc_insertion_point(field_get:Improvement.cottageLevel)
  return _internal_cottagelevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Improvement::set_cottagelevel(ArgT0&& arg0, ArgT... args) {
 
 cottagelevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Improvement.cottageLevel)
}
inline std::string* Improvement::mutable_cottagelevel() {
  std::string* _s = _internal_mutable_cottagelevel();
  // @@protoc_insertion_point(field_mutable:Improvement.cottageLevel)
  return _s;
}
inline const std::string& Improvement::_internal_cottagelevel() const {
  return cottagelevel_.Get();
}
inline void Improvement::_internal_set_cottagelevel(const std::string& value) {
  
  cottagelevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Improvement::_internal_mutable_cottagelevel() {
  
  return cottagelevel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Improvement::release_cottagelevel() {
  // @@protoc_insertion_point(field_release:Improvement.cottageLevel)
  return cottagelevel_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Improvement::set_allocated_cottagelevel(std::string* cottagelevel) {
  if (cottagelevel != nullptr) {
    
  } else {
    
  }
  cottagelevel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cottagelevel,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Improvement.cottageLevel)
}

// -------------------------------------------------------------------

// Yield

// int32 hammers = 1;
inline void Yield::clear_hammers() {
  hammers_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::_internal_hammers() const {
  return hammers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::hammers() const {
  // @@protoc_insertion_point(field_get:Yield.hammers)
  return _internal_hammers();
}
inline void Yield::_internal_set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hammers_ = value;
}
inline void Yield::set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hammers(value);
  // @@protoc_insertion_point(field_set:Yield.hammers)
}

// int32 commerce = 2;
inline void Yield::clear_commerce() {
  commerce_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::_internal_commerce() const {
  return commerce_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::commerce() const {
  // @@protoc_insertion_point(field_get:Yield.commerce)
  return _internal_commerce();
}
inline void Yield::_internal_set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  commerce_ = value;
}
inline void Yield::set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_commerce(value);
  // @@protoc_insertion_point(field_set:Yield.commerce)
}

// int32 food = 3;
inline void Yield::clear_food() {
  food_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::_internal_food() const {
  return food_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::food() const {
  // @@protoc_insertion_point(field_get:Yield.food)
  return _internal_food();
}
inline void Yield::_internal_set_food(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  food_ = value;
}
inline void Yield::set_food(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_food(value);
  // @@protoc_insertion_point(field_set:Yield.food)
}

// -------------------------------------------------------------------

// Tile

// .Terrain terrain = 1;
inline void Tile::clear_terrain() {
  terrain_ = 0;
}
inline ::Terrain Tile::_internal_terrain() const {
  return static_cast< ::Terrain >(terrain_);
}
inline ::Terrain Tile::terrain() const {
  // @@protoc_insertion_point(field_get:Tile.terrain)
  return _internal_terrain();
}
inline void Tile::_internal_set_terrain(::Terrain value) {
  
  terrain_ = value;
}
inline void Tile::set_terrain(::Terrain value) {
  _internal_set_terrain(value);
  // @@protoc_insertion_point(field_set:Tile.terrain)
}

// bool forested = 2;
inline void Tile::clear_forested() {
  forested_ = false;
}
inline bool Tile::_internal_forested() const {
  return forested_;
}
inline bool Tile::forested() const {
  // @@protoc_insertion_point(field_get:Tile.forested)
  return _internal_forested();
}
inline void Tile::_internal_set_forested(bool value) {
  
  forested_ = value;
}
inline void Tile::set_forested(bool value) {
  _internal_set_forested(value);
  // @@protoc_insertion_point(field_set:Tile.forested)
}

// bool hilled = 3;
inline void Tile::clear_hilled() {
  hilled_ = false;
}
inline bool Tile::_internal_hilled() const {
  return hilled_;
}
inline bool Tile::hilled() const {
  // @@protoc_insertion_point(field_get:Tile.hilled)
  return _internal_hilled();
}
inline void Tile::_internal_set_hilled(bool value) {
  
  hilled_ = value;
}
inline void Tile::set_hilled(bool value) {
  _internal_set_hilled(value);
  // @@protoc_insertion_point(field_set:Tile.hilled)
}

// repeated .Improvement improvements = 4;
inline int Tile::_internal_improvements_size() const {
  return improvements_.size();
}
inline int Tile::improvements_size() const {
  return _internal_improvements_size();
}
inline void Tile::clear_improvements() {
  improvements_.Clear();
}
inline ::Improvement* Tile::mutable_improvements(int index) {
  // @@protoc_insertion_point(field_mutable:Tile.improvements)
  return improvements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >*
Tile::mutable_improvements() {
  // @@protoc_insertion_point(field_mutable_list:Tile.improvements)
  return &improvements_;
}
inline const ::Improvement& Tile::_internal_improvements(int index) const {
  return improvements_.Get(index);
}
inline const ::Improvement& Tile::improvements(int index) const {
  // @@protoc_insertion_point(field_get:Tile.improvements)
  return _internal_improvements(index);
}
inline ::Improvement* Tile::_internal_add_improvements() {
  return improvements_.Add();
}
inline ::Improvement* Tile::add_improvements() {
  ::Improvement* _add = _internal_add_improvements();
  // @@protoc_insertion_point(field_add:Tile.improvements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >&
Tile::improvements() const {
  // @@protoc_insertion_point(field_list:Tile.improvements)
  return improvements_;
}

// .Yield yield = 5;
inline bool Tile::_internal_has_yield() const {
  return this != internal_default_instance() && yield_ != nullptr;
}
inline bool Tile::has_yield() const {
  return _internal_has_yield();
}
inline void Tile::clear_yield() {
  if (GetArenaForAllocation() == nullptr && yield_ != nullptr) {
    delete yield_;
  }
  yield_ = nullptr;
}
inline const ::Yield& Tile::_internal_yield() const {
  const ::Yield* p = yield_;
  return p != nullptr ? *p : reinterpret_cast<const ::Yield&>(
      ::_Yield_default_instance_);
}
inline const ::Yield& Tile::yield() const {
  // @@protoc_insertion_point(field_get:Tile.yield)
  return _internal_yield();
}
inline void Tile::unsafe_arena_set_allocated_yield(
    ::Yield* yield) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(yield_);
  }
  yield_ = yield;
  if (yield) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tile.yield)
}
inline ::Yield* Tile::release_yield() {
  
  ::Yield* temp = yield_;
  yield_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Yield* Tile::unsafe_arena_release_yield() {
  // @@protoc_insertion_point(field_release:Tile.yield)
  
  ::Yield* temp = yield_;
  yield_ = nullptr;
  return temp;
}
inline ::Yield* Tile::_internal_mutable_yield() {
  
  if (yield_ == nullptr) {
    auto* p = CreateMaybeMessage<::Yield>(GetArenaForAllocation());
    yield_ = p;
  }
  return yield_;
}
inline ::Yield* Tile::mutable_yield() {
  ::Yield* _msg = _internal_mutable_yield();
  // @@protoc_insertion_point(field_mutable:Tile.yield)
  return _msg;
}
inline void Tile::set_allocated_yield(::Yield* yield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete yield_;
  }
  if (yield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Yield>::GetOwningArena(yield);
    if (message_arena != submessage_arena) {
      yield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield, submessage_arena);
    }
    
  } else {
    
  }
  yield_ = yield;
  // @@protoc_insertion_point(field_set_allocated:Tile.yield)
}

// int32 ownerID = 6;
inline void Tile::clear_ownerid() {
  ownerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tile::_internal_ownerid() const {
  return ownerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tile::ownerid() const {
  // @@protoc_insertion_point(field_get:Tile.ownerID)
  return _internal_ownerid();
}
inline void Tile::_internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ownerid_ = value;
}
inline void Tile::set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Tile.ownerID)
}

// bool hasOwner = 7;
inline void Tile::clear_hasowner() {
  hasowner_ = false;
}
inline bool Tile::_internal_hasowner() const {
  return hasowner_;
}
inline bool Tile::hasowner() const {
  // @@protoc_insertion_point(field_get:Tile.hasOwner)
  return _internal_hasowner();
}
inline void Tile::_internal_set_hasowner(bool value) {
  
  hasowner_ = value;
}
inline void Tile::set_hasowner(bool value) {
  _internal_set_hasowner(value);
  // @@protoc_insertion_point(field_set:Tile.hasOwner)
}

// bool isWorked = 8;
inline void Tile::clear_isworked() {
  isworked_ = false;
}
inline bool Tile::_internal_isworked() const {
  return isworked_;
}
inline bool Tile::isworked() const {
  // @@protoc_insertion_point(field_get:Tile.isWorked)
  return _internal_isworked();
}
inline void Tile::_internal_set_isworked(bool value) {
  
  isworked_ = value;
}
inline void Tile::set_isworked(bool value) {
  _internal_set_isworked(value);
  // @@protoc_insertion_point(field_set:Tile.isWorked)
}

// -------------------------------------------------------------------

// UpdateMap

// uint32 width = 1;
inline void UpdateMap::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::width() const {
  // @@protoc_insertion_point(field_get:UpdateMap.width)
  return _internal_width();
}
inline void UpdateMap::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void UpdateMap::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:UpdateMap.width)
}

// uint32 height = 2;
inline void UpdateMap::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::height() const {
  // @@protoc_insertion_point(field_get:UpdateMap.height)
  return _internal_height();
}
inline void UpdateMap::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void UpdateMap::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:UpdateMap.height)
}

// repeated .Tile tiles = 3;
inline int UpdateMap::_internal_tiles_size() const {
  return tiles_.size();
}
inline int UpdateMap::tiles_size() const {
  return _internal_tiles_size();
}
inline void UpdateMap::clear_tiles() {
  tiles_.Clear();
}
inline ::Tile* UpdateMap::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateMap.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
UpdateMap::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:UpdateMap.tiles)
  return &tiles_;
}
inline const ::Tile& UpdateMap::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::Tile& UpdateMap::tiles(int index) const {
  // @@protoc_insertion_point(field_get:UpdateMap.tiles)
  return _internal_tiles(index);
}
inline ::Tile* UpdateMap::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::Tile* UpdateMap::add_tiles() {
  ::Tile* _add = _internal_add_tiles();
  // @@protoc_insertion_point(field_add:UpdateMap.tiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
UpdateMap::tiles() const {
  // @@protoc_insertion_point(field_list:UpdateMap.tiles)
  return tiles_;
}

// repeated .Visibility visibility = 4;
inline int UpdateMap::_internal_visibility_size() const {
  return visibility_.size();
}
inline int UpdateMap::visibility_size() const {
  return _internal_visibility_size();
}
inline void UpdateMap::clear_visibility() {
  visibility_.Clear();
}
inline ::Visibility UpdateMap::_internal_visibility(int index) const {
  return static_cast< ::Visibility >(visibility_.Get(index));
}
inline ::Visibility UpdateMap::visibility(int index) const {
  // @@protoc_insertion_point(field_get:UpdateMap.visibility)
  return _internal_visibility(index);
}
inline void UpdateMap::set_visibility(int index, ::Visibility value) {
  visibility_.Set(index, value);
  // @@protoc_insertion_point(field_set:UpdateMap.visibility)
}
inline void UpdateMap::_internal_add_visibility(::Visibility value) {
  visibility_.Add(value);
}
inline void UpdateMap::add_visibility(::Visibility value) {
  _internal_add_visibility(value);
  // @@protoc_insertion_point(field_add:UpdateMap.visibility)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UpdateMap::visibility() const {
  // @@protoc_insertion_point(field_list:UpdateMap.visibility)
  return visibility_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UpdateMap::_internal_mutable_visibility() {
  return &visibility_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UpdateMap::mutable_visibility() {
  // @@protoc_insertion_point(field_mutable_list:UpdateMap.visibility)
  return _internal_mutable_visibility();
}

// -------------------------------------------------------------------

// UnitBuildTask

// string unitKindID = 1;
inline void UnitBuildTask::clear_unitkindid() {
  unitkindid_.ClearToEmpty();
}
inline const std::string& UnitBuildTask::unitkindid() const {
  // @@protoc_insertion_point(field_get:UnitBuildTask.unitKindID)
  return _internal_unitkindid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnitBuildTask::set_unitkindid(ArgT0&& arg0, ArgT... args) {
 
 unitkindid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UnitBuildTask.unitKindID)
}
inline std::string* UnitBuildTask::mutable_unitkindid() {
  std::string* _s = _internal_mutable_unitkindid();
  // @@protoc_insertion_point(field_mutable:UnitBuildTask.unitKindID)
  return _s;
}
inline const std::string& UnitBuildTask::_internal_unitkindid() const {
  return unitkindid_.Get();
}
inline void UnitBuildTask::_internal_set_unitkindid(const std::string& value) {
  
  unitkindid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnitBuildTask::_internal_mutable_unitkindid() {
  
  return unitkindid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnitBuildTask::release_unitkindid() {
  // @@protoc_insertion_point(field_release:UnitBuildTask.unitKindID)
  return unitkindid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnitBuildTask::set_allocated_unitkindid(std::string* unitkindid) {
  if (unitkindid != nullptr) {
    
  } else {
    
  }
  unitkindid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unitkindid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:UnitBuildTask.unitKindID)
}

// -------------------------------------------------------------------

// BuildingBuildTask

// string buildingName = 1;
inline void BuildingBuildTask::clear_buildingname() {
  buildingname_.ClearToEmpty();
}
inline const std::string& BuildingBuildTask::buildingname() const {
  // @@protoc_insertion_point(field_get:BuildingBuildTask.buildingName)
  return _internal_buildingname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildingBuildTask::set_buildingname(ArgT0&& arg0, ArgT... args) {
 
 buildingname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildingBuildTask.buildingName)
}
inline std::string* BuildingBuildTask::mutable_buildingname() {
  std::string* _s = _internal_mutable_buildingname();
  // @@protoc_insertion_point(field_mutable:BuildingBuildTask.buildingName)
  return _s;
}
inline const std::string& BuildingBuildTask::_internal_buildingname() const {
  return buildingname_.Get();
}
inline void BuildingBuildTask::_internal_set_buildingname(const std::string& value) {
  
  buildingname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BuildingBuildTask::_internal_mutable_buildingname() {
  
  return buildingname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BuildingBuildTask::release_buildingname() {
  // @@protoc_insertion_point(field_release:BuildingBuildTask.buildingName)
  return buildingname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BuildingBuildTask::set_allocated_buildingname(std::string* buildingname) {
  if (buildingname != nullptr) {
    
  } else {
    
  }
  buildingname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buildingname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:BuildingBuildTask.buildingName)
}

// -------------------------------------------------------------------

// BuildTaskKind

// .UnitBuildTask unit = 1;
inline bool BuildTaskKind::_internal_has_unit() const {
  return task_case() == kUnit;
}
inline bool BuildTaskKind::has_unit() const {
  return _internal_has_unit();
}
inline void BuildTaskKind::set_has_unit() {
  _oneof_case_[0] = kUnit;
}
inline void BuildTaskKind::clear_unit() {
  if (_internal_has_unit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete task_.unit_;
    }
    clear_has_task();
  }
}
inline ::UnitBuildTask* BuildTaskKind::release_unit() {
  // @@protoc_insertion_point(field_release:BuildTaskKind.unit)
  if (_internal_has_unit()) {
    clear_has_task();
      ::UnitBuildTask* temp = task_.unit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UnitBuildTask& BuildTaskKind::_internal_unit() const {
  return _internal_has_unit()
      ? *task_.unit_
      : reinterpret_cast< ::UnitBuildTask&>(::_UnitBuildTask_default_instance_);
}
inline const ::UnitBuildTask& BuildTaskKind::unit() const {
  // @@protoc_insertion_point(field_get:BuildTaskKind.unit)
  return _internal_unit();
}
inline ::UnitBuildTask* BuildTaskKind::unsafe_arena_release_unit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BuildTaskKind.unit)
  if (_internal_has_unit()) {
    clear_has_task();
    ::UnitBuildTask* temp = task_.unit_;
    task_.unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuildTaskKind::unsafe_arena_set_allocated_unit(::UnitBuildTask* unit) {
  clear_task();
  if (unit) {
    set_has_unit();
    task_.unit_ = unit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildTaskKind.unit)
}
inline ::UnitBuildTask* BuildTaskKind::_internal_mutable_unit() {
  if (!_internal_has_unit()) {
    clear_task();
    set_has_unit();
    task_.unit_ = CreateMaybeMessage< ::UnitBuildTask >(GetArenaForAllocation());
  }
  return task_.unit_;
}
inline ::UnitBuildTask* BuildTaskKind::mutable_unit() {
  ::UnitBuildTask* _msg = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:BuildTaskKind.unit)
  return _msg;
}

// .BuildingBuildTask building = 2;
inline bool BuildTaskKind::_internal_has_building() const {
  return task_case() == kBuilding;
}
inline bool BuildTaskKind::has_building() const {
  return _internal_has_building();
}
inline void BuildTaskKind::set_has_building() {
  _oneof_case_[0] = kBuilding;
}
inline void BuildTaskKind::clear_building() {
  if (_internal_has_building()) {
    if (GetArenaForAllocation() == nullptr) {
      delete task_.building_;
    }
    clear_has_task();
  }
}
inline ::BuildingBuildTask* BuildTaskKind::release_building() {
  // @@protoc_insertion_point(field_release:BuildTaskKind.building)
  if (_internal_has_building()) {
    clear_has_task();
      ::BuildingBuildTask* temp = task_.building_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.building_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::BuildingBuildTask& BuildTaskKind::_internal_building() const {
  return _internal_has_building()
      ? *task_.building_
      : reinterpret_cast< ::BuildingBuildTask&>(::_BuildingBuildTask_default_instance_);
}
inline const ::BuildingBuildTask& BuildTaskKind::building() const {
  // @@protoc_insertion_point(field_get:BuildTaskKind.building)
  return _internal_building();
}
inline ::BuildingBuildTask* BuildTaskKind::unsafe_arena_release_building() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BuildTaskKind.building)
  if (_internal_has_building()) {
    clear_has_task();
    ::BuildingBuildTask* temp = task_.building_;
    task_.building_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuildTaskKind::unsafe_arena_set_allocated_building(::BuildingBuildTask* building) {
  clear_task();
  if (building) {
    set_has_building();
    task_.building_ = building;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildTaskKind.building)
}
inline ::BuildingBuildTask* BuildTaskKind::_internal_mutable_building() {
  if (!_internal_has_building()) {
    clear_task();
    set_has_building();
    task_.building_ = CreateMaybeMessage< ::BuildingBuildTask >(GetArenaForAllocation());
  }
  return task_.building_;
}
inline ::BuildingBuildTask* BuildTaskKind::mutable_building() {
  ::BuildingBuildTask* _msg = _internal_mutable_building();
  // @@protoc_insertion_point(field_mutable:BuildTaskKind.building)
  return _msg;
}

inline bool BuildTaskKind::has_task() const {
  return task_case() != TASK_NOT_SET;
}
inline void BuildTaskKind::clear_has_task() {
  _oneof_case_[0] = TASK_NOT_SET;
}
inline BuildTaskKind::TaskCase BuildTaskKind::task_case() const {
  return BuildTaskKind::TaskCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BuildTask

// .BuildTaskKind kind = 1;
inline bool BuildTask::_internal_has_kind() const {
  return this != internal_default_instance() && kind_ != nullptr;
}
inline bool BuildTask::has_kind() const {
  return _internal_has_kind();
}
inline void BuildTask::clear_kind() {
  if (GetArenaForAllocation() == nullptr && kind_ != nullptr) {
    delete kind_;
  }
  kind_ = nullptr;
}
inline const ::BuildTaskKind& BuildTask::_internal_kind() const {
  const ::BuildTaskKind* p = kind_;
  return p != nullptr ? *p : reinterpret_cast<const ::BuildTaskKind&>(
      ::_BuildTaskKind_default_instance_);
}
inline const ::BuildTaskKind& BuildTask::kind() const {
  // @@protoc_insertion_point(field_get:BuildTask.kind)
  return _internal_kind();
}
inline void BuildTask::unsafe_arena_set_allocated_kind(
    ::BuildTaskKind* kind) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kind_);
  }
  kind_ = kind;
  if (kind) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildTask.kind)
}
inline ::BuildTaskKind* BuildTask::release_kind() {
  
  ::BuildTaskKind* temp = kind_;
  kind_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BuildTaskKind* BuildTask::unsafe_arena_release_kind() {
  // @@protoc_insertion_point(field_release:BuildTask.kind)
  
  ::BuildTaskKind* temp = kind_;
  kind_ = nullptr;
  return temp;
}
inline ::BuildTaskKind* BuildTask::_internal_mutable_kind() {
  
  if (kind_ == nullptr) {
    auto* p = CreateMaybeMessage<::BuildTaskKind>(GetArenaForAllocation());
    kind_ = p;
  }
  return kind_;
}
inline ::BuildTaskKind* BuildTask::mutable_kind() {
  ::BuildTaskKind* _msg = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:BuildTask.kind)
  return _msg;
}
inline void BuildTask::set_allocated_kind(::BuildTaskKind* kind) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kind_;
  }
  if (kind) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::BuildTaskKind>::GetOwningArena(kind);
    if (message_arena != submessage_arena) {
      kind = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kind, submessage_arena);
    }
    
  } else {
    
  }
  kind_ = kind;
  // @@protoc_insertion_point(field_set_allocated:BuildTask.kind)
}

// int32 progress = 2;
inline void BuildTask::clear_progress() {
  progress_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::_internal_progress() const {
  return progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::progress() const {
  // @@protoc_insertion_point(field_get:BuildTask.progress)
  return _internal_progress();
}
inline void BuildTask::_internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  progress_ = value;
}
inline void BuildTask::set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:BuildTask.progress)
}

// int32 cost = 3;
inline void BuildTask::clear_cost() {
  cost_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::_internal_cost() const {
  return cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::cost() const {
  // @@protoc_insertion_point(field_get:BuildTask.cost)
  return _internal_cost();
}
inline void BuildTask::_internal_set_cost(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cost_ = value;
}
inline void BuildTask::set_cost(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:BuildTask.cost)
}

// -------------------------------------------------------------------

// UpdateCity

// .Pos pos = 1;
inline bool UpdateCity::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool UpdateCity::has_pos() const {
  return _internal_has_pos();
}
inline void UpdateCity::clear_pos() {
  if (GetArenaForAllocation() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::Pos& UpdateCity::_internal_pos() const {
  const ::Pos* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Pos&>(
      ::_Pos_default_instance_);
}
inline const ::Pos& UpdateCity::pos() const {
  // @@protoc_insertion_point(field_get:UpdateCity.pos)
  return _internal_pos();
}
inline void UpdateCity::unsafe_arena_set_allocated_pos(
    ::Pos* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateCity.pos)
}
inline ::Pos* UpdateCity::release_pos() {
  
  ::Pos* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Pos* UpdateCity::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:UpdateCity.pos)
  
  ::Pos* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::Pos* UpdateCity::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::Pos* UpdateCity::mutable_pos() {
  ::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:UpdateCity.pos)
  return _msg;
}
inline void UpdateCity::set_allocated_pos(::Pos* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Pos>::GetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:UpdateCity.pos)
}

// string name = 2;
inline void UpdateCity::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateCity::name() const {
  // @@protoc_insertion_point(field_get:UpdateCity.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCity::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UpdateCity.name)
}
inline std::string* UpdateCity::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:UpdateCity.name)
  return _s;
}
inline const std::string& UpdateCity::_internal_name() const {
  return name_.Get();
}
inline void UpdateCity::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateCity::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateCity::release_name() {
  // @@protoc_insertion_point(field_release:UpdateCity.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateCity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:UpdateCity.name)
}

// int32 ownerID = 3;
inline void UpdateCity::clear_ownerid() {
  ownerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_ownerid() const {
  return ownerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::ownerid() const {
  // @@protoc_insertion_point(field_get:UpdateCity.ownerID)
  return _internal_ownerid();
}
inline void UpdateCity::_internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ownerid_ = value;
}
inline void UpdateCity::set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:UpdateCity.ownerID)
}

// .BuildTask buildTask = 4;
inline bool UpdateCity::_internal_has_buildtask() const {
  return this != internal_default_instance() && buildtask_ != nullptr;
}
inline bool UpdateCity::has_buildtask() const {
  return _internal_has_buildtask();
}
inline void UpdateCity::clear_buildtask() {
  if (GetArenaForAllocation() == nullptr && buildtask_ != nullptr) {
    delete buildtask_;
  }
  buildtask_ = nullptr;
}
inline const ::BuildTask& UpdateCity::_internal_buildtask() const {
  const ::BuildTask* p = buildtask_;
  return p != nullptr ? *p : reinterpret_cast<const ::BuildTask&>(
      ::_BuildTask_default_instance_);
}
inline const ::BuildTask& UpdateCity::buildtask() const {
  // @@protoc_insertion_point(field_get:UpdateCity.buildTask)
  return _internal_buildtask();
}
inline void UpdateCity::unsafe_arena_set_allocated_buildtask(
    ::BuildTask* buildtask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(buildtask_);
  }
  buildtask_ = buildtask;
  if (buildtask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateCity.buildTask)
}
inline ::BuildTask* UpdateCity::release_buildtask() {
  
  ::BuildTask* temp = buildtask_;
  buildtask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BuildTask* UpdateCity::unsafe_arena_release_buildtask() {
  // @@protoc_insertion_point(field_release:UpdateCity.buildTask)
  
  ::BuildTask* temp = buildtask_;
  buildtask_ = nullptr;
  return temp;
}
inline ::BuildTask* UpdateCity::_internal_mutable_buildtask() {
  
  if (buildtask_ == nullptr) {
    auto* p = CreateMaybeMessage<::BuildTask>(GetArenaForAllocation());
    buildtask_ = p;
  }
  return buildtask_;
}
inline ::BuildTask* UpdateCity::mutable_buildtask() {
  ::BuildTask* _msg = _internal_mutable_buildtask();
  // @@protoc_insertion_point(field_mutable:UpdateCity.buildTask)
  return _msg;
}
inline void UpdateCity::set_allocated_buildtask(::BuildTask* buildtask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete buildtask_;
  }
  if (buildtask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::BuildTask>::GetOwningArena(buildtask);
    if (message_arena != submessage_arena) {
      buildtask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildtask, submessage_arena);
    }
    
  } else {
    
  }
  buildtask_ = buildtask;
  // @@protoc_insertion_point(field_set_allocated:UpdateCity.buildTask)
}

// .Yield yield = 5;
inline bool UpdateCity::_internal_has_yield() const {
  return this != internal_default_instance() && yield_ != nullptr;
}
inline bool UpdateCity::has_yield() const {
  return _internal_has_yield();
}
inline void UpdateCity::clear_yield() {
  if (GetArenaForAllocation() == nullptr && yield_ != nullptr) {
    delete yield_;
  }
  yield_ = nullptr;
}
inline const ::Yield& UpdateCity::_internal_yield() const {
  const ::Yield* p = yield_;
  return p != nullptr ? *p : reinterpret_cast<const ::Yield&>(
      ::_Yield_default_instance_);
}
inline const ::Yield& UpdateCity::yield() const {
  // @@protoc_insertion_point(field_get:UpdateCity.yield)
  return _internal_yield();
}
inline void UpdateCity::unsafe_arena_set_allocated_yield(
    ::Yield* yield) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(yield_);
  }
  yield_ = yield;
  if (yield) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateCity.yield)
}
inline ::Yield* UpdateCity::release_yield() {
  
  ::Yield* temp = yield_;
  yield_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Yield* UpdateCity::unsafe_arena_release_yield() {
  // @@protoc_insertion_point(field_release:UpdateCity.yield)
  
  ::Yield* temp = yield_;
  yield_ = nullptr;
  return temp;
}
inline ::Yield* UpdateCity::_internal_mutable_yield() {
  
  if (yield_ == nullptr) {
    auto* p = CreateMaybeMessage<::Yield>(GetArenaForAllocation());
    yield_ = p;
  }
  return yield_;
}
inline ::Yield* UpdateCity::mutable_yield() {
  ::Yield* _msg = _internal_mutable_yield();
  // @@protoc_insertion_point(field_mutable:UpdateCity.yield)
  return _msg;
}
inline void UpdateCity::set_allocated_yield(::Yield* yield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete yield_;
  }
  if (yield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Yield>::GetOwningArena(yield);
    if (message_arena != submessage_arena) {
      yield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield, submessage_arena);
    }
    
  } else {
    
  }
  yield_ = yield;
  // @@protoc_insertion_point(field_set_allocated:UpdateCity.yield)
}

// int32 culture = 6;
inline void UpdateCity::clear_culture() {
  culture_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_culture() const {
  return culture_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::culture() const {
  // @@protoc_insertion_point(field_get:UpdateCity.culture)
  return _internal_culture();
}
inline void UpdateCity::_internal_set_culture(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  culture_ = value;
}
inline void UpdateCity::set_culture(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_culture(value);
  // @@protoc_insertion_point(field_set:UpdateCity.culture)
}

// int32 cultureNeeded = 7;
inline void UpdateCity::clear_cultureneeded() {
  cultureneeded_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_cultureneeded() const {
  return cultureneeded_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::cultureneeded() const {
  // @@protoc_insertion_point(field_get:UpdateCity.cultureNeeded)
  return _internal_cultureneeded();
}
inline void UpdateCity::_internal_set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cultureneeded_ = value;
}
inline void UpdateCity::set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cultureneeded(value);
  // @@protoc_insertion_point(field_set:UpdateCity.cultureNeeded)
}

// int32 id = 8;
inline void UpdateCity::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::id() const {
  // @@protoc_insertion_point(field_get:UpdateCity.id)
  return _internal_id();
}
inline void UpdateCity::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void UpdateCity::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:UpdateCity.id)
}

// repeated string buildingNames = 9;
inline int UpdateCity::_internal_buildingnames_size() const {
  return buildingnames_.size();
}
inline int UpdateCity::buildingnames_size() const {
  return _internal_buildingnames_size();
}
inline void UpdateCity::clear_buildingnames() {
  buildingnames_.Clear();
}
inline std::string* UpdateCity::add_buildingnames() {
  std::string* _s = _internal_add_buildingnames();
  // @@protoc_insertion_point(field_add_mutable:UpdateCity.buildingNames)
  return _s;
}
inline const std::string& UpdateCity::_internal_buildingnames(int index) const {
  return buildingnames_.Get(index);
}
inline const std::string& UpdateCity::buildingnames(int index) const {
  // @@protoc_insertion_point(field_get:UpdateCity.buildingNames)
  return _internal_buildingnames(index);
}
inline std::string* UpdateCity::mutable_buildingnames(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateCity.buildingNames)
  return buildingnames_.Mutable(index);
}
inline void UpdateCity::set_buildingnames(int index, const std::string& value) {
  buildingnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:UpdateCity.buildingNames)
}
inline void UpdateCity::set_buildingnames(int index, std::string&& value) {
  buildingnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:UpdateCity.buildingNames)
}
inline void UpdateCity::set_buildingnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buildingnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdateCity.buildingNames)
}
inline void UpdateCity::set_buildingnames(int index, const char* value, size_t size) {
  buildingnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdateCity.buildingNames)
}
inline std::string* UpdateCity::_internal_add_buildingnames() {
  return buildingnames_.Add();
}
inline void UpdateCity::add_buildingnames(const std::string& value) {
  buildingnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:UpdateCity.buildingNames)
}
inline void UpdateCity::add_buildingnames(std::string&& value) {
  buildingnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:UpdateCity.buildingNames)
}
inline void UpdateCity::add_buildingnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buildingnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:UpdateCity.buildingNames)
}
inline void UpdateCity::add_buildingnames(const char* value, size_t size) {
  buildingnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:UpdateCity.buildingNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateCity::buildingnames() const {
  // @@protoc_insertion_point(field_list:UpdateCity.buildingNames)
  return buildingnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateCity::mutable_buildingnames() {
  // @@protoc_insertion_point(field_mutable_list:UpdateCity.buildingNames)
  return &buildingnames_;
}

// int32 population = 10;
inline void UpdateCity::clear_population() {
  population_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_population() const {
  return population_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::population() const {
  // @@protoc_insertion_point(field_get:UpdateCity.population)
  return _internal_population();
}
inline void UpdateCity::_internal_set_population(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  population_ = value;
}
inline void UpdateCity::set_population(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_population(value);
  // @@protoc_insertion_point(field_set:UpdateCity.population)
}

// int32 storedFood = 11;
inline void UpdateCity::clear_storedfood() {
  storedfood_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_storedfood() const {
  return storedfood_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::storedfood() const {
  // @@protoc_insertion_point(field_get:UpdateCity.storedFood)
  return _internal_storedfood();
}
inline void UpdateCity::_internal_set_storedfood(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  storedfood_ = value;
}
inline void UpdateCity::set_storedfood(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_storedfood(value);
  // @@protoc_insertion_point(field_set:UpdateCity.storedFood)
}

// int32 foodNeededForGrowth = 12;
inline void UpdateCity::clear_foodneededforgrowth() {
  foodneededforgrowth_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_foodneededforgrowth() const {
  return foodneededforgrowth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::foodneededforgrowth() const {
  // @@protoc_insertion_point(field_get:UpdateCity.foodNeededForGrowth)
  return _internal_foodneededforgrowth();
}
inline void UpdateCity::_internal_set_foodneededforgrowth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  foodneededforgrowth_ = value;
}
inline void UpdateCity::set_foodneededforgrowth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_foodneededforgrowth(value);
  // @@protoc_insertion_point(field_set:UpdateCity.foodNeededForGrowth)
}

// int32 consumedFood = 13;
inline void UpdateCity::clear_consumedfood() {
  consumedfood_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_consumedfood() const {
  return consumedfood_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::consumedfood() const {
  // @@protoc_insertion_point(field_get:UpdateCity.consumedFood)
  return _internal_consumedfood();
}
inline void UpdateCity::_internal_set_consumedfood(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  consumedfood_ = value;
}
inline void UpdateCity::set_consumedfood(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_consumedfood(value);
  // @@protoc_insertion_point(field_set:UpdateCity.consumedFood)
}

// -------------------------------------------------------------------

// Path

// repeated uint32 positions = 1;
inline int Path::_internal_positions_size() const {
  return positions_.size();
}
inline int Path::positions_size() const {
  return _internal_positions_size();
}
inline void Path::clear_positions() {
  positions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Path::_internal_positions(int index) const {
  return positions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Path::positions(int index) const {
  // @@protoc_insertion_point(field_get:Path.positions)
  return _internal_positions(index);
}
inline void Path::set_positions(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  positions_.Set(index, value);
  // @@protoc_insertion_point(field_set:Path.positions)
}
inline void Path::_internal_add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  positions_.Add(value);
}
inline void Path::add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_positions(value);
  // @@protoc_insertion_point(field_add:Path.positions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Path::_internal_positions() const {
  return positions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Path::positions() const {
  // @@protoc_insertion_point(field_list:Path.positions)
  return _internal_positions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Path::_internal_mutable_positions() {
  return &positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Path::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:Path.positions)
  return _internal_mutable_positions();
}

// -------------------------------------------------------------------

// FoundCityCapability

// -------------------------------------------------------------------

// WorkerTaskImprovement

// string improvementID = 1;
inline void WorkerTaskImprovement::clear_improvementid() {
  improvementid_.ClearToEmpty();
}
inline const std::string& WorkerTaskImprovement::improvementid() const {
  // @@protoc_insertion_point(field_get:WorkerTaskImprovement.improvementID)
  return _internal_improvementid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerTaskImprovement::set_improvementid(ArgT0&& arg0, ArgT... args) {
 
 improvementid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WorkerTaskImprovement.improvementID)
}
inline std::string* WorkerTaskImprovement::mutable_improvementid() {
  std::string* _s = _internal_mutable_improvementid();
  // @@protoc_insertion_point(field_mutable:WorkerTaskImprovement.improvementID)
  return _s;
}
inline const std::string& WorkerTaskImprovement::_internal_improvementid() const {
  return improvementid_.Get();
}
inline void WorkerTaskImprovement::_internal_set_improvementid(const std::string& value) {
  
  improvementid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WorkerTaskImprovement::_internal_mutable_improvementid() {
  
  return improvementid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WorkerTaskImprovement::release_improvementid() {
  // @@protoc_insertion_point(field_release:WorkerTaskImprovement.improvementID)
  return improvementid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WorkerTaskImprovement::set_allocated_improvementid(std::string* improvementid) {
  if (improvementid != nullptr) {
    
  } else {
    
  }
  improvementid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), improvementid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:WorkerTaskImprovement.improvementID)
}

// -------------------------------------------------------------------

// WorkerTaskKind

// .WorkerTaskImprovement buildImprovement = 1;
inline bool WorkerTaskKind::_internal_has_buildimprovement() const {
  return kind_case() == kBuildImprovement;
}
inline bool WorkerTaskKind::has_buildimprovement() const {
  return _internal_has_buildimprovement();
}
inline void WorkerTaskKind::set_has_buildimprovement() {
  _oneof_case_[0] = kBuildImprovement;
}
inline void WorkerTaskKind::clear_buildimprovement() {
  if (_internal_has_buildimprovement()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.buildimprovement_;
    }
    clear_has_kind();
  }
}
inline ::WorkerTaskImprovement* WorkerTaskKind::release_buildimprovement() {
  // @@protoc_insertion_point(field_release:WorkerTaskKind.buildImprovement)
  if (_internal_has_buildimprovement()) {
    clear_has_kind();
      ::WorkerTaskImprovement* temp = kind_.buildimprovement_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.buildimprovement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::WorkerTaskImprovement& WorkerTaskKind::_internal_buildimprovement() const {
  return _internal_has_buildimprovement()
      ? *kind_.buildimprovement_
      : reinterpret_cast< ::WorkerTaskImprovement&>(::_WorkerTaskImprovement_default_instance_);
}
inline const ::WorkerTaskImprovement& WorkerTaskKind::buildimprovement() const {
  // @@protoc_insertion_point(field_get:WorkerTaskKind.buildImprovement)
  return _internal_buildimprovement();
}
inline ::WorkerTaskImprovement* WorkerTaskKind::unsafe_arena_release_buildimprovement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:WorkerTaskKind.buildImprovement)
  if (_internal_has_buildimprovement()) {
    clear_has_kind();
    ::WorkerTaskImprovement* temp = kind_.buildimprovement_;
    kind_.buildimprovement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerTaskKind::unsafe_arena_set_allocated_buildimprovement(::WorkerTaskImprovement* buildimprovement) {
  clear_kind();
  if (buildimprovement) {
    set_has_buildimprovement();
    kind_.buildimprovement_ = buildimprovement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerTaskKind.buildImprovement)
}
inline ::WorkerTaskImprovement* WorkerTaskKind::_internal_mutable_buildimprovement() {
  if (!_internal_has_buildimprovement()) {
    clear_kind();
    set_has_buildimprovement();
    kind_.buildimprovement_ = CreateMaybeMessage< ::WorkerTaskImprovement >(GetArenaForAllocation());
  }
  return kind_.buildimprovement_;
}
inline ::WorkerTaskImprovement* WorkerTaskKind::mutable_buildimprovement() {
  ::WorkerTaskImprovement* _msg = _internal_mutable_buildimprovement();
  // @@protoc_insertion_point(field_mutable:WorkerTaskKind.buildImprovement)
  return _msg;
}

inline bool WorkerTaskKind::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void WorkerTaskKind::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline WorkerTaskKind::KindCase WorkerTaskKind::kind_case() const {
  return WorkerTaskKind::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorkerTask

// string name = 1;
inline void WorkerTask::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& WorkerTask::name() const {
  // @@protoc_insertion_point(field_get:WorkerTask.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerTask::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WorkerTask.name)
}
inline std::string* WorkerTask::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:WorkerTask.name)
  return _s;
}
inline const std::string& WorkerTask::_internal_name() const {
  return name_.Get();
}
inline void WorkerTask::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WorkerTask::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WorkerTask::release_name() {
  // @@protoc_insertion_point(field_release:WorkerTask.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WorkerTask::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:WorkerTask.name)
}

// int32 turnsLeft = 2;
inline void WorkerTask::clear_turnsleft() {
  turnsleft_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerTask::_internal_turnsleft() const {
  return turnsleft_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerTask::turnsleft() const {
  // @@protoc_insertion_point(field_get:WorkerTask.turnsLeft)
  return _internal_turnsleft();
}
inline void WorkerTask::_internal_set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  turnsleft_ = value;
}
inline void WorkerTask::set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_turnsleft(value);
  // @@protoc_insertion_point(field_set:WorkerTask.turnsLeft)
}

// .WorkerTaskKind kind = 3;
inline bool WorkerTask::_internal_has_kind() const {
  return this != internal_default_instance() && kind_ != nullptr;
}
inline bool WorkerTask::has_kind() const {
  return _internal_has_kind();
}
inline void WorkerTask::clear_kind() {
  if (GetArenaForAllocation() == nullptr && kind_ != nullptr) {
    delete kind_;
  }
  kind_ = nullptr;
}
inline const ::WorkerTaskKind& WorkerTask::_internal_kind() const {
  const ::WorkerTaskKind* p = kind_;
  return p != nullptr ? *p : reinterpret_cast<const ::WorkerTaskKind&>(
      ::_WorkerTaskKind_default_instance_);
}
inline const ::WorkerTaskKind& WorkerTask::kind() const {
  // @@protoc_insertion_point(field_get:WorkerTask.kind)
  return _internal_kind();
}
inline void WorkerTask::unsafe_arena_set_allocated_kind(
    ::WorkerTaskKind* kind) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kind_);
  }
  kind_ = kind;
  if (kind) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerTask.kind)
}
inline ::WorkerTaskKind* WorkerTask::release_kind() {
  
  ::WorkerTaskKind* temp = kind_;
  kind_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::WorkerTaskKind* WorkerTask::unsafe_arena_release_kind() {
  // @@protoc_insertion_point(field_release:WorkerTask.kind)
  
  ::WorkerTaskKind* temp = kind_;
  kind_ = nullptr;
  return temp;
}
inline ::WorkerTaskKind* WorkerTask::_internal_mutable_kind() {
  
  if (kind_ == nullptr) {
    auto* p = CreateMaybeMessage<::WorkerTaskKind>(GetArenaForAllocation());
    kind_ = p;
  }
  return kind_;
}
inline ::WorkerTaskKind* WorkerTask::mutable_kind() {
  ::WorkerTaskKind* _msg = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:WorkerTask.kind)
  return _msg;
}
inline void WorkerTask::set_allocated_kind(::WorkerTaskKind* kind) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kind_;
  }
  if (kind) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::WorkerTaskKind>::GetOwningArena(kind);
    if (message_arena != submessage_arena) {
      kind = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kind, submessage_arena);
    }
    
  } else {
    
  }
  kind_ = kind;
  // @@protoc_insertion_point(field_set_allocated:WorkerTask.kind)
}

// -------------------------------------------------------------------

// WorkerCapability

// .WorkerTask currentTask = 1;
inline bool WorkerCapability::_internal_has_currenttask() const {
  return this != internal_default_instance() && currenttask_ != nullptr;
}
inline bool WorkerCapability::has_currenttask() const {
  return _internal_has_currenttask();
}
inline void WorkerCapability::clear_currenttask() {
  if (GetArenaForAllocation() == nullptr && currenttask_ != nullptr) {
    delete currenttask_;
  }
  currenttask_ = nullptr;
}
inline const ::WorkerTask& WorkerCapability::_internal_currenttask() const {
  const ::WorkerTask* p = currenttask_;
  return p != nullptr ? *p : reinterpret_cast<const ::WorkerTask&>(
      ::_WorkerTask_default_instance_);
}
inline const ::WorkerTask& WorkerCapability::currenttask() const {
  // @@protoc_insertion_point(field_get:WorkerCapability.currentTask)
  return _internal_currenttask();
}
inline void WorkerCapability::unsafe_arena_set_allocated_currenttask(
    ::WorkerTask* currenttask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currenttask_);
  }
  currenttask_ = currenttask;
  if (currenttask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerCapability.currentTask)
}
inline ::WorkerTask* WorkerCapability::release_currenttask() {
  
  ::WorkerTask* temp = currenttask_;
  currenttask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::WorkerTask* WorkerCapability::unsafe_arena_release_currenttask() {
  // @@protoc_insertion_point(field_release:WorkerCapability.currentTask)
  
  ::WorkerTask* temp = currenttask_;
  currenttask_ = nullptr;
  return temp;
}
inline ::WorkerTask* WorkerCapability::_internal_mutable_currenttask() {
  
  if (currenttask_ == nullptr) {
    auto* p = CreateMaybeMessage<::WorkerTask>(GetArenaForAllocation());
    currenttask_ = p;
  }
  return currenttask_;
}
inline ::WorkerTask* WorkerCapability::mutable_currenttask() {
  ::WorkerTask* _msg = _internal_mutable_currenttask();
  // @@protoc_insertion_point(field_mutable:WorkerCapability.currentTask)
  return _msg;
}
inline void WorkerCapability::set_allocated_currenttask(::WorkerTask* currenttask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete currenttask_;
  }
  if (currenttask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::WorkerTask>::GetOwningArena(currenttask);
    if (message_arena != submessage_arena) {
      currenttask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currenttask, submessage_arena);
    }
    
  } else {
    
  }
  currenttask_ = currenttask;
  // @@protoc_insertion_point(field_set_allocated:WorkerCapability.currentTask)
}

// repeated .WorkerTask possibleTasks = 2;
inline int WorkerCapability::_internal_possibletasks_size() const {
  return possibletasks_.size();
}
inline int WorkerCapability::possibletasks_size() const {
  return _internal_possibletasks_size();
}
inline void WorkerCapability::clear_possibletasks() {
  possibletasks_.Clear();
}
inline ::WorkerTask* WorkerCapability::mutable_possibletasks(int index) {
  // @@protoc_insertion_point(field_mutable:WorkerCapability.possibleTasks)
  return possibletasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >*
WorkerCapability::mutable_possibletasks() {
  // @@protoc_insertion_point(field_mutable_list:WorkerCapability.possibleTasks)
  return &possibletasks_;
}
inline const ::WorkerTask& WorkerCapability::_internal_possibletasks(int index) const {
  return possibletasks_.Get(index);
}
inline const ::WorkerTask& WorkerCapability::possibletasks(int index) const {
  // @@protoc_insertion_point(field_get:WorkerCapability.possibleTasks)
  return _internal_possibletasks(index);
}
inline ::WorkerTask* WorkerCapability::_internal_add_possibletasks() {
  return possibletasks_.Add();
}
inline ::WorkerTask* WorkerCapability::add_possibletasks() {
  ::WorkerTask* _add = _internal_add_possibletasks();
  // @@protoc_insertion_point(field_add:WorkerCapability.possibleTasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >&
WorkerCapability::possibletasks() const {
  // @@protoc_insertion_point(field_list:WorkerCapability.possibleTasks)
  return possibletasks_;
}

// -------------------------------------------------------------------

// CarryUnitsCapability

// repeated int32 carryingUnitIDs = 1;
inline int CarryUnitsCapability::_internal_carryingunitids_size() const {
  return carryingunitids_.size();
}
inline int CarryUnitsCapability::carryingunitids_size() const {
  return _internal_carryingunitids_size();
}
inline void CarryUnitsCapability::clear_carryingunitids() {
  carryingunitids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CarryUnitsCapability::_internal_carryingunitids(int index) const {
  return carryingunitids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CarryUnitsCapability::carryingunitids(int index) const {
  // @@protoc_insertion_point(field_get:CarryUnitsCapability.carryingUnitIDs)
  return _internal_carryingunitids(index);
}
inline void CarryUnitsCapability::set_carryingunitids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  carryingunitids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CarryUnitsCapability.carryingUnitIDs)
}
inline void CarryUnitsCapability::_internal_add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  carryingunitids_.Add(value);
}
inline void CarryUnitsCapability::add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_carryingunitids(value);
  // @@protoc_insertion_point(field_add:CarryUnitsCapability.carryingUnitIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CarryUnitsCapability::_internal_carryingunitids() const {
  return carryingunitids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CarryUnitsCapability::carryingunitids() const {
  // @@protoc_insertion_point(field_list:CarryUnitsCapability.carryingUnitIDs)
  return _internal_carryingunitids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CarryUnitsCapability::_internal_mutable_carryingunitids() {
  return &carryingunitids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CarryUnitsCapability::mutable_carryingunitids() {
  // @@protoc_insertion_point(field_mutable_list:CarryUnitsCapability.carryingUnitIDs)
  return _internal_mutable_carryingunitids();
}

// -------------------------------------------------------------------

// Capability

// .FoundCityCapability foundCity = 1;
inline bool Capability::_internal_has_foundcity() const {
  return cap_case() == kFoundCity;
}
inline bool Capability::has_foundcity() const {
  return _internal_has_foundcity();
}
inline void Capability::set_has_foundcity() {
  _oneof_case_[0] = kFoundCity;
}
inline void Capability::clear_foundcity() {
  if (_internal_has_foundcity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cap_.foundcity_;
    }
    clear_has_cap();
  }
}
inline ::FoundCityCapability* Capability::release_foundcity() {
  // @@protoc_insertion_point(field_release:Capability.foundCity)
  if (_internal_has_foundcity()) {
    clear_has_cap();
      ::FoundCityCapability* temp = cap_.foundcity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cap_.foundcity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FoundCityCapability& Capability::_internal_foundcity() const {
  return _internal_has_foundcity()
      ? *cap_.foundcity_
      : reinterpret_cast< ::FoundCityCapability&>(::_FoundCityCapability_default_instance_);
}
inline const ::FoundCityCapability& Capability::foundcity() const {
  // @@protoc_insertion_point(field_get:Capability.foundCity)
  return _internal_foundcity();
}
inline ::FoundCityCapability* Capability::unsafe_arena_release_foundcity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Capability.foundCity)
  if (_internal_has_foundcity()) {
    clear_has_cap();
    ::FoundCityCapability* temp = cap_.foundcity_;
    cap_.foundcity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Capability::unsafe_arena_set_allocated_foundcity(::FoundCityCapability* foundcity) {
  clear_cap();
  if (foundcity) {
    set_has_foundcity();
    cap_.foundcity_ = foundcity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Capability.foundCity)
}
inline ::FoundCityCapability* Capability::_internal_mutable_foundcity() {
  if (!_internal_has_foundcity()) {
    clear_cap();
    set_has_foundcity();
    cap_.foundcity_ = CreateMaybeMessage< ::FoundCityCapability >(GetArenaForAllocation());
  }
  return cap_.foundcity_;
}
inline ::FoundCityCapability* Capability::mutable_foundcity() {
  ::FoundCityCapability* _msg = _internal_mutable_foundcity();
  // @@protoc_insertion_point(field_mutable:Capability.foundCity)
  return _msg;
}

// .WorkerCapability worker = 2;
inline bool Capability::_internal_has_worker() const {
  return cap_case() == kWorker;
}
inline bool Capability::has_worker() const {
  return _internal_has_worker();
}
inline void Capability::set_has_worker() {
  _oneof_case_[0] = kWorker;
}
inline void Capability::clear_worker() {
  if (_internal_has_worker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cap_.worker_;
    }
    clear_has_cap();
  }
}
inline ::WorkerCapability* Capability::release_worker() {
  // @@protoc_insertion_point(field_release:Capability.worker)
  if (_internal_has_worker()) {
    clear_has_cap();
      ::WorkerCapability* temp = cap_.worker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cap_.worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::WorkerCapability& Capability::_internal_worker() const {
  return _internal_has_worker()
      ? *cap_.worker_
      : reinterpret_cast< ::WorkerCapability&>(::_WorkerCapability_default_instance_);
}
inline const ::WorkerCapability& Capability::worker() const {
  // @@protoc_insertion_point(field_get:Capability.worker)
  return _internal_worker();
}
inline ::WorkerCapability* Capability::unsafe_arena_release_worker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Capability.worker)
  if (_internal_has_worker()) {
    clear_has_cap();
    ::WorkerCapability* temp = cap_.worker_;
    cap_.worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Capability::unsafe_arena_set_allocated_worker(::WorkerCapability* worker) {
  clear_cap();
  if (worker) {
    set_has_worker();
    cap_.worker_ = worker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Capability.worker)
}
inline ::WorkerCapability* Capability::_internal_mutable_worker() {
  if (!_internal_has_worker()) {
    clear_cap();
    set_has_worker();
    cap_.worker_ = CreateMaybeMessage< ::WorkerCapability >(GetArenaForAllocation());
  }
  return cap_.worker_;
}
inline ::WorkerCapability* Capability::mutable_worker() {
  ::WorkerCapability* _msg = _internal_mutable_worker();
  // @@protoc_insertion_point(field_mutable:Capability.worker)
  return _msg;
}

// .CarryUnitsCapability carryUnits = 3;
inline bool Capability::_internal_has_carryunits() const {
  return cap_case() == kCarryUnits;
}
inline bool Capability::has_carryunits() const {
  return _internal_has_carryunits();
}
inline void Capability::set_has_carryunits() {
  _oneof_case_[0] = kCarryUnits;
}
inline void Capability::clear_carryunits() {
  if (_internal_has_carryunits()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cap_.carryunits_;
    }
    clear_has_cap();
  }
}
inline ::CarryUnitsCapability* Capability::release_carryunits() {
  // @@protoc_insertion_point(field_release:Capability.carryUnits)
  if (_internal_has_carryunits()) {
    clear_has_cap();
      ::CarryUnitsCapability* temp = cap_.carryunits_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cap_.carryunits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CarryUnitsCapability& Capability::_internal_carryunits() const {
  return _internal_has_carryunits()
      ? *cap_.carryunits_
      : reinterpret_cast< ::CarryUnitsCapability&>(::_CarryUnitsCapability_default_instance_);
}
inline const ::CarryUnitsCapability& Capability::carryunits() const {
  // @@protoc_insertion_point(field_get:Capability.carryUnits)
  return _internal_carryunits();
}
inline ::CarryUnitsCapability* Capability::unsafe_arena_release_carryunits() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Capability.carryUnits)
  if (_internal_has_carryunits()) {
    clear_has_cap();
    ::CarryUnitsCapability* temp = cap_.carryunits_;
    cap_.carryunits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Capability::unsafe_arena_set_allocated_carryunits(::CarryUnitsCapability* carryunits) {
  clear_cap();
  if (carryunits) {
    set_has_carryunits();
    cap_.carryunits_ = carryunits;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Capability.carryUnits)
}
inline ::CarryUnitsCapability* Capability::_internal_mutable_carryunits() {
  if (!_internal_has_carryunits()) {
    clear_cap();
    set_has_carryunits();
    cap_.carryunits_ = CreateMaybeMessage< ::CarryUnitsCapability >(GetArenaForAllocation());
  }
  return cap_.carryunits_;
}
inline ::CarryUnitsCapability* Capability::mutable_carryunits() {
  ::CarryUnitsCapability* _msg = _internal_mutable_carryunits();
  // @@protoc_insertion_point(field_mutable:Capability.carryUnits)
  return _msg;
}

inline bool Capability::has_cap() const {
  return cap_case() != CAP_NOT_SET;
}
inline void Capability::clear_has_cap() {
  _oneof_case_[0] = CAP_NOT_SET;
}
inline Capability::CapCase Capability::cap_case() const {
  return Capability::CapCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateUnit

// .Pos pos = 1;
inline bool UpdateUnit::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool UpdateUnit::has_pos() const {
  return _internal_has_pos();
}
inline void UpdateUnit::clear_pos() {
  if (GetArenaForAllocation() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::Pos& UpdateUnit::_internal_pos() const {
  const ::Pos* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Pos&>(
      ::_Pos_default_instance_);
}
inline const ::Pos& UpdateUnit::pos() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.pos)
  return _internal_pos();
}
inline void UpdateUnit::unsafe_arena_set_allocated_pos(
    ::Pos* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateUnit.pos)
}
inline ::Pos* UpdateUnit::release_pos() {
  
  ::Pos* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Pos* UpdateUnit::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:UpdateUnit.pos)
  
  ::Pos* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::Pos* UpdateUnit::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::Pos* UpdateUnit::mutable_pos() {
  ::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:UpdateUnit.pos)
  return _msg;
}
inline void UpdateUnit::set_allocated_pos(::Pos* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Pos>::GetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:UpdateUnit.pos)
}

// string kindID = 2;
inline void UpdateUnit::clear_kindid() {
  kindid_.ClearToEmpty();
}
inline const std::string& UpdateUnit::kindid() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.kindID)
  return _internal_kindid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUnit::set_kindid(ArgT0&& arg0, ArgT... args) {
 
 kindid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UpdateUnit.kindID)
}
inline std::string* UpdateUnit::mutable_kindid() {
  std::string* _s = _internal_mutable_kindid();
  // @@protoc_insertion_point(field_mutable:UpdateUnit.kindID)
  return _s;
}
inline const std::string& UpdateUnit::_internal_kindid() const {
  return kindid_.Get();
}
inline void UpdateUnit::_internal_set_kindid(const std::string& value) {
  
  kindid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUnit::_internal_mutable_kindid() {
  
  return kindid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUnit::release_kindid() {
  // @@protoc_insertion_point(field_release:UpdateUnit.kindID)
  return kindid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUnit::set_allocated_kindid(std::string* kindid) {
  if (kindid != nullptr) {
    
  } else {
    
  }
  kindid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kindid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:UpdateUnit.kindID)
}

// int32 ownerID = 3;
inline void UpdateUnit::clear_ownerid() {
  ownerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateUnit::_internal_ownerid() const {
  return ownerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateUnit::ownerid() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.ownerID)
  return _internal_ownerid();
}
inline void UpdateUnit::_internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ownerid_ = value;
}
inline void UpdateUnit::set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.ownerID)
}

// double health = 4;
inline void UpdateUnit::clear_health() {
  health_ = 0;
}
inline double UpdateUnit::_internal_health() const {
  return health_;
}
inline double UpdateUnit::health() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.health)
  return _internal_health();
}
inline void UpdateUnit::_internal_set_health(double value) {
  
  health_ = value;
}
inline void UpdateUnit::set_health(double value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.health)
}

// double movementLeft = 5;
inline void UpdateUnit::clear_movementleft() {
  movementleft_ = 0;
}
inline double UpdateUnit::_internal_movementleft() const {
  return movementleft_;
}
inline double UpdateUnit::movementleft() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.movementLeft)
  return _internal_movementleft();
}
inline void UpdateUnit::_internal_set_movementleft(double value) {
  
  movementleft_ = value;
}
inline void UpdateUnit::set_movementleft(double value) {
  _internal_set_movementleft(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.movementLeft)
}

// .Path followingPath = 6;
inline bool UpdateUnit::_internal_has_followingpath() const {
  return this != internal_default_instance() && followingpath_ != nullptr;
}
inline bool UpdateUnit::has_followingpath() const {
  return _internal_has_followingpath();
}
inline void UpdateUnit::clear_followingpath() {
  if (GetArenaForAllocation() == nullptr && followingpath_ != nullptr) {
    delete followingpath_;
  }
  followingpath_ = nullptr;
}
inline const ::Path& UpdateUnit::_internal_followingpath() const {
  const ::Path* p = followingpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Path&>(
      ::_Path_default_instance_);
}
inline const ::Path& UpdateUnit::followingpath() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.followingPath)
  return _internal_followingpath();
}
inline void UpdateUnit::unsafe_arena_set_allocated_followingpath(
    ::Path* followingpath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(followingpath_);
  }
  followingpath_ = followingpath;
  if (followingpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateUnit.followingPath)
}
inline ::Path* UpdateUnit::release_followingpath() {
  
  ::Path* temp = followingpath_;
  followingpath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Path* UpdateUnit::unsafe_arena_release_followingpath() {
  // @@protoc_insertion_point(field_release:UpdateUnit.followingPath)
  
  ::Path* temp = followingpath_;
  followingpath_ = nullptr;
  return temp;
}
inline ::Path* UpdateUnit::_internal_mutable_followingpath() {
  
  if (followingpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Path>(GetArenaForAllocation());
    followingpath_ = p;
  }
  return followingpath_;
}
inline ::Path* UpdateUnit::mutable_followingpath() {
  ::Path* _msg = _internal_mutable_followingpath();
  // @@protoc_insertion_point(field_mutable:UpdateUnit.followingPath)
  return _msg;
}
inline void UpdateUnit::set_allocated_followingpath(::Path* followingpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete followingpath_;
  }
  if (followingpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Path>::GetOwningArena(followingpath);
    if (message_arena != submessage_arena) {
      followingpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, followingpath, submessage_arena);
    }
    
  } else {
    
  }
  followingpath_ = followingpath;
  // @@protoc_insertion_point(field_set_allocated:UpdateUnit.followingPath)
}

// repeated .Capability capabilities = 7;
inline int UpdateUnit::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int UpdateUnit::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void UpdateUnit::clear_capabilities() {
  capabilities_.Clear();
}
inline ::Capability* UpdateUnit::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateUnit.capabilities)
  return capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >*
UpdateUnit::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:UpdateUnit.capabilities)
  return &capabilities_;
}
inline const ::Capability& UpdateUnit::_internal_capabilities(int index) const {
  return capabilities_.Get(index);
}
inline const ::Capability& UpdateUnit::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:UpdateUnit.capabilities)
  return _internal_capabilities(index);
}
inline ::Capability* UpdateUnit::_internal_add_capabilities() {
  return capabilities_.Add();
}
inline ::Capability* UpdateUnit::add_capabilities() {
  ::Capability* _add = _internal_add_capabilities();
  // @@protoc_insertion_point(field_add:UpdateUnit.capabilities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >&
UpdateUnit::capabilities() const {
  // @@protoc_insertion_point(field_list:UpdateUnit.capabilities)
  return capabilities_;
}

// int32 id = 8;
inline void UpdateUnit::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateUnit::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateUnit::id() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.id)
  return _internal_id();
}
inline void UpdateUnit::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void UpdateUnit::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.id)
}

// double strength = 9;
inline void UpdateUnit::clear_strength() {
  strength_ = 0;
}
inline double UpdateUnit::_internal_strength() const {
  return strength_;
}
inline double UpdateUnit::strength() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.strength)
  return _internal_strength();
}
inline void UpdateUnit::_internal_set_strength(double value) {
  
  strength_ = value;
}
inline void UpdateUnit::set_strength(double value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.strength)
}

// -------------------------------------------------------------------

// ResearchingTech

// string techID = 1;
inline void ResearchingTech::clear_techid() {
  techid_.ClearToEmpty();
}
inline const std::string& ResearchingTech::techid() const {
  // @@protoc_insertion_point(field_get:ResearchingTech.techID)
  return _internal_techid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResearchingTech::set_techid(ArgT0&& arg0, ArgT... args) {
 
 techid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResearchingTech.techID)
}
inline std::string* ResearchingTech::mutable_techid() {
  std::string* _s = _internal_mutable_techid();
  // @@protoc_insertion_point(field_mutable:ResearchingTech.techID)
  return _s;
}
inline const std::string& ResearchingTech::_internal_techid() const {
  return techid_.Get();
}
inline void ResearchingTech::_internal_set_techid(const std::string& value) {
  
  techid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResearchingTech::_internal_mutable_techid() {
  
  return techid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResearchingTech::release_techid() {
  // @@protoc_insertion_point(field_release:ResearchingTech.techID)
  return techid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResearchingTech::set_allocated_techid(std::string* techid) {
  if (techid != nullptr) {
    
  } else {
    
  }
  techid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), techid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ResearchingTech.techID)
}

// int32 progress = 2;
inline void ResearchingTech::clear_progress() {
  progress_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResearchingTech::_internal_progress() const {
  return progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResearchingTech::progress() const {
  // @@protoc_insertion_point(field_get:ResearchingTech.progress)
  return _internal_progress();
}
inline void ResearchingTech::_internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  progress_ = value;
}
inline void ResearchingTech::set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:ResearchingTech.progress)
}

// -------------------------------------------------------------------

// UpdatePlayer

// int32 id = 1;
inline void UpdatePlayer::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::id() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.id)
  return _internal_id();
}
inline void UpdatePlayer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void UpdatePlayer::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.id)
}

// string username = 2;
inline void UpdatePlayer::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UpdatePlayer::username() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePlayer::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UpdatePlayer.username)
}
inline std::string* UpdatePlayer::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.username)
  return _s;
}
inline const std::string& UpdatePlayer::_internal_username() const {
  return username_.Get();
}
inline void UpdatePlayer::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePlayer::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePlayer::release_username() {
  // @@protoc_insertion_point(field_release:UpdatePlayer.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePlayer::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:UpdatePlayer.username)
}

// int32 baseRevenue = 3;
inline void UpdatePlayer::clear_baserevenue() {
  baserevenue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_baserevenue() const {
  return baserevenue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::baserevenue() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.baseRevenue)
  return _internal_baserevenue();
}
inline void UpdatePlayer::_internal_set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  baserevenue_ = value;
}
inline void UpdatePlayer::set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_baserevenue(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.baseRevenue)
}

// int32 beakerRevenue = 4;
inline void UpdatePlayer::clear_beakerrevenue() {
  beakerrevenue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_beakerrevenue() const {
  return beakerrevenue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::beakerrevenue() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.beakerRevenue)
  return _internal_beakerrevenue();
}
inline void UpdatePlayer::_internal_set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  beakerrevenue_ = value;
}
inline void UpdatePlayer::set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_beakerrevenue(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.beakerRevenue)
}

// int32 goldRevenue = 5;
inline void UpdatePlayer::clear_goldrevenue() {
  goldrevenue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_goldrevenue() const {
  return goldrevenue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::goldrevenue() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.goldRevenue)
  return _internal_goldrevenue();
}
inline void UpdatePlayer::_internal_set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  goldrevenue_ = value;
}
inline void UpdatePlayer::set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_goldrevenue(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.goldRevenue)
}

// int32 expenses = 6;
inline void UpdatePlayer::clear_expenses() {
  expenses_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_expenses() const {
  return expenses_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::expenses() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.expenses)
  return _internal_expenses();
}
inline void UpdatePlayer::_internal_set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  expenses_ = value;
}
inline void UpdatePlayer::set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_expenses(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.expenses)
}

// int32 netGold = 7;
inline void UpdatePlayer::clear_netgold() {
  netgold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_netgold() const {
  return netgold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::netgold() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.netGold)
  return _internal_netgold();
}
inline void UpdatePlayer::_internal_set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  netgold_ = value;
}
inline void UpdatePlayer::set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_netgold(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.netGold)
}

// int32 gold = 8;
inline void UpdatePlayer::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::gold() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.gold)
  return _internal_gold();
}
inline void UpdatePlayer::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void UpdatePlayer::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.gold)
}

// .ResearchingTech researchingTech = 9;
inline bool UpdatePlayer::_internal_has_researchingtech() const {
  return this != internal_default_instance() && researchingtech_ != nullptr;
}
inline bool UpdatePlayer::has_researchingtech() const {
  return _internal_has_researchingtech();
}
inline void UpdatePlayer::clear_researchingtech() {
  if (GetArenaForAllocation() == nullptr && researchingtech_ != nullptr) {
    delete researchingtech_;
  }
  researchingtech_ = nullptr;
}
inline const ::ResearchingTech& UpdatePlayer::_internal_researchingtech() const {
  const ::ResearchingTech* p = researchingtech_;
  return p != nullptr ? *p : reinterpret_cast<const ::ResearchingTech&>(
      ::_ResearchingTech_default_instance_);
}
inline const ::ResearchingTech& UpdatePlayer::researchingtech() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.researchingTech)
  return _internal_researchingtech();
}
inline void UpdatePlayer::unsafe_arena_set_allocated_researchingtech(
    ::ResearchingTech* researchingtech) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(researchingtech_);
  }
  researchingtech_ = researchingtech;
  if (researchingtech) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdatePlayer.researchingTech)
}
inline ::ResearchingTech* UpdatePlayer::release_researchingtech() {
  
  ::ResearchingTech* temp = researchingtech_;
  researchingtech_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ResearchingTech* UpdatePlayer::unsafe_arena_release_researchingtech() {
  // @@protoc_insertion_point(field_release:UpdatePlayer.researchingTech)
  
  ::ResearchingTech* temp = researchingtech_;
  researchingtech_ = nullptr;
  return temp;
}
inline ::ResearchingTech* UpdatePlayer::_internal_mutable_researchingtech() {
  
  if (researchingtech_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResearchingTech>(GetArenaForAllocation());
    researchingtech_ = p;
  }
  return researchingtech_;
}
inline ::ResearchingTech* UpdatePlayer::mutable_researchingtech() {
  ::ResearchingTech* _msg = _internal_mutable_researchingtech();
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.researchingTech)
  return _msg;
}
inline void UpdatePlayer::set_allocated_researchingtech(::ResearchingTech* researchingtech) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete researchingtech_;
  }
  if (researchingtech) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ResearchingTech>::GetOwningArena(researchingtech);
    if (message_arena != submessage_arena) {
      researchingtech = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, researchingtech, submessage_arena);
    }
    
  } else {
    
  }
  researchingtech_ = researchingtech;
  // @@protoc_insertion_point(field_set_allocated:UpdatePlayer.researchingTech)
}

// int32 capitalCityID = 10;
inline void UpdatePlayer::clear_capitalcityid() {
  capitalcityid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_capitalcityid() const {
  return capitalcityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::capitalcityid() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.capitalCityID)
  return _internal_capitalcityid();
}
inline void UpdatePlayer::_internal_set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  capitalcityid_ = value;
}
inline void UpdatePlayer::set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_capitalcityid(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.capitalCityID)
}

// repeated string unlockedTechIDs = 11;
inline int UpdatePlayer::_internal_unlockedtechids_size() const {
  return unlockedtechids_.size();
}
inline int UpdatePlayer::unlockedtechids_size() const {
  return _internal_unlockedtechids_size();
}
inline void UpdatePlayer::clear_unlockedtechids() {
  unlockedtechids_.Clear();
}
inline std::string* UpdatePlayer::add_unlockedtechids() {
  std::string* _s = _internal_add_unlockedtechids();
  // @@protoc_insertion_point(field_add_mutable:UpdatePlayer.unlockedTechIDs)
  return _s;
}
inline const std::string& UpdatePlayer::_internal_unlockedtechids(int index) const {
  return unlockedtechids_.Get(index);
}
inline const std::string& UpdatePlayer::unlockedtechids(int index) const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.unlockedTechIDs)
  return _internal_unlockedtechids(index);
}
inline std::string* UpdatePlayer::mutable_unlockedtechids(int index) {
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.unlockedTechIDs)
  return unlockedtechids_.Mutable(index);
}
inline void UpdatePlayer::set_unlockedtechids(int index, const std::string& value) {
  unlockedtechids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::set_unlockedtechids(int index, std::string&& value) {
  unlockedtechids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::set_unlockedtechids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unlockedtechids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::set_unlockedtechids(int index, const char* value, size_t size) {
  unlockedtechids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdatePlayer.unlockedTechIDs)
}
inline std::string* UpdatePlayer::_internal_add_unlockedtechids() {
  return unlockedtechids_.Add();
}
inline void UpdatePlayer::add_unlockedtechids(const std::string& value) {
  unlockedtechids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::add_unlockedtechids(std::string&& value) {
  unlockedtechids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::add_unlockedtechids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unlockedtechids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::add_unlockedtechids(const char* value, size_t size) {
  unlockedtechids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:UpdatePlayer.unlockedTechIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdatePlayer::unlockedtechids() const {
  // @@protoc_insertion_point(field_list:UpdatePlayer.unlockedTechIDs)
  return unlockedtechids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdatePlayer::mutable_unlockedtechids() {
  // @@protoc_insertion_point(field_mutable_list:UpdatePlayer.unlockedTechIDs)
  return &unlockedtechids_;
}

// repeated string possibleResearches = 12;
inline int UpdatePlayer::_internal_possibleresearches_size() const {
  return possibleresearches_.size();
}
inline int UpdatePlayer::possibleresearches_size() const {
  return _internal_possibleresearches_size();
}
inline void UpdatePlayer::clear_possibleresearches() {
  possibleresearches_.Clear();
}
inline std::string* UpdatePlayer::add_possibleresearches() {
  std::string* _s = _internal_add_possibleresearches();
  // @@protoc_insertion_point(field_add_mutable:UpdatePlayer.possibleResearches)
  return _s;
}
inline const std::string& UpdatePlayer::_internal_possibleresearches(int index) const {
  return possibleresearches_.Get(index);
}
inline const std::string& UpdatePlayer::possibleresearches(int index) const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.possibleResearches)
  return _internal_possibleresearches(index);
}
inline std::string* UpdatePlayer::mutable_possibleresearches(int index) {
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.possibleResearches)
  return possibleresearches_.Mutable(index);
}
inline void UpdatePlayer::set_possibleresearches(int index, const std::string& value) {
  possibleresearches_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::set_possibleresearches(int index, std::string&& value) {
  possibleresearches_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::set_possibleresearches(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  possibleresearches_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::set_possibleresearches(int index, const char* value, size_t size) {
  possibleresearches_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdatePlayer.possibleResearches)
}
inline std::string* UpdatePlayer::_internal_add_possibleresearches() {
  return possibleresearches_.Add();
}
inline void UpdatePlayer::add_possibleresearches(const std::string& value) {
  possibleresearches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::add_possibleresearches(std::string&& value) {
  possibleresearches_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::add_possibleresearches(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  possibleresearches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::add_possibleresearches(const char* value, size_t size) {
  possibleresearches_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:UpdatePlayer.possibleResearches)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdatePlayer::possibleresearches() const {
  // @@protoc_insertion_point(field_list:UpdatePlayer.possibleResearches)
  return possibleresearches_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdatePlayer::mutable_possibleresearches() {
  // @@protoc_insertion_point(field_mutable_list:UpdatePlayer.possibleResearches)
  return &possibleresearches_;
}

// -------------------------------------------------------------------

// PathComputed

// int32 pathID = 1;
inline void PathComputed::clear_pathid() {
  pathid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PathComputed::_internal_pathid() const {
  return pathid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PathComputed::pathid() const {
  // @@protoc_insertion_point(field_get:PathComputed.pathID)
  return _internal_pathid();
}
inline void PathComputed::_internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pathid_ = value;
}
inline void PathComputed::set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pathid(value);
  // @@protoc_insertion_point(field_set:PathComputed.pathID)
}

// .Path path = 2;
inline bool PathComputed::_internal_has_path() const {
  return this != internal_default_instance() && path_ != nullptr;
}
inline bool PathComputed::has_path() const {
  return _internal_has_path();
}
inline void PathComputed::clear_path() {
  if (GetArenaForAllocation() == nullptr && path_ != nullptr) {
    delete path_;
  }
  path_ = nullptr;
}
inline const ::Path& PathComputed::_internal_path() const {
  const ::Path* p = path_;
  return p != nullptr ? *p : reinterpret_cast<const ::Path&>(
      ::_Path_default_instance_);
}
inline const ::Path& PathComputed::path() const {
  // @@protoc_insertion_point(field_get:PathComputed.path)
  return _internal_path();
}
inline void PathComputed::unsafe_arena_set_allocated_path(
    ::Path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathComputed.path)
}
inline ::Path* PathComputed::release_path() {
  
  ::Path* temp = path_;
  path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Path* PathComputed::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:PathComputed.path)
  
  ::Path* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::Path* PathComputed::_internal_mutable_path() {
  
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::Path>(GetArenaForAllocation());
    path_ = p;
  }
  return path_;
}
inline ::Path* PathComputed::mutable_path() {
  ::Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:PathComputed.path)
  return _msg;
}
inline void PathComputed::set_allocated_path(::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Path>::GetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:PathComputed.path)
}

// -------------------------------------------------------------------

// MoveUnit

// int32 unitID = 1;
inline void MoveUnit::clear_unitid() {
  unitid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MoveUnit::_internal_unitid() const {
  return unitid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MoveUnit::unitid() const {
  // @@protoc_insertion_point(field_get:MoveUnit.unitID)
  return _internal_unitid();
}
inline void MoveUnit::_internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  unitid_ = value;
}
inline void MoveUnit::set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_unitid(value);
  // @@protoc_insertion_point(field_set:MoveUnit.unitID)
}

// .Pos newPos = 2;
inline bool MoveUnit::_internal_has_newpos() const {
  return this != internal_default_instance() && newpos_ != nullptr;
}
inline bool MoveUnit::has_newpos() const {
  return _internal_has_newpos();
}
inline void MoveUnit::clear_newpos() {
  if (GetArenaForAllocation() == nullptr && newpos_ != nullptr) {
    delete newpos_;
  }
  newpos_ = nullptr;
}
inline const ::Pos& MoveUnit::_internal_newpos() const {
  const ::Pos* p = newpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Pos&>(
      ::_Pos_default_instance_);
}
inline const ::Pos& MoveUnit::newpos() const {
  // @@protoc_insertion_point(field_get:MoveUnit.newPos)
  return _internal_newpos();
}
inline void MoveUnit::unsafe_arena_set_allocated_newpos(
    ::Pos* newpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newpos_);
  }
  newpos_ = newpos;
  if (newpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MoveUnit.newPos)
}
inline ::Pos* MoveUnit::release_newpos() {
  
  ::Pos* temp = newpos_;
  newpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Pos* MoveUnit::unsafe_arena_release_newpos() {
  // @@protoc_insertion_point(field_release:MoveUnit.newPos)
  
  ::Pos* temp = newpos_;
  newpos_ = nullptr;
  return temp;
}
inline ::Pos* MoveUnit::_internal_mutable_newpos() {
  
  if (newpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArenaForAllocation());
    newpos_ = p;
  }
  return newpos_;
}
inline ::Pos* MoveUnit::mutable_newpos() {
  ::Pos* _msg = _internal_mutable_newpos();
  // @@protoc_insertion_point(field_mutable:MoveUnit.newPos)
  return _msg;
}
inline void MoveUnit::set_allocated_newpos(::Pos* newpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete newpos_;
  }
  if (newpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Pos>::GetOwningArena(newpos);
    if (message_arena != submessage_arena) {
      newpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newpos, submessage_arena);
    }
    
  } else {
    
  }
  newpos_ = newpos;
  // @@protoc_insertion_point(field_set_allocated:MoveUnit.newPos)
}

// -------------------------------------------------------------------

// SetCityBuildTask

// int32 cityID = 1;
inline void SetCityBuildTask::clear_cityid() {
  cityid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetCityBuildTask::_internal_cityid() const {
  return cityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetCityBuildTask::cityid() const {
  // @@protoc_insertion_point(field_get:SetCityBuildTask.cityID)
  return _internal_cityid();
}
inline void SetCityBuildTask::_internal_set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cityid_ = value;
}
inline void SetCityBuildTask::set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cityid(value);
  // @@protoc_insertion_point(field_set:SetCityBuildTask.cityID)
}

// .BuildTaskKind task = 2;
inline bool SetCityBuildTask::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool SetCityBuildTask::has_task() const {
  return _internal_has_task();
}
inline void SetCityBuildTask::clear_task() {
  if (GetArenaForAllocation() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::BuildTaskKind& SetCityBuildTask::_internal_task() const {
  const ::BuildTaskKind* p = task_;
  return p != nullptr ? *p : reinterpret_cast<const ::BuildTaskKind&>(
      ::_BuildTaskKind_default_instance_);
}
inline const ::BuildTaskKind& SetCityBuildTask::task() const {
  // @@protoc_insertion_point(field_get:SetCityBuildTask.task)
  return _internal_task();
}
inline void SetCityBuildTask::unsafe_arena_set_allocated_task(
    ::BuildTaskKind* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SetCityBuildTask.task)
}
inline ::BuildTaskKind* SetCityBuildTask::release_task() {
  
  ::BuildTaskKind* temp = task_;
  task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BuildTaskKind* SetCityBuildTask::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:SetCityBuildTask.task)
  
  ::BuildTaskKind* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::BuildTaskKind* SetCityBuildTask::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::BuildTaskKind>(GetArenaForAllocation());
    task_ = p;
  }
  return task_;
}
inline ::BuildTaskKind* SetCityBuildTask::mutable_task() {
  ::BuildTaskKind* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:SetCityBuildTask.task)
  return _msg;
}
inline void SetCityBuildTask::set_allocated_task(::BuildTaskKind* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::BuildTaskKind>::GetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:SetCityBuildTask.task)
}

// -------------------------------------------------------------------

// SetWorkerTask

// int32 workerID = 1;
inline void SetWorkerTask::clear_workerid() {
  workerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetWorkerTask::_internal_workerid() const {
  return workerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetWorkerTask::workerid() const {
  // @@protoc_insertion_point(field_get:SetWorkerTask.workerID)
  return _internal_workerid();
}
inline void SetWorkerTask::_internal_set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  workerid_ = value;
}
inline void SetWorkerTask::set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_workerid(value);
  // @@protoc_insertion_point(field_set:SetWorkerTask.workerID)
}

// .WorkerTask task = 2;
inline bool SetWorkerTask::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool SetWorkerTask::has_task() const {
  return _internal_has_task();
}
inline void SetWorkerTask::clear_task() {
  if (GetArenaForAllocation() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::WorkerTask& SetWorkerTask::_internal_task() const {
  const ::WorkerTask* p = task_;
  return p != nullptr ? *p : reinterpret_cast<const ::WorkerTask&>(
      ::_WorkerTask_default_instance_);
}
inline const ::WorkerTask& SetWorkerTask::task() const {
  // @@protoc_insertion_point(field_get:SetWorkerTask.task)
  return _internal_task();
}
inline void SetWorkerTask::unsafe_arena_set_allocated_task(
    ::WorkerTask* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SetWorkerTask.task)
}
inline ::WorkerTask* SetWorkerTask::release_task() {
  
  ::WorkerTask* temp = task_;
  task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::WorkerTask* SetWorkerTask::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:SetWorkerTask.task)
  
  ::WorkerTask* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::WorkerTask* SetWorkerTask::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::WorkerTask>(GetArenaForAllocation());
    task_ = p;
  }
  return task_;
}
inline ::WorkerTask* SetWorkerTask::mutable_task() {
  ::WorkerTask* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:SetWorkerTask.task)
  return _msg;
}
inline void SetWorkerTask::set_allocated_task(::WorkerTask* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::WorkerTask>::GetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:SetWorkerTask.task)
}

// -------------------------------------------------------------------

// ComputePath

// int32 unitID = 1;
inline void ComputePath::clear_unitid() {
  unitid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::_internal_unitid() const {
  return unitid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::unitid() const {
  // @@protoc_insertion_point(field_get:ComputePath.unitID)
  return _internal_unitid();
}
inline void ComputePath::_internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  unitid_ = value;
}
inline void ComputePath::set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_unitid(value);
  // @@protoc_insertion_point(field_set:ComputePath.unitID)
}

// .Pos from = 2;
inline bool ComputePath::_internal_has_from() const {
  return this != internal_default_instance() && from_ != nullptr;
}
inline bool ComputePath::has_from() const {
  return _internal_has_from();
}
inline void ComputePath::clear_from() {
  if (GetArenaForAllocation() == nullptr && from_ != nullptr) {
    delete from_;
  }
  from_ = nullptr;
}
inline const ::Pos& ComputePath::_internal_from() const {
  const ::Pos* p = from_;
  return p != nullptr ? *p : reinterpret_cast<const ::Pos&>(
      ::_Pos_default_instance_);
}
inline const ::Pos& ComputePath::from() const {
  // @@protoc_insertion_point(field_get:ComputePath.from)
  return _internal_from();
}
inline void ComputePath::unsafe_arena_set_allocated_from(
    ::Pos* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_);
  }
  from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ComputePath.from)
}
inline ::Pos* ComputePath::release_from() {
  
  ::Pos* temp = from_;
  from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Pos* ComputePath::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:ComputePath.from)
  
  ::Pos* temp = from_;
  from_ = nullptr;
  return temp;
}
inline ::Pos* ComputePath::_internal_mutable_from() {
  
  if (from_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArenaForAllocation());
    from_ = p;
  }
  return from_;
}
inline ::Pos* ComputePath::mutable_from() {
  ::Pos* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:ComputePath.from)
  return _msg;
}
inline void ComputePath::set_allocated_from(::Pos* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Pos>::GetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:ComputePath.from)
}

// .Pos to = 3;
inline bool ComputePath::_internal_has_to() const {
  return this != internal_default_instance() && to_ != nullptr;
}
inline bool ComputePath::has_to() const {
  return _internal_has_to();
}
inline void ComputePath::clear_to() {
  if (GetArenaForAllocation() == nullptr && to_ != nullptr) {
    delete to_;
  }
  to_ = nullptr;
}
inline const ::Pos& ComputePath::_internal_to() const {
  const ::Pos* p = to_;
  return p != nullptr ? *p : reinterpret_cast<const ::Pos&>(
      ::_Pos_default_instance_);
}
inline const ::Pos& ComputePath::to() const {
  // @@protoc_insertion_point(field_get:ComputePath.to)
  return _internal_to();
}
inline void ComputePath::unsafe_arena_set_allocated_to(
    ::Pos* to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(to_);
  }
  to_ = to;
  if (to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ComputePath.to)
}
inline ::Pos* ComputePath::release_to() {
  
  ::Pos* temp = to_;
  to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Pos* ComputePath::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:ComputePath.to)
  
  ::Pos* temp = to_;
  to_ = nullptr;
  return temp;
}
inline ::Pos* ComputePath::_internal_mutable_to() {
  
  if (to_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArenaForAllocation());
    to_ = p;
  }
  return to_;
}
inline ::Pos* ComputePath::mutable_to() {
  ::Pos* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:ComputePath.to)
  return _msg;
}
inline void ComputePath::set_allocated_to(::Pos* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Pos>::GetOwningArena(to);
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  to_ = to;
  // @@protoc_insertion_point(field_set_allocated:ComputePath.to)
}

// int32 pathID = 4;
inline void ComputePath::clear_pathid() {
  pathid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::_internal_pathid() const {
  return pathid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::pathid() const {
  // @@protoc_insertion_point(field_get:ComputePath.pathID)
  return _internal_pathid();
}
inline void ComputePath::_internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pathid_ = value;
}
inline void ComputePath::set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pathid(value);
  // @@protoc_insertion_point(field_set:ComputePath.pathID)
}

// -------------------------------------------------------------------

// SetEconomySettings

// int32 beakerPercent = 1;
inline void SetEconomySettings::clear_beakerpercent() {
  beakerpercent_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetEconomySettings::_internal_beakerpercent() const {
  return beakerpercent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetEconomySettings::beakerpercent() const {
  // @@protoc_insertion_point(field_get:SetEconomySettings.beakerPercent)
  return _internal_beakerpercent();
}
inline void SetEconomySettings::_internal_set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  beakerpercent_ = value;
}
inline void SetEconomySettings::set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_beakerpercent(value);
  // @@protoc_insertion_point(field_set:SetEconomySettings.beakerPercent)
}

// -------------------------------------------------------------------

// SetResearch

// string techID = 1;
inline void SetResearch::clear_techid() {
  techid_.ClearToEmpty();
}
inline const std::string& SetResearch::techid() const {
  // @@protoc_insertion_point(field_get:SetResearch.techID)
  return _internal_techid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetResearch::set_techid(ArgT0&& arg0, ArgT... args) {
 
 techid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetResearch.techID)
}
inline std::string* SetResearch::mutable_techid() {
  std::string* _s = _internal_mutable_techid();
  // @@protoc_insertion_point(field_mutable:SetResearch.techID)
  return _s;
}
inline const std::string& SetResearch::_internal_techid() const {
  return techid_.Get();
}
inline void SetResearch::_internal_set_techid(const std::string& value) {
  
  techid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetResearch::_internal_mutable_techid() {
  
  return techid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetResearch::release_techid() {
  // @@protoc_insertion_point(field_release:SetResearch.techID)
  return techid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetResearch::set_allocated_techid(std::string* techid) {
  if (techid != nullptr) {
    
  } else {
    
  }
  techid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), techid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SetResearch.techID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Era> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Era>() {
  return ::Era_descriptor();
}
template <> struct is_proto_enum< ::Terrain> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Terrain>() {
  return ::Terrain_descriptor();
}
template <> struct is_proto_enum< ::Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Visibility>() {
  return ::Visibility_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_riposte_2eproto
