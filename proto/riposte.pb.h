// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riposte.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_riposte_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_riposte_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_riposte_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_riposte_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[39]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_riposte_2eproto;
class AdminStartGame;
class AdminStartGameDefaultTypeInternal;
extern AdminStartGameDefaultTypeInternal _AdminStartGame_default_instance_;
class AnyClient;
class AnyClientDefaultTypeInternal;
extern AnyClientDefaultTypeInternal _AnyClient_default_instance_;
class AnyServer;
class AnyServerDefaultTypeInternal;
extern AnyServerDefaultTypeInternal _AnyServer_default_instance_;
class BuildTask;
class BuildTaskDefaultTypeInternal;
extern BuildTaskDefaultTypeInternal _BuildTask_default_instance_;
class BuildTaskKind;
class BuildTaskKindDefaultTypeInternal;
extern BuildTaskKindDefaultTypeInternal _BuildTaskKind_default_instance_;
class BuildingBuildTask;
class BuildingBuildTaskDefaultTypeInternal;
extern BuildingBuildTaskDefaultTypeInternal _BuildingBuildTask_default_instance_;
class Capability;
class CapabilityDefaultTypeInternal;
extern CapabilityDefaultTypeInternal _Capability_default_instance_;
class CarryUnitsCapability;
class CarryUnitsCapabilityDefaultTypeInternal;
extern CarryUnitsCapabilityDefaultTypeInternal _CarryUnitsCapability_default_instance_;
class ClientInfo;
class ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class ComputePath;
class ComputePathDefaultTypeInternal;
extern ComputePathDefaultTypeInternal _ComputePath_default_instance_;
class FoundCityCapability;
class FoundCityCapabilityDefaultTypeInternal;
extern FoundCityCapabilityDefaultTypeInternal _FoundCityCapability_default_instance_;
class Improvement;
class ImprovementDefaultTypeInternal;
extern ImprovementDefaultTypeInternal _Improvement_default_instance_;
class KickPlayer;
class KickPlayerDefaultTypeInternal;
extern KickPlayerDefaultTypeInternal _KickPlayer_default_instance_;
class LobbyError;
class LobbyErrorDefaultTypeInternal;
extern LobbyErrorDefaultTypeInternal _LobbyError_default_instance_;
class MoveUnit;
class MoveUnitDefaultTypeInternal;
extern MoveUnitDefaultTypeInternal _MoveUnit_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PathComputed;
class PathComputedDefaultTypeInternal;
extern PathComputedDefaultTypeInternal _PathComputed_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class Pos;
class PosDefaultTypeInternal;
extern PosDefaultTypeInternal _Pos_default_instance_;
class ResearchingTech;
class ResearchingTechDefaultTypeInternal;
extern ResearchingTechDefaultTypeInternal _ResearchingTech_default_instance_;
class ServerInfo;
class ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class SetCityBuildTask;
class SetCityBuildTaskDefaultTypeInternal;
extern SetCityBuildTaskDefaultTypeInternal _SetCityBuildTask_default_instance_;
class SetEconomySettings;
class SetEconomySettingsDefaultTypeInternal;
extern SetEconomySettingsDefaultTypeInternal _SetEconomySettings_default_instance_;
class SetLeader;
class SetLeaderDefaultTypeInternal;
extern SetLeaderDefaultTypeInternal _SetLeader_default_instance_;
class SetResearch;
class SetResearchDefaultTypeInternal;
extern SetResearchDefaultTypeInternal _SetResearch_default_instance_;
class SetWorkerTask;
class SetWorkerTaskDefaultTypeInternal;
extern SetWorkerTaskDefaultTypeInternal _SetWorkerTask_default_instance_;
class StartGame;
class StartGameDefaultTypeInternal;
extern StartGameDefaultTypeInternal _StartGame_default_instance_;
class Tile;
class TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class UnitBuildTask;
class UnitBuildTaskDefaultTypeInternal;
extern UnitBuildTaskDefaultTypeInternal _UnitBuildTask_default_instance_;
class UpdateCity;
class UpdateCityDefaultTypeInternal;
extern UpdateCityDefaultTypeInternal _UpdateCity_default_instance_;
class UpdateGlobalData;
class UpdateGlobalDataDefaultTypeInternal;
extern UpdateGlobalDataDefaultTypeInternal _UpdateGlobalData_default_instance_;
class UpdateMap;
class UpdateMapDefaultTypeInternal;
extern UpdateMapDefaultTypeInternal _UpdateMap_default_instance_;
class UpdatePlayer;
class UpdatePlayerDefaultTypeInternal;
extern UpdatePlayerDefaultTypeInternal _UpdatePlayer_default_instance_;
class UpdateUnit;
class UpdateUnitDefaultTypeInternal;
extern UpdateUnitDefaultTypeInternal _UpdateUnit_default_instance_;
class WorkerCapability;
class WorkerCapabilityDefaultTypeInternal;
extern WorkerCapabilityDefaultTypeInternal _WorkerCapability_default_instance_;
class WorkerTask;
class WorkerTaskDefaultTypeInternal;
extern WorkerTaskDefaultTypeInternal _WorkerTask_default_instance_;
class WorkerTaskImprovement;
class WorkerTaskImprovementDefaultTypeInternal;
extern WorkerTaskImprovementDefaultTypeInternal _WorkerTaskImprovement_default_instance_;
class WorkerTaskKind;
class WorkerTaskKindDefaultTypeInternal;
extern WorkerTaskKindDefaultTypeInternal _WorkerTaskKind_default_instance_;
class Yield;
class YieldDefaultTypeInternal;
extern YieldDefaultTypeInternal _Yield_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AdminStartGame* Arena::CreateMaybeMessage<::AdminStartGame>(Arena*);
template<> ::AnyClient* Arena::CreateMaybeMessage<::AnyClient>(Arena*);
template<> ::AnyServer* Arena::CreateMaybeMessage<::AnyServer>(Arena*);
template<> ::BuildTask* Arena::CreateMaybeMessage<::BuildTask>(Arena*);
template<> ::BuildTaskKind* Arena::CreateMaybeMessage<::BuildTaskKind>(Arena*);
template<> ::BuildingBuildTask* Arena::CreateMaybeMessage<::BuildingBuildTask>(Arena*);
template<> ::Capability* Arena::CreateMaybeMessage<::Capability>(Arena*);
template<> ::CarryUnitsCapability* Arena::CreateMaybeMessage<::CarryUnitsCapability>(Arena*);
template<> ::ClientInfo* Arena::CreateMaybeMessage<::ClientInfo>(Arena*);
template<> ::ComputePath* Arena::CreateMaybeMessage<::ComputePath>(Arena*);
template<> ::FoundCityCapability* Arena::CreateMaybeMessage<::FoundCityCapability>(Arena*);
template<> ::Improvement* Arena::CreateMaybeMessage<::Improvement>(Arena*);
template<> ::KickPlayer* Arena::CreateMaybeMessage<::KickPlayer>(Arena*);
template<> ::LobbyError* Arena::CreateMaybeMessage<::LobbyError>(Arena*);
template<> ::MoveUnit* Arena::CreateMaybeMessage<::MoveUnit>(Arena*);
template<> ::Path* Arena::CreateMaybeMessage<::Path>(Arena*);
template<> ::PathComputed* Arena::CreateMaybeMessage<::PathComputed>(Arena*);
template<> ::PlayerInfo* Arena::CreateMaybeMessage<::PlayerInfo>(Arena*);
template<> ::Pos* Arena::CreateMaybeMessage<::Pos>(Arena*);
template<> ::ResearchingTech* Arena::CreateMaybeMessage<::ResearchingTech>(Arena*);
template<> ::ServerInfo* Arena::CreateMaybeMessage<::ServerInfo>(Arena*);
template<> ::SetCityBuildTask* Arena::CreateMaybeMessage<::SetCityBuildTask>(Arena*);
template<> ::SetEconomySettings* Arena::CreateMaybeMessage<::SetEconomySettings>(Arena*);
template<> ::SetLeader* Arena::CreateMaybeMessage<::SetLeader>(Arena*);
template<> ::SetResearch* Arena::CreateMaybeMessage<::SetResearch>(Arena*);
template<> ::SetWorkerTask* Arena::CreateMaybeMessage<::SetWorkerTask>(Arena*);
template<> ::StartGame* Arena::CreateMaybeMessage<::StartGame>(Arena*);
template<> ::Tile* Arena::CreateMaybeMessage<::Tile>(Arena*);
template<> ::UnitBuildTask* Arena::CreateMaybeMessage<::UnitBuildTask>(Arena*);
template<> ::UpdateCity* Arena::CreateMaybeMessage<::UpdateCity>(Arena*);
template<> ::UpdateGlobalData* Arena::CreateMaybeMessage<::UpdateGlobalData>(Arena*);
template<> ::UpdateMap* Arena::CreateMaybeMessage<::UpdateMap>(Arena*);
template<> ::UpdatePlayer* Arena::CreateMaybeMessage<::UpdatePlayer>(Arena*);
template<> ::UpdateUnit* Arena::CreateMaybeMessage<::UpdateUnit>(Arena*);
template<> ::WorkerCapability* Arena::CreateMaybeMessage<::WorkerCapability>(Arena*);
template<> ::WorkerTask* Arena::CreateMaybeMessage<::WorkerTask>(Arena*);
template<> ::WorkerTaskImprovement* Arena::CreateMaybeMessage<::WorkerTaskImprovement>(Arena*);
template<> ::WorkerTaskKind* Arena::CreateMaybeMessage<::WorkerTaskKind>(Arena*);
template<> ::Yield* Arena::CreateMaybeMessage<::Yield>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Era : int {
  Ancient = 0,
  Classical = 1,
  Medieval = 2,
  Renaissance = 3,
  Industrial = 4,
  Modern = 5,
  Future = 6,
  Era_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Era_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Era_IsValid(int value);
constexpr Era Era_MIN = Ancient;
constexpr Era Era_MAX = Future;
constexpr int Era_ARRAYSIZE = Era_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Era_descriptor();
template<typename T>
inline const std::string& Era_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Era>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Era_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Era_descriptor(), enum_t_value);
}
inline bool Era_Parse(
    const std::string& name, Era* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Era>(
    Era_descriptor(), name, value);
}
enum Terrain : int {
  Grassland = 0,
  Desert = 1,
  Ocean = 2,
  Plains = 3,
  Terrain_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Terrain_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Terrain_IsValid(int value);
constexpr Terrain Terrain_MIN = Grassland;
constexpr Terrain Terrain_MAX = Plains;
constexpr int Terrain_ARRAYSIZE = Terrain_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Terrain_descriptor();
template<typename T>
inline const std::string& Terrain_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Terrain>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Terrain_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Terrain_descriptor(), enum_t_value);
}
inline bool Terrain_Parse(
    const std::string& name, Terrain* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Terrain>(
    Terrain_descriptor(), name, value);
}
enum Visibility : int {
  Visible = 0,
  Fogged = 1,
  Hidden = 2,
  Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Visibility_IsValid(int value);
constexpr Visibility Visibility_MIN = Visible;
constexpr Visibility Visibility_MAX = Hidden;
constexpr int Visibility_ARRAYSIZE = Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_descriptor();
template<typename T>
inline const std::string& Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Visibility_descriptor(), enum_t_value);
}
inline bool Visibility_Parse(
    const std::string& name, Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility>(
    Visibility_descriptor(), name, value);
}
// ===================================================================

class Pos PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Pos) */ {
 public:
  inline Pos() : Pos(nullptr) {};
  virtual ~Pos();

  Pos(const Pos& from);
  Pos(Pos&& from) noexcept
    : Pos() {
    *this = ::std::move(from);
  }

  inline Pos& operator=(const Pos& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pos& operator=(Pos&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Pos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pos* internal_default_instance() {
    return reinterpret_cast<const Pos*>(
               &_Pos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Pos& a, Pos& b) {
    a.Swap(&b);
  }
  inline void Swap(Pos* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pos* New() const final {
    return CreateMaybeMessage<Pos>(nullptr);
  }

  Pos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Pos& from);
  void MergeFrom(const Pos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Pos";
  }
  protected:
  explicit Pos(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // uint32 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::uint32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::uint32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Pos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 x_;
  ::PROTOBUF_NAMESPACE_ID::uint32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class AnyClient PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AnyClient) */ {
 public:
  inline AnyClient() : AnyClient(nullptr) {};
  virtual ~AnyClient();

  AnyClient(const AnyClient& from);
  AnyClient(AnyClient&& from) noexcept
    : AnyClient() {
    *this = ::std::move(from);
  }

  inline AnyClient& operator=(const AnyClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyClient& operator=(AnyClient&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnyClient& default_instance();

  enum PacketCase {
    kClientInfo = 1,
    PACKET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnyClient* internal_default_instance() {
    return reinterpret_cast<const AnyClient*>(
               &_AnyClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AnyClient& a, AnyClient& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyClient* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnyClient* New() const final {
    return CreateMaybeMessage<AnyClient>(nullptr);
  }

  AnyClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnyClient>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnyClient& from);
  void MergeFrom(const AnyClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AnyClient";
  }
  protected:
  explicit AnyClient(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientInfoFieldNumber = 1,
  };
  // .ClientInfo clientInfo = 1;
  bool has_clientinfo() const;
  private:
  bool _internal_has_clientinfo() const;
  public:
  void clear_clientinfo();
  const ::ClientInfo& clientinfo() const;
  ::ClientInfo* release_clientinfo();
  ::ClientInfo* mutable_clientinfo();
  void set_allocated_clientinfo(::ClientInfo* clientinfo);
  private:
  const ::ClientInfo& _internal_clientinfo() const;
  ::ClientInfo* _internal_mutable_clientinfo();
  public:
  void unsafe_arena_set_allocated_clientinfo(
      ::ClientInfo* clientinfo);
  ::ClientInfo* unsafe_arena_release_clientinfo();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:AnyClient)
 private:
  class _Internal;
  void set_has_clientinfo();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PacketUnion {
    PacketUnion() {}
    ::ClientInfo* clientinfo_;
  } packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class AnyServer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AnyServer) */ {
 public:
  inline AnyServer() : AnyServer(nullptr) {};
  virtual ~AnyServer();

  AnyServer(const AnyServer& from);
  AnyServer(AnyServer&& from) noexcept
    : AnyServer() {
    *this = ::std::move(from);
  }

  inline AnyServer& operator=(const AnyServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyServer& operator=(AnyServer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnyServer& default_instance();

  enum PacketCase {
    kServerInfo = 1,
    kStartGame = 2,
    kLobbyError = 3,
    kUpdateGlobalData = 4,
    kUpdateMap = 5,
    kUpdateCity = 6,
    kUpdateUnit = 7,
    kUpdatePlayer = 8,
    kPathComputed = 9,
    PACKET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnyServer* internal_default_instance() {
    return reinterpret_cast<const AnyServer*>(
               &_AnyServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AnyServer& a, AnyServer& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyServer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnyServer* New() const final {
    return CreateMaybeMessage<AnyServer>(nullptr);
  }

  AnyServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnyServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnyServer& from);
  void MergeFrom(const AnyServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AnyServer";
  }
  protected:
  explicit AnyServer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerInfoFieldNumber = 1,
    kStartGameFieldNumber = 2,
    kLobbyErrorFieldNumber = 3,
    kUpdateGlobalDataFieldNumber = 4,
    kUpdateMapFieldNumber = 5,
    kUpdateCityFieldNumber = 6,
    kUpdateUnitFieldNumber = 7,
    kUpdatePlayerFieldNumber = 8,
    kPathComputedFieldNumber = 9,
  };
  // .ServerInfo serverInfo = 1;
  bool has_serverinfo() const;
  private:
  bool _internal_has_serverinfo() const;
  public:
  void clear_serverinfo();
  const ::ServerInfo& serverinfo() const;
  ::ServerInfo* release_serverinfo();
  ::ServerInfo* mutable_serverinfo();
  void set_allocated_serverinfo(::ServerInfo* serverinfo);
  private:
  const ::ServerInfo& _internal_serverinfo() const;
  ::ServerInfo* _internal_mutable_serverinfo();
  public:
  void unsafe_arena_set_allocated_serverinfo(
      ::ServerInfo* serverinfo);
  ::ServerInfo* unsafe_arena_release_serverinfo();

  // .StartGame startGame = 2;
  bool has_startgame() const;
  private:
  bool _internal_has_startgame() const;
  public:
  void clear_startgame();
  const ::StartGame& startgame() const;
  ::StartGame* release_startgame();
  ::StartGame* mutable_startgame();
  void set_allocated_startgame(::StartGame* startgame);
  private:
  const ::StartGame& _internal_startgame() const;
  ::StartGame* _internal_mutable_startgame();
  public:
  void unsafe_arena_set_allocated_startgame(
      ::StartGame* startgame);
  ::StartGame* unsafe_arena_release_startgame();

  // .LobbyError lobbyError = 3;
  bool has_lobbyerror() const;
  private:
  bool _internal_has_lobbyerror() const;
  public:
  void clear_lobbyerror();
  const ::LobbyError& lobbyerror() const;
  ::LobbyError* release_lobbyerror();
  ::LobbyError* mutable_lobbyerror();
  void set_allocated_lobbyerror(::LobbyError* lobbyerror);
  private:
  const ::LobbyError& _internal_lobbyerror() const;
  ::LobbyError* _internal_mutable_lobbyerror();
  public:
  void unsafe_arena_set_allocated_lobbyerror(
      ::LobbyError* lobbyerror);
  ::LobbyError* unsafe_arena_release_lobbyerror();

  // .UpdateGlobalData updateGlobalData = 4;
  bool has_updateglobaldata() const;
  private:
  bool _internal_has_updateglobaldata() const;
  public:
  void clear_updateglobaldata();
  const ::UpdateGlobalData& updateglobaldata() const;
  ::UpdateGlobalData* release_updateglobaldata();
  ::UpdateGlobalData* mutable_updateglobaldata();
  void set_allocated_updateglobaldata(::UpdateGlobalData* updateglobaldata);
  private:
  const ::UpdateGlobalData& _internal_updateglobaldata() const;
  ::UpdateGlobalData* _internal_mutable_updateglobaldata();
  public:
  void unsafe_arena_set_allocated_updateglobaldata(
      ::UpdateGlobalData* updateglobaldata);
  ::UpdateGlobalData* unsafe_arena_release_updateglobaldata();

  // .UpdateMap updateMap = 5;
  bool has_updatemap() const;
  private:
  bool _internal_has_updatemap() const;
  public:
  void clear_updatemap();
  const ::UpdateMap& updatemap() const;
  ::UpdateMap* release_updatemap();
  ::UpdateMap* mutable_updatemap();
  void set_allocated_updatemap(::UpdateMap* updatemap);
  private:
  const ::UpdateMap& _internal_updatemap() const;
  ::UpdateMap* _internal_mutable_updatemap();
  public:
  void unsafe_arena_set_allocated_updatemap(
      ::UpdateMap* updatemap);
  ::UpdateMap* unsafe_arena_release_updatemap();

  // .UpdateCity updateCity = 6;
  bool has_updatecity() const;
  private:
  bool _internal_has_updatecity() const;
  public:
  void clear_updatecity();
  const ::UpdateCity& updatecity() const;
  ::UpdateCity* release_updatecity();
  ::UpdateCity* mutable_updatecity();
  void set_allocated_updatecity(::UpdateCity* updatecity);
  private:
  const ::UpdateCity& _internal_updatecity() const;
  ::UpdateCity* _internal_mutable_updatecity();
  public:
  void unsafe_arena_set_allocated_updatecity(
      ::UpdateCity* updatecity);
  ::UpdateCity* unsafe_arena_release_updatecity();

  // .UpdateUnit updateUnit = 7;
  bool has_updateunit() const;
  private:
  bool _internal_has_updateunit() const;
  public:
  void clear_updateunit();
  const ::UpdateUnit& updateunit() const;
  ::UpdateUnit* release_updateunit();
  ::UpdateUnit* mutable_updateunit();
  void set_allocated_updateunit(::UpdateUnit* updateunit);
  private:
  const ::UpdateUnit& _internal_updateunit() const;
  ::UpdateUnit* _internal_mutable_updateunit();
  public:
  void unsafe_arena_set_allocated_updateunit(
      ::UpdateUnit* updateunit);
  ::UpdateUnit* unsafe_arena_release_updateunit();

  // .UpdatePlayer updatePlayer = 8;
  bool has_updateplayer() const;
  private:
  bool _internal_has_updateplayer() const;
  public:
  void clear_updateplayer();
  const ::UpdatePlayer& updateplayer() const;
  ::UpdatePlayer* release_updateplayer();
  ::UpdatePlayer* mutable_updateplayer();
  void set_allocated_updateplayer(::UpdatePlayer* updateplayer);
  private:
  const ::UpdatePlayer& _internal_updateplayer() const;
  ::UpdatePlayer* _internal_mutable_updateplayer();
  public:
  void unsafe_arena_set_allocated_updateplayer(
      ::UpdatePlayer* updateplayer);
  ::UpdatePlayer* unsafe_arena_release_updateplayer();

  // .PathComputed pathComputed = 9;
  bool has_pathcomputed() const;
  private:
  bool _internal_has_pathcomputed() const;
  public:
  void clear_pathcomputed();
  const ::PathComputed& pathcomputed() const;
  ::PathComputed* release_pathcomputed();
  ::PathComputed* mutable_pathcomputed();
  void set_allocated_pathcomputed(::PathComputed* pathcomputed);
  private:
  const ::PathComputed& _internal_pathcomputed() const;
  ::PathComputed* _internal_mutable_pathcomputed();
  public:
  void unsafe_arena_set_allocated_pathcomputed(
      ::PathComputed* pathcomputed);
  ::PathComputed* unsafe_arena_release_pathcomputed();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:AnyServer)
 private:
  class _Internal;
  void set_has_serverinfo();
  void set_has_startgame();
  void set_has_lobbyerror();
  void set_has_updateglobaldata();
  void set_has_updatemap();
  void set_has_updatecity();
  void set_has_updateunit();
  void set_has_updateplayer();
  void set_has_pathcomputed();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PacketUnion {
    PacketUnion() {}
    ::ServerInfo* serverinfo_;
    ::StartGame* startgame_;
    ::LobbyError* lobbyerror_;
    ::UpdateGlobalData* updateglobaldata_;
    ::UpdateMap* updatemap_;
    ::UpdateCity* updatecity_;
    ::UpdateUnit* updateunit_;
    ::UpdatePlayer* updateplayer_;
    ::PathComputed* pathcomputed_;
  } packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {};
  virtual ~ClientInfo();

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientInfo* New() const final {
    return CreateMaybeMessage<ClientInfo>(nullptr);
  }

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {};
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const final {
    return CreateMaybeMessage<ServerInfo>(nullptr);
  }

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPlayersFieldNumber = 2,
    kPlayerIDFieldNumber = 1,
  };
  // repeated .PlayerInfo currentPlayers = 2;
  int currentplayers_size() const;
  private:
  int _internal_currentplayers_size() const;
  public:
  void clear_currentplayers();
  ::PlayerInfo* mutable_currentplayers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
      mutable_currentplayers();
  private:
  const ::PlayerInfo& _internal_currentplayers(int index) const;
  ::PlayerInfo* _internal_add_currentplayers();
  public:
  const ::PlayerInfo& currentplayers(int index) const;
  ::PlayerInfo* add_currentplayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
      currentplayers() const;

  // int32 playerID = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo > currentplayers_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class KickPlayer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KickPlayer) */ {
 public:
  inline KickPlayer() : KickPlayer(nullptr) {};
  virtual ~KickPlayer();

  KickPlayer(const KickPlayer& from);
  KickPlayer(KickPlayer&& from) noexcept
    : KickPlayer() {
    *this = ::std::move(from);
  }

  inline KickPlayer& operator=(const KickPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPlayer& operator=(KickPlayer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KickPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KickPlayer* internal_default_instance() {
    return reinterpret_cast<const KickPlayer*>(
               &_KickPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(KickPlayer& a, KickPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPlayer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KickPlayer* New() const final {
    return CreateMaybeMessage<KickPlayer>(nullptr);
  }

  KickPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KickPlayer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KickPlayer& from);
  void MergeFrom(const KickPlayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KickPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KickPlayer";
  }
  protected:
  explicit KickPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kIDFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reason();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reason(
      std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // int32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:KickPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetLeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetLeader) */ {
 public:
  inline SetLeader() : SetLeader(nullptr) {};
  virtual ~SetLeader();

  SetLeader(const SetLeader& from);
  SetLeader(SetLeader&& from) noexcept
    : SetLeader() {
    *this = ::std::move(from);
  }

  inline SetLeader& operator=(const SetLeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLeader& operator=(SetLeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetLeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLeader* internal_default_instance() {
    return reinterpret_cast<const SetLeader*>(
               &_SetLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetLeader& a, SetLeader& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetLeader* New() const final {
    return CreateMaybeMessage<SetLeader>(nullptr);
  }

  SetLeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetLeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetLeader& from);
  void MergeFrom(const SetLeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetLeader";
  }
  protected:
  explicit SetLeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCivIDFieldNumber = 1,
    kLeaderFieldNumber = 2,
  };
  // string civID = 1;
  void clear_civid();
  const std::string& civid() const;
  void set_civid(const std::string& value);
  void set_civid(std::string&& value);
  void set_civid(const char* value);
  void set_civid(const char* value, size_t size);
  std::string* mutable_civid();
  std::string* release_civid();
  void set_allocated_civid(std::string* civid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_civid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_civid(
      std::string* civid);
  private:
  const std::string& _internal_civid() const;
  void _internal_set_civid(const std::string& value);
  std::string* _internal_mutable_civid();
  public:

  // string leader = 2;
  void clear_leader();
  const std::string& leader() const;
  void set_leader(const std::string& value);
  void set_leader(std::string&& value);
  void set_leader(const char* value);
  void set_leader(const char* value, size_t size);
  std::string* mutable_leader();
  std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_leader();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_leader(
      std::string* leader);
  private:
  const std::string& _internal_leader() const;
  void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // @@protoc_insertion_point(class_scope:SetLeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr civid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class AdminStartGame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminStartGame) */ {
 public:
  inline AdminStartGame() : AdminStartGame(nullptr) {};
  virtual ~AdminStartGame();

  AdminStartGame(const AdminStartGame& from);
  AdminStartGame(AdminStartGame&& from) noexcept
    : AdminStartGame() {
    *this = ::std::move(from);
  }

  inline AdminStartGame& operator=(const AdminStartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminStartGame& operator=(AdminStartGame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdminStartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminStartGame* internal_default_instance() {
    return reinterpret_cast<const AdminStartGame*>(
               &_AdminStartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AdminStartGame& a, AdminStartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminStartGame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminStartGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdminStartGame* New() const final {
    return CreateMaybeMessage<AdminStartGame>(nullptr);
  }

  AdminStartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdminStartGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdminStartGame& from);
  void MergeFrom(const AdminStartGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminStartGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminStartGame";
  }
  protected:
  explicit AdminStartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AdminStartGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class LobbyError PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LobbyError) */ {
 public:
  inline LobbyError() : LobbyError(nullptr) {};
  virtual ~LobbyError();

  LobbyError(const LobbyError& from);
  LobbyError(LobbyError&& from) noexcept
    : LobbyError() {
    *this = ::std::move(from);
  }

  inline LobbyError& operator=(const LobbyError& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyError& operator=(LobbyError&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LobbyError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LobbyError* internal_default_instance() {
    return reinterpret_cast<const LobbyError*>(
               &_LobbyError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LobbyError& a, LobbyError& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyError* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LobbyError* New() const final {
    return CreateMaybeMessage<LobbyError>(nullptr);
  }

  LobbyError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LobbyError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LobbyError& from);
  void MergeFrom(const LobbyError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LobbyError";
  }
  protected:
  explicit LobbyError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:LobbyError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class StartGame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StartGame) */ {
 public:
  inline StartGame() : StartGame(nullptr) {};
  virtual ~StartGame();

  StartGame(const StartGame& from);
  StartGame(StartGame&& from) noexcept
    : StartGame() {
    *this = ::std::move(from);
  }

  inline StartGame& operator=(const StartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartGame& operator=(StartGame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartGame* internal_default_instance() {
    return reinterpret_cast<const StartGame*>(
               &_StartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StartGame& a, StartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(StartGame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartGame* New() const final {
    return CreateMaybeMessage<StartGame>(nullptr);
  }

  StartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartGame& from);
  void MergeFrom(const StartGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartGame";
  }
  protected:
  explicit StartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:StartGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {};
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(nullptr);
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kCivIDFieldNumber = 2,
    kLeaderNameFieldNumber = 3,
    kScoreFieldNumber = 4,
    kIdFieldNumber = 5,
    kIsAdminFieldNumber = 6,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string civID = 2;
  void clear_civid();
  const std::string& civid() const;
  void set_civid(const std::string& value);
  void set_civid(std::string&& value);
  void set_civid(const char* value);
  void set_civid(const char* value, size_t size);
  std::string* mutable_civid();
  std::string* release_civid();
  void set_allocated_civid(std::string* civid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_civid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_civid(
      std::string* civid);
  private:
  const std::string& _internal_civid() const;
  void _internal_set_civid(const std::string& value);
  std::string* _internal_mutable_civid();
  public:

  // string leaderName = 3;
  void clear_leadername();
  const std::string& leadername() const;
  void set_leadername(const std::string& value);
  void set_leadername(std::string&& value);
  void set_leadername(const char* value);
  void set_leadername(const char* value, size_t size);
  std::string* mutable_leadername();
  std::string* release_leadername();
  void set_allocated_leadername(std::string* leadername);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_leadername();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_leadername(
      std::string* leadername);
  private:
  const std::string& _internal_leadername() const;
  void _internal_set_leadername(const std::string& value);
  std::string* _internal_mutable_leadername();
  public:

  // int32 score = 4;
  void clear_score();
  ::PROTOBUF_NAMESPACE_ID::int32 score() const;
  void set_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_score() const;
  void _internal_set_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 id = 5;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isAdmin = 6;
  void clear_isadmin();
  bool isadmin() const;
  void set_isadmin(bool value);
  private:
  bool _internal_isadmin() const;
  void _internal_set_isadmin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr civid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leadername_;
  ::PROTOBUF_NAMESPACE_ID::int32 score_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  bool isadmin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateGlobalData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateGlobalData) */ {
 public:
  inline UpdateGlobalData() : UpdateGlobalData(nullptr) {};
  virtual ~UpdateGlobalData();

  UpdateGlobalData(const UpdateGlobalData& from);
  UpdateGlobalData(UpdateGlobalData&& from) noexcept
    : UpdateGlobalData() {
    *this = ::std::move(from);
  }

  inline UpdateGlobalData& operator=(const UpdateGlobalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateGlobalData& operator=(UpdateGlobalData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateGlobalData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateGlobalData* internal_default_instance() {
    return reinterpret_cast<const UpdateGlobalData*>(
               &_UpdateGlobalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateGlobalData& a, UpdateGlobalData& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateGlobalData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateGlobalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateGlobalData* New() const final {
    return CreateMaybeMessage<UpdateGlobalData>(nullptr);
  }

  UpdateGlobalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateGlobalData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateGlobalData& from);
  void MergeFrom(const UpdateGlobalData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateGlobalData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateGlobalData";
  }
  protected:
  explicit UpdateGlobalData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kTurnFieldNumber = 2,
    kEraFieldNumber = 3,
  };
  // repeated .PlayerInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
      mutable_players();
  private:
  const ::PlayerInfo& _internal_players(int index) const;
  ::PlayerInfo* _internal_add_players();
  public:
  const ::PlayerInfo& players(int index) const;
  ::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
      players() const;

  // int32 turn = 2;
  void clear_turn();
  ::PROTOBUF_NAMESPACE_ID::int32 turn() const;
  void set_turn(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_turn() const;
  void _internal_set_turn(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .Era era = 3;
  void clear_era();
  ::Era era() const;
  void set_era(::Era value);
  private:
  ::Era _internal_era() const;
  void _internal_set_era(::Era value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateGlobalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo > players_;
  ::PROTOBUF_NAMESPACE_ID::int32 turn_;
  int era_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Improvement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Improvement) */ {
 public:
  inline Improvement() : Improvement(nullptr) {};
  virtual ~Improvement();

  Improvement(const Improvement& from);
  Improvement(Improvement&& from) noexcept
    : Improvement() {
    *this = ::std::move(from);
  }

  inline Improvement& operator=(const Improvement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Improvement& operator=(Improvement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Improvement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Improvement* internal_default_instance() {
    return reinterpret_cast<const Improvement*>(
               &_Improvement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Improvement& a, Improvement& b) {
    a.Swap(&b);
  }
  inline void Swap(Improvement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Improvement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Improvement* New() const final {
    return CreateMaybeMessage<Improvement>(nullptr);
  }

  Improvement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Improvement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Improvement& from);
  void MergeFrom(const Improvement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Improvement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Improvement";
  }
  protected:
  explicit Improvement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCottageLevelFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string cottageLevel = 2;
  void clear_cottagelevel();
  const std::string& cottagelevel() const;
  void set_cottagelevel(const std::string& value);
  void set_cottagelevel(std::string&& value);
  void set_cottagelevel(const char* value);
  void set_cottagelevel(const char* value, size_t size);
  std::string* mutable_cottagelevel();
  std::string* release_cottagelevel();
  void set_allocated_cottagelevel(std::string* cottagelevel);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_cottagelevel();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_cottagelevel(
      std::string* cottagelevel);
  private:
  const std::string& _internal_cottagelevel() const;
  void _internal_set_cottagelevel(const std::string& value);
  std::string* _internal_mutable_cottagelevel();
  public:

  // @@protoc_insertion_point(class_scope:Improvement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cottagelevel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Yield PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Yield) */ {
 public:
  inline Yield() : Yield(nullptr) {};
  virtual ~Yield();

  Yield(const Yield& from);
  Yield(Yield&& from) noexcept
    : Yield() {
    *this = ::std::move(from);
  }

  inline Yield& operator=(const Yield& from) {
    CopyFrom(from);
    return *this;
  }
  inline Yield& operator=(Yield&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Yield& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Yield* internal_default_instance() {
    return reinterpret_cast<const Yield*>(
               &_Yield_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Yield& a, Yield& b) {
    a.Swap(&b);
  }
  inline void Swap(Yield* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Yield* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Yield* New() const final {
    return CreateMaybeMessage<Yield>(nullptr);
  }

  Yield* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Yield>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Yield& from);
  void MergeFrom(const Yield& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Yield* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Yield";
  }
  protected:
  explicit Yield(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHammersFieldNumber = 1,
    kCommerceFieldNumber = 2,
    kFoodFieldNumber = 3,
  };
  // int32 hammers = 1;
  void clear_hammers();
  ::PROTOBUF_NAMESPACE_ID::int32 hammers() const;
  void set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hammers() const;
  void _internal_set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 commerce = 2;
  void clear_commerce();
  ::PROTOBUF_NAMESPACE_ID::int32 commerce() const;
  void set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_commerce() const;
  void _internal_set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 food = 3;
  void clear_food();
  ::PROTOBUF_NAMESPACE_ID::int32 food() const;
  void set_food(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_food() const;
  void _internal_set_food(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Yield)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 hammers_;
  ::PROTOBUF_NAMESPACE_ID::int32 commerce_;
  ::PROTOBUF_NAMESPACE_ID::int32 food_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Tile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {};
  virtual ~Tile();

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tile* New() const final {
    return CreateMaybeMessage<Tile>(nullptr);
  }

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImprovementsFieldNumber = 4,
    kYieldFieldNumber = 5,
    kTerrainFieldNumber = 1,
    kForestedFieldNumber = 2,
    kHilledFieldNumber = 3,
    kHasOwnerFieldNumber = 7,
    kOwnerIDFieldNumber = 6,
  };
  // repeated .Improvement improvements = 4;
  int improvements_size() const;
  private:
  int _internal_improvements_size() const;
  public:
  void clear_improvements();
  ::Improvement* mutable_improvements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >*
      mutable_improvements();
  private:
  const ::Improvement& _internal_improvements(int index) const;
  ::Improvement* _internal_add_improvements();
  public:
  const ::Improvement& improvements(int index) const;
  ::Improvement* add_improvements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >&
      improvements() const;

  // .Yield yield = 5;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;
  public:
  void clear_yield();
  const ::Yield& yield() const;
  ::Yield* release_yield();
  ::Yield* mutable_yield();
  void set_allocated_yield(::Yield* yield);
  private:
  const ::Yield& _internal_yield() const;
  ::Yield* _internal_mutable_yield();
  public:
  void unsafe_arena_set_allocated_yield(
      ::Yield* yield);
  ::Yield* unsafe_arena_release_yield();

  // .Terrain terrain = 1;
  void clear_terrain();
  ::Terrain terrain() const;
  void set_terrain(::Terrain value);
  private:
  ::Terrain _internal_terrain() const;
  void _internal_set_terrain(::Terrain value);
  public:

  // bool forested = 2;
  void clear_forested();
  bool forested() const;
  void set_forested(bool value);
  private:
  bool _internal_forested() const;
  void _internal_set_forested(bool value);
  public:

  // bool hilled = 3;
  void clear_hilled();
  bool hilled() const;
  void set_hilled(bool value);
  private:
  bool _internal_hilled() const;
  void _internal_set_hilled(bool value);
  public:

  // bool hasOwner = 7;
  void clear_hasowner();
  bool hasowner() const;
  void set_hasowner(bool value);
  private:
  bool _internal_hasowner() const;
  void _internal_set_hasowner(bool value);
  public:

  // int32 ownerID = 6;
  void clear_ownerid();
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid() const;
  void set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ownerid() const;
  void _internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Tile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement > improvements_;
  ::Yield* yield_;
  int terrain_;
  bool forested_;
  bool hilled_;
  bool hasowner_;
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateMap) */ {
 public:
  inline UpdateMap() : UpdateMap(nullptr) {};
  virtual ~UpdateMap();

  UpdateMap(const UpdateMap& from);
  UpdateMap(UpdateMap&& from) noexcept
    : UpdateMap() {
    *this = ::std::move(from);
  }

  inline UpdateMap& operator=(const UpdateMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMap& operator=(UpdateMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateMap* internal_default_instance() {
    return reinterpret_cast<const UpdateMap*>(
               &_UpdateMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateMap& a, UpdateMap& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateMap* New() const final {
    return CreateMaybeMessage<UpdateMap>(nullptr);
  }

  UpdateMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateMap& from);
  void MergeFrom(const UpdateMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateMap";
  }
  protected:
  explicit UpdateMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 3,
    kVisibilityFieldNumber = 4,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // repeated .Tile tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::Tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
      mutable_tiles();
  private:
  const ::Tile& _internal_tiles(int index) const;
  ::Tile* _internal_add_tiles();
  public:
  const ::Tile& tiles(int index) const;
  ::Tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
      tiles() const;

  // repeated .Visibility visibility = 4;
  int visibility_size() const;
  private:
  int _internal_visibility_size() const;
  public:
  void clear_visibility();
  private:
  ::Visibility _internal_visibility(int index) const;
  void _internal_add_visibility(::Visibility value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_visibility();
  public:
  ::Visibility visibility(int index) const;
  void set_visibility(int index, ::Visibility value);
  void add_visibility(::Visibility value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& visibility() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_visibility();

  // uint32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile > tiles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> visibility_;
  mutable std::atomic<int> _visibility_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UnitBuildTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UnitBuildTask) */ {
 public:
  inline UnitBuildTask() : UnitBuildTask(nullptr) {};
  virtual ~UnitBuildTask();

  UnitBuildTask(const UnitBuildTask& from);
  UnitBuildTask(UnitBuildTask&& from) noexcept
    : UnitBuildTask() {
    *this = ::std::move(from);
  }

  inline UnitBuildTask& operator=(const UnitBuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitBuildTask& operator=(UnitBuildTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitBuildTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitBuildTask* internal_default_instance() {
    return reinterpret_cast<const UnitBuildTask*>(
               &_UnitBuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UnitBuildTask& a, UnitBuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitBuildTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitBuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitBuildTask* New() const final {
    return CreateMaybeMessage<UnitBuildTask>(nullptr);
  }

  UnitBuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitBuildTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitBuildTask& from);
  void MergeFrom(const UnitBuildTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitBuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UnitBuildTask";
  }
  protected:
  explicit UnitBuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitKindIDFieldNumber = 1,
  };
  // string unitKindID = 1;
  void clear_unitkindid();
  const std::string& unitkindid() const;
  void set_unitkindid(const std::string& value);
  void set_unitkindid(std::string&& value);
  void set_unitkindid(const char* value);
  void set_unitkindid(const char* value, size_t size);
  std::string* mutable_unitkindid();
  std::string* release_unitkindid();
  void set_allocated_unitkindid(std::string* unitkindid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_unitkindid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_unitkindid(
      std::string* unitkindid);
  private:
  const std::string& _internal_unitkindid() const;
  void _internal_set_unitkindid(const std::string& value);
  std::string* _internal_mutable_unitkindid();
  public:

  // @@protoc_insertion_point(class_scope:UnitBuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unitkindid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class BuildingBuildTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildingBuildTask) */ {
 public:
  inline BuildingBuildTask() : BuildingBuildTask(nullptr) {};
  virtual ~BuildingBuildTask();

  BuildingBuildTask(const BuildingBuildTask& from);
  BuildingBuildTask(BuildingBuildTask&& from) noexcept
    : BuildingBuildTask() {
    *this = ::std::move(from);
  }

  inline BuildingBuildTask& operator=(const BuildingBuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildingBuildTask& operator=(BuildingBuildTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildingBuildTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildingBuildTask* internal_default_instance() {
    return reinterpret_cast<const BuildingBuildTask*>(
               &_BuildingBuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BuildingBuildTask& a, BuildingBuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildingBuildTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildingBuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildingBuildTask* New() const final {
    return CreateMaybeMessage<BuildingBuildTask>(nullptr);
  }

  BuildingBuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildingBuildTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildingBuildTask& from);
  void MergeFrom(const BuildingBuildTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildingBuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildingBuildTask";
  }
  protected:
  explicit BuildingBuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildingIDFieldNumber = 1,
  };
  // string buildingID = 1;
  void clear_buildingid();
  const std::string& buildingid() const;
  void set_buildingid(const std::string& value);
  void set_buildingid(std::string&& value);
  void set_buildingid(const char* value);
  void set_buildingid(const char* value, size_t size);
  std::string* mutable_buildingid();
  std::string* release_buildingid();
  void set_allocated_buildingid(std::string* buildingid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_buildingid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_buildingid(
      std::string* buildingid);
  private:
  const std::string& _internal_buildingid() const;
  void _internal_set_buildingid(const std::string& value);
  std::string* _internal_mutable_buildingid();
  public:

  // @@protoc_insertion_point(class_scope:BuildingBuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buildingid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class BuildTaskKind PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildTaskKind) */ {
 public:
  inline BuildTaskKind() : BuildTaskKind(nullptr) {};
  virtual ~BuildTaskKind();

  BuildTaskKind(const BuildTaskKind& from);
  BuildTaskKind(BuildTaskKind&& from) noexcept
    : BuildTaskKind() {
    *this = ::std::move(from);
  }

  inline BuildTaskKind& operator=(const BuildTaskKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildTaskKind& operator=(BuildTaskKind&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildTaskKind& default_instance();

  enum TaskCase {
    kUnit = 1,
    kBuilding = 2,
    TASK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildTaskKind* internal_default_instance() {
    return reinterpret_cast<const BuildTaskKind*>(
               &_BuildTaskKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BuildTaskKind& a, BuildTaskKind& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildTaskKind* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildTaskKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildTaskKind* New() const final {
    return CreateMaybeMessage<BuildTaskKind>(nullptr);
  }

  BuildTaskKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildTaskKind>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildTaskKind& from);
  void MergeFrom(const BuildTaskKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildTaskKind* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildTaskKind";
  }
  protected:
  explicit BuildTaskKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kBuildingFieldNumber = 2,
  };
  // .UnitBuildTask unit = 1;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const ::UnitBuildTask& unit() const;
  ::UnitBuildTask* release_unit();
  ::UnitBuildTask* mutable_unit();
  void set_allocated_unit(::UnitBuildTask* unit);
  private:
  const ::UnitBuildTask& _internal_unit() const;
  ::UnitBuildTask* _internal_mutable_unit();
  public:
  void unsafe_arena_set_allocated_unit(
      ::UnitBuildTask* unit);
  ::UnitBuildTask* unsafe_arena_release_unit();

  // .BuildingBuildTask building = 2;
  bool has_building() const;
  private:
  bool _internal_has_building() const;
  public:
  void clear_building();
  const ::BuildingBuildTask& building() const;
  ::BuildingBuildTask* release_building();
  ::BuildingBuildTask* mutable_building();
  void set_allocated_building(::BuildingBuildTask* building);
  private:
  const ::BuildingBuildTask& _internal_building() const;
  ::BuildingBuildTask* _internal_mutable_building();
  public:
  void unsafe_arena_set_allocated_building(
      ::BuildingBuildTask* building);
  ::BuildingBuildTask* unsafe_arena_release_building();

  void clear_task();
  TaskCase task_case() const;
  // @@protoc_insertion_point(class_scope:BuildTaskKind)
 private:
  class _Internal;
  void set_has_unit();
  void set_has_building();

  inline bool has_task() const;
  inline void clear_has_task();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TaskUnion {
    TaskUnion() {}
    ::UnitBuildTask* unit_;
    ::BuildingBuildTask* building_;
  } task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class BuildTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildTask) */ {
 public:
  inline BuildTask() : BuildTask(nullptr) {};
  virtual ~BuildTask();

  BuildTask(const BuildTask& from);
  BuildTask(BuildTask&& from) noexcept
    : BuildTask() {
    *this = ::std::move(from);
  }

  inline BuildTask& operator=(const BuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildTask& operator=(BuildTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildTask* internal_default_instance() {
    return reinterpret_cast<const BuildTask*>(
               &_BuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BuildTask& a, BuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildTask* New() const final {
    return CreateMaybeMessage<BuildTask>(nullptr);
  }

  BuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildTask& from);
  void MergeFrom(const BuildTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildTask";
  }
  protected:
  explicit BuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kProgressFieldNumber = 2,
    kCostFieldNumber = 3,
  };
  // .BuildTaskKind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const ::BuildTaskKind& kind() const;
  ::BuildTaskKind* release_kind();
  ::BuildTaskKind* mutable_kind();
  void set_allocated_kind(::BuildTaskKind* kind);
  private:
  const ::BuildTaskKind& _internal_kind() const;
  ::BuildTaskKind* _internal_mutable_kind();
  public:
  void unsafe_arena_set_allocated_kind(
      ::BuildTaskKind* kind);
  ::BuildTaskKind* unsafe_arena_release_kind();

  // int32 progress = 2;
  void clear_progress();
  ::PROTOBUF_NAMESPACE_ID::int32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_progress() const;
  void _internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cost = 3;
  void clear_cost();
  ::PROTOBUF_NAMESPACE_ID::int32 cost() const;
  void set_cost(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cost() const;
  void _internal_set_cost(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::BuildTaskKind* kind_;
  ::PROTOBUF_NAMESPACE_ID::int32 progress_;
  ::PROTOBUF_NAMESPACE_ID::int32 cost_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateCity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateCity) */ {
 public:
  inline UpdateCity() : UpdateCity(nullptr) {};
  virtual ~UpdateCity();

  UpdateCity(const UpdateCity& from);
  UpdateCity(UpdateCity&& from) noexcept
    : UpdateCity() {
    *this = ::std::move(from);
  }

  inline UpdateCity& operator=(const UpdateCity& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCity& operator=(UpdateCity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateCity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateCity* internal_default_instance() {
    return reinterpret_cast<const UpdateCity*>(
               &_UpdateCity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateCity& a, UpdateCity& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateCity* New() const final {
    return CreateMaybeMessage<UpdateCity>(nullptr);
  }

  UpdateCity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateCity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateCity& from);
  void MergeFrom(const UpdateCity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateCity";
  }
  protected:
  explicit UpdateCity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildingNamesFieldNumber = 9,
    kNameFieldNumber = 2,
    kPosFieldNumber = 1,
    kBuildTaskFieldNumber = 4,
    kOwnerIDFieldNumber = 3,
    kHammersPerTurnFieldNumber = 5,
    kCultureFieldNumber = 6,
    kCultureNeededFieldNumber = 7,
    kIDFieldNumber = 8,
  };
  // repeated string buildingNames = 9;
  int buildingnames_size() const;
  private:
  int _internal_buildingnames_size() const;
  public:
  void clear_buildingnames();
  const std::string& buildingnames(int index) const;
  std::string* mutable_buildingnames(int index);
  void set_buildingnames(int index, const std::string& value);
  void set_buildingnames(int index, std::string&& value);
  void set_buildingnames(int index, const char* value);
  void set_buildingnames(int index, const char* value, size_t size);
  std::string* add_buildingnames();
  void add_buildingnames(const std::string& value);
  void add_buildingnames(std::string&& value);
  void add_buildingnames(const char* value);
  void add_buildingnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& buildingnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_buildingnames();
  private:
  const std::string& _internal_buildingnames(int index) const;
  std::string* _internal_add_buildingnames();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Pos pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Pos& pos() const;
  ::Pos* release_pos();
  ::Pos* mutable_pos();
  void set_allocated_pos(::Pos* pos);
  private:
  const ::Pos& _internal_pos() const;
  ::Pos* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Pos* pos);
  ::Pos* unsafe_arena_release_pos();

  // .BuildTask buildTask = 4;
  bool has_buildtask() const;
  private:
  bool _internal_has_buildtask() const;
  public:
  void clear_buildtask();
  const ::BuildTask& buildtask() const;
  ::BuildTask* release_buildtask();
  ::BuildTask* mutable_buildtask();
  void set_allocated_buildtask(::BuildTask* buildtask);
  private:
  const ::BuildTask& _internal_buildtask() const;
  ::BuildTask* _internal_mutable_buildtask();
  public:
  void unsafe_arena_set_allocated_buildtask(
      ::BuildTask* buildtask);
  ::BuildTask* unsafe_arena_release_buildtask();

  // int32 ownerID = 3;
  void clear_ownerid();
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid() const;
  void set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ownerid() const;
  void _internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 hammersPerTurn = 5;
  void clear_hammersperturn();
  ::PROTOBUF_NAMESPACE_ID::int32 hammersperturn() const;
  void set_hammersperturn(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hammersperturn() const;
  void _internal_set_hammersperturn(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 culture = 6;
  void clear_culture();
  ::PROTOBUF_NAMESPACE_ID::int32 culture() const;
  void set_culture(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_culture() const;
  void _internal_set_culture(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cultureNeeded = 7;
  void clear_cultureneeded();
  ::PROTOBUF_NAMESPACE_ID::int32 cultureneeded() const;
  void set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cultureneeded() const;
  void _internal_set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ID = 8;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateCity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> buildingnames_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Pos* pos_;
  ::BuildTask* buildtask_;
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 hammersperturn_;
  ::PROTOBUF_NAMESPACE_ID::int32 culture_;
  ::PROTOBUF_NAMESPACE_ID::int32 cultureneeded_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Path PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Path) */ {
 public:
  inline Path() : Path(nullptr) {};
  virtual ~Path();

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Path& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return CreateMaybeMessage<Path>(nullptr);
  }

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 1,
  };
  // repeated uint32 positions = 1;
  int positions_size() const;
  private:
  int _internal_positions_size() const;
  public:
  void clear_positions();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_positions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_positions() const;
  void _internal_add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_positions();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 positions(int index) const;
  void set_positions(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_positions();

  // @@protoc_insertion_point(class_scope:Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > positions_;
  mutable std::atomic<int> _positions_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class FoundCityCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FoundCityCapability) */ {
 public:
  inline FoundCityCapability() : FoundCityCapability(nullptr) {};
  virtual ~FoundCityCapability();

  FoundCityCapability(const FoundCityCapability& from);
  FoundCityCapability(FoundCityCapability&& from) noexcept
    : FoundCityCapability() {
    *this = ::std::move(from);
  }

  inline FoundCityCapability& operator=(const FoundCityCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline FoundCityCapability& operator=(FoundCityCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FoundCityCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FoundCityCapability* internal_default_instance() {
    return reinterpret_cast<const FoundCityCapability*>(
               &_FoundCityCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FoundCityCapability& a, FoundCityCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(FoundCityCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FoundCityCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FoundCityCapability* New() const final {
    return CreateMaybeMessage<FoundCityCapability>(nullptr);
  }

  FoundCityCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FoundCityCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FoundCityCapability& from);
  void MergeFrom(const FoundCityCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FoundCityCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FoundCityCapability";
  }
  protected:
  explicit FoundCityCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:FoundCityCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerTaskImprovement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerTaskImprovement) */ {
 public:
  inline WorkerTaskImprovement() : WorkerTaskImprovement(nullptr) {};
  virtual ~WorkerTaskImprovement();

  WorkerTaskImprovement(const WorkerTaskImprovement& from);
  WorkerTaskImprovement(WorkerTaskImprovement&& from) noexcept
    : WorkerTaskImprovement() {
    *this = ::std::move(from);
  }

  inline WorkerTaskImprovement& operator=(const WorkerTaskImprovement& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerTaskImprovement& operator=(WorkerTaskImprovement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerTaskImprovement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerTaskImprovement* internal_default_instance() {
    return reinterpret_cast<const WorkerTaskImprovement*>(
               &_WorkerTaskImprovement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WorkerTaskImprovement& a, WorkerTaskImprovement& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerTaskImprovement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerTaskImprovement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerTaskImprovement* New() const final {
    return CreateMaybeMessage<WorkerTaskImprovement>(nullptr);
  }

  WorkerTaskImprovement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerTaskImprovement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerTaskImprovement& from);
  void MergeFrom(const WorkerTaskImprovement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerTaskImprovement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerTaskImprovement";
  }
  protected:
  explicit WorkerTaskImprovement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImprovementIDFieldNumber = 1,
  };
  // string improvementID = 1;
  void clear_improvementid();
  const std::string& improvementid() const;
  void set_improvementid(const std::string& value);
  void set_improvementid(std::string&& value);
  void set_improvementid(const char* value);
  void set_improvementid(const char* value, size_t size);
  std::string* mutable_improvementid();
  std::string* release_improvementid();
  void set_allocated_improvementid(std::string* improvementid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_improvementid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_improvementid(
      std::string* improvementid);
  private:
  const std::string& _internal_improvementid() const;
  void _internal_set_improvementid(const std::string& value);
  std::string* _internal_mutable_improvementid();
  public:

  // @@protoc_insertion_point(class_scope:WorkerTaskImprovement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr improvementid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerTaskKind PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerTaskKind) */ {
 public:
  inline WorkerTaskKind() : WorkerTaskKind(nullptr) {};
  virtual ~WorkerTaskKind();

  WorkerTaskKind(const WorkerTaskKind& from);
  WorkerTaskKind(WorkerTaskKind&& from) noexcept
    : WorkerTaskKind() {
    *this = ::std::move(from);
  }

  inline WorkerTaskKind& operator=(const WorkerTaskKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerTaskKind& operator=(WorkerTaskKind&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerTaskKind& default_instance();

  enum KindCase {
    kBuildImprovement = 1,
    KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerTaskKind* internal_default_instance() {
    return reinterpret_cast<const WorkerTaskKind*>(
               &_WorkerTaskKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WorkerTaskKind& a, WorkerTaskKind& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerTaskKind* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerTaskKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerTaskKind* New() const final {
    return CreateMaybeMessage<WorkerTaskKind>(nullptr);
  }

  WorkerTaskKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerTaskKind>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerTaskKind& from);
  void MergeFrom(const WorkerTaskKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerTaskKind* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerTaskKind";
  }
  protected:
  explicit WorkerTaskKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildImprovementFieldNumber = 1,
  };
  // .WorkerTaskImprovement buildImprovement = 1;
  bool has_buildimprovement() const;
  private:
  bool _internal_has_buildimprovement() const;
  public:
  void clear_buildimprovement();
  const ::WorkerTaskImprovement& buildimprovement() const;
  ::WorkerTaskImprovement* release_buildimprovement();
  ::WorkerTaskImprovement* mutable_buildimprovement();
  void set_allocated_buildimprovement(::WorkerTaskImprovement* buildimprovement);
  private:
  const ::WorkerTaskImprovement& _internal_buildimprovement() const;
  ::WorkerTaskImprovement* _internal_mutable_buildimprovement();
  public:
  void unsafe_arena_set_allocated_buildimprovement(
      ::WorkerTaskImprovement* buildimprovement);
  ::WorkerTaskImprovement* unsafe_arena_release_buildimprovement();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:WorkerTaskKind)
 private:
  class _Internal;
  void set_has_buildimprovement();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    KindUnion() {}
    ::WorkerTaskImprovement* buildimprovement_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerTask) */ {
 public:
  inline WorkerTask() : WorkerTask(nullptr) {};
  virtual ~WorkerTask();

  WorkerTask(const WorkerTask& from);
  WorkerTask(WorkerTask&& from) noexcept
    : WorkerTask() {
    *this = ::std::move(from);
  }

  inline WorkerTask& operator=(const WorkerTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerTask& operator=(WorkerTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerTask* internal_default_instance() {
    return reinterpret_cast<const WorkerTask*>(
               &_WorkerTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(WorkerTask& a, WorkerTask& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerTask* New() const final {
    return CreateMaybeMessage<WorkerTask>(nullptr);
  }

  WorkerTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerTask& from);
  void MergeFrom(const WorkerTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerTask";
  }
  protected:
  explicit WorkerTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKindFieldNumber = 3,
    kTurnsLeftFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .WorkerTaskKind kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const ::WorkerTaskKind& kind() const;
  ::WorkerTaskKind* release_kind();
  ::WorkerTaskKind* mutable_kind();
  void set_allocated_kind(::WorkerTaskKind* kind);
  private:
  const ::WorkerTaskKind& _internal_kind() const;
  ::WorkerTaskKind* _internal_mutable_kind();
  public:
  void unsafe_arena_set_allocated_kind(
      ::WorkerTaskKind* kind);
  ::WorkerTaskKind* unsafe_arena_release_kind();

  // int32 turnsLeft = 2;
  void clear_turnsleft();
  ::PROTOBUF_NAMESPACE_ID::int32 turnsleft() const;
  void set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_turnsleft() const;
  void _internal_set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::WorkerTaskKind* kind_;
  ::PROTOBUF_NAMESPACE_ID::int32 turnsleft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class WorkerCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerCapability) */ {
 public:
  inline WorkerCapability() : WorkerCapability(nullptr) {};
  virtual ~WorkerCapability();

  WorkerCapability(const WorkerCapability& from);
  WorkerCapability(WorkerCapability&& from) noexcept
    : WorkerCapability() {
    *this = ::std::move(from);
  }

  inline WorkerCapability& operator=(const WorkerCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerCapability& operator=(WorkerCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerCapability* internal_default_instance() {
    return reinterpret_cast<const WorkerCapability*>(
               &_WorkerCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(WorkerCapability& a, WorkerCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerCapability* New() const final {
    return CreateMaybeMessage<WorkerCapability>(nullptr);
  }

  WorkerCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerCapability& from);
  void MergeFrom(const WorkerCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerCapability";
  }
  protected:
  explicit WorkerCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPossibleTasksFieldNumber = 2,
    kCurrentTaskFieldNumber = 1,
  };
  // repeated .WorkerTask possibleTasks = 2;
  int possibletasks_size() const;
  private:
  int _internal_possibletasks_size() const;
  public:
  void clear_possibletasks();
  ::WorkerTask* mutable_possibletasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >*
      mutable_possibletasks();
  private:
  const ::WorkerTask& _internal_possibletasks(int index) const;
  ::WorkerTask* _internal_add_possibletasks();
  public:
  const ::WorkerTask& possibletasks(int index) const;
  ::WorkerTask* add_possibletasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >&
      possibletasks() const;

  // .WorkerTask currentTask = 1;
  bool has_currenttask() const;
  private:
  bool _internal_has_currenttask() const;
  public:
  void clear_currenttask();
  const ::WorkerTask& currenttask() const;
  ::WorkerTask* release_currenttask();
  ::WorkerTask* mutable_currenttask();
  void set_allocated_currenttask(::WorkerTask* currenttask);
  private:
  const ::WorkerTask& _internal_currenttask() const;
  ::WorkerTask* _internal_mutable_currenttask();
  public:
  void unsafe_arena_set_allocated_currenttask(
      ::WorkerTask* currenttask);
  ::WorkerTask* unsafe_arena_release_currenttask();

  // @@protoc_insertion_point(class_scope:WorkerCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask > possibletasks_;
  ::WorkerTask* currenttask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class CarryUnitsCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarryUnitsCapability) */ {
 public:
  inline CarryUnitsCapability() : CarryUnitsCapability(nullptr) {};
  virtual ~CarryUnitsCapability();

  CarryUnitsCapability(const CarryUnitsCapability& from);
  CarryUnitsCapability(CarryUnitsCapability&& from) noexcept
    : CarryUnitsCapability() {
    *this = ::std::move(from);
  }

  inline CarryUnitsCapability& operator=(const CarryUnitsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarryUnitsCapability& operator=(CarryUnitsCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarryUnitsCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarryUnitsCapability* internal_default_instance() {
    return reinterpret_cast<const CarryUnitsCapability*>(
               &_CarryUnitsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CarryUnitsCapability& a, CarryUnitsCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(CarryUnitsCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarryUnitsCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarryUnitsCapability* New() const final {
    return CreateMaybeMessage<CarryUnitsCapability>(nullptr);
  }

  CarryUnitsCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarryUnitsCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarryUnitsCapability& from);
  void MergeFrom(const CarryUnitsCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarryUnitsCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarryUnitsCapability";
  }
  protected:
  explicit CarryUnitsCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarryingUnitIDsFieldNumber = 1,
  };
  // repeated int32 carryingUnitIDs = 1;
  int carryingunitids_size() const;
  private:
  int _internal_carryingunitids_size() const;
  public:
  void clear_carryingunitids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_carryingunitids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_carryingunitids() const;
  void _internal_add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_carryingunitids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 carryingunitids(int index) const;
  void set_carryingunitids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      carryingunitids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_carryingunitids();

  // @@protoc_insertion_point(class_scope:CarryUnitsCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > carryingunitids_;
  mutable std::atomic<int> _carryingunitids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class Capability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Capability) */ {
 public:
  inline Capability() : Capability(nullptr) {};
  virtual ~Capability();

  Capability(const Capability& from);
  Capability(Capability&& from) noexcept
    : Capability() {
    *this = ::std::move(from);
  }

  inline Capability& operator=(const Capability& from) {
    CopyFrom(from);
    return *this;
  }
  inline Capability& operator=(Capability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Capability& default_instance();

  enum CapCase {
    kFoundCity = 1,
    kWorker = 2,
    kCarryUnits = 3,
    CAP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capability* internal_default_instance() {
    return reinterpret_cast<const Capability*>(
               &_Capability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Capability& a, Capability& b) {
    a.Swap(&b);
  }
  inline void Swap(Capability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Capability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Capability* New() const final {
    return CreateMaybeMessage<Capability>(nullptr);
  }

  Capability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Capability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Capability& from);
  void MergeFrom(const Capability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Capability";
  }
  protected:
  explicit Capability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFoundCityFieldNumber = 1,
    kWorkerFieldNumber = 2,
    kCarryUnitsFieldNumber = 3,
  };
  // .FoundCityCapability foundCity = 1;
  bool has_foundcity() const;
  private:
  bool _internal_has_foundcity() const;
  public:
  void clear_foundcity();
  const ::FoundCityCapability& foundcity() const;
  ::FoundCityCapability* release_foundcity();
  ::FoundCityCapability* mutable_foundcity();
  void set_allocated_foundcity(::FoundCityCapability* foundcity);
  private:
  const ::FoundCityCapability& _internal_foundcity() const;
  ::FoundCityCapability* _internal_mutable_foundcity();
  public:
  void unsafe_arena_set_allocated_foundcity(
      ::FoundCityCapability* foundcity);
  ::FoundCityCapability* unsafe_arena_release_foundcity();

  // .WorkerCapability worker = 2;
  bool has_worker() const;
  private:
  bool _internal_has_worker() const;
  public:
  void clear_worker();
  const ::WorkerCapability& worker() const;
  ::WorkerCapability* release_worker();
  ::WorkerCapability* mutable_worker();
  void set_allocated_worker(::WorkerCapability* worker);
  private:
  const ::WorkerCapability& _internal_worker() const;
  ::WorkerCapability* _internal_mutable_worker();
  public:
  void unsafe_arena_set_allocated_worker(
      ::WorkerCapability* worker);
  ::WorkerCapability* unsafe_arena_release_worker();

  // .CarryUnitsCapability carryUnits = 3;
  bool has_carryunits() const;
  private:
  bool _internal_has_carryunits() const;
  public:
  void clear_carryunits();
  const ::CarryUnitsCapability& carryunits() const;
  ::CarryUnitsCapability* release_carryunits();
  ::CarryUnitsCapability* mutable_carryunits();
  void set_allocated_carryunits(::CarryUnitsCapability* carryunits);
  private:
  const ::CarryUnitsCapability& _internal_carryunits() const;
  ::CarryUnitsCapability* _internal_mutable_carryunits();
  public:
  void unsafe_arena_set_allocated_carryunits(
      ::CarryUnitsCapability* carryunits);
  ::CarryUnitsCapability* unsafe_arena_release_carryunits();

  void clear_cap();
  CapCase cap_case() const;
  // @@protoc_insertion_point(class_scope:Capability)
 private:
  class _Internal;
  void set_has_foundcity();
  void set_has_worker();
  void set_has_carryunits();

  inline bool has_cap() const;
  inline void clear_has_cap();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CapUnion {
    CapUnion() {}
    ::FoundCityCapability* foundcity_;
    ::WorkerCapability* worker_;
    ::CarryUnitsCapability* carryunits_;
  } cap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdateUnit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateUnit) */ {
 public:
  inline UpdateUnit() : UpdateUnit(nullptr) {};
  virtual ~UpdateUnit();

  UpdateUnit(const UpdateUnit& from);
  UpdateUnit(UpdateUnit&& from) noexcept
    : UpdateUnit() {
    *this = ::std::move(from);
  }

  inline UpdateUnit& operator=(const UpdateUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUnit& operator=(UpdateUnit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateUnit* internal_default_instance() {
    return reinterpret_cast<const UpdateUnit*>(
               &_UpdateUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateUnit& a, UpdateUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUnit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateUnit* New() const final {
    return CreateMaybeMessage<UpdateUnit>(nullptr);
  }

  UpdateUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateUnit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateUnit& from);
  void MergeFrom(const UpdateUnit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateUnit";
  }
  protected:
  explicit UpdateUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 7,
    kKindIDFieldNumber = 2,
    kPosFieldNumber = 1,
    kFollowingPathFieldNumber = 6,
    kHealthFieldNumber = 4,
    kMovementLeftFieldNumber = 5,
    kOwnerIDFieldNumber = 3,
  };
  // repeated .Capability capabilities = 7;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  ::Capability* mutable_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >*
      mutable_capabilities();
  private:
  const ::Capability& _internal_capabilities(int index) const;
  ::Capability* _internal_add_capabilities();
  public:
  const ::Capability& capabilities(int index) const;
  ::Capability* add_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >&
      capabilities() const;

  // string kindID = 2;
  void clear_kindid();
  const std::string& kindid() const;
  void set_kindid(const std::string& value);
  void set_kindid(std::string&& value);
  void set_kindid(const char* value);
  void set_kindid(const char* value, size_t size);
  std::string* mutable_kindid();
  std::string* release_kindid();
  void set_allocated_kindid(std::string* kindid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_kindid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_kindid(
      std::string* kindid);
  private:
  const std::string& _internal_kindid() const;
  void _internal_set_kindid(const std::string& value);
  std::string* _internal_mutable_kindid();
  public:

  // .Pos pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Pos& pos() const;
  ::Pos* release_pos();
  ::Pos* mutable_pos();
  void set_allocated_pos(::Pos* pos);
  private:
  const ::Pos& _internal_pos() const;
  ::Pos* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Pos* pos);
  ::Pos* unsafe_arena_release_pos();

  // .Path followingPath = 6;
  bool has_followingpath() const;
  private:
  bool _internal_has_followingpath() const;
  public:
  void clear_followingpath();
  const ::Path& followingpath() const;
  ::Path* release_followingpath();
  ::Path* mutable_followingpath();
  void set_allocated_followingpath(::Path* followingpath);
  private:
  const ::Path& _internal_followingpath() const;
  ::Path* _internal_mutable_followingpath();
  public:
  void unsafe_arena_set_allocated_followingpath(
      ::Path* followingpath);
  ::Path* unsafe_arena_release_followingpath();

  // double health = 4;
  void clear_health();
  double health() const;
  void set_health(double value);
  private:
  double _internal_health() const;
  void _internal_set_health(double value);
  public:

  // double movementLeft = 5;
  void clear_movementleft();
  double movementleft() const;
  void set_movementleft(double value);
  private:
  double _internal_movementleft() const;
  void _internal_set_movementleft(double value);
  public:

  // int32 ownerID = 3;
  void clear_ownerid();
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid() const;
  void set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ownerid() const;
  void _internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability > capabilities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kindid_;
  ::Pos* pos_;
  ::Path* followingpath_;
  double health_;
  double movementleft_;
  ::PROTOBUF_NAMESPACE_ID::int32 ownerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ResearchingTech PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResearchingTech) */ {
 public:
  inline ResearchingTech() : ResearchingTech(nullptr) {};
  virtual ~ResearchingTech();

  ResearchingTech(const ResearchingTech& from);
  ResearchingTech(ResearchingTech&& from) noexcept
    : ResearchingTech() {
    *this = ::std::move(from);
  }

  inline ResearchingTech& operator=(const ResearchingTech& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResearchingTech& operator=(ResearchingTech&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResearchingTech& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResearchingTech* internal_default_instance() {
    return reinterpret_cast<const ResearchingTech*>(
               &_ResearchingTech_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResearchingTech& a, ResearchingTech& b) {
    a.Swap(&b);
  }
  inline void Swap(ResearchingTech* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResearchingTech* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResearchingTech* New() const final {
    return CreateMaybeMessage<ResearchingTech>(nullptr);
  }

  ResearchingTech* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResearchingTech>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResearchingTech& from);
  void MergeFrom(const ResearchingTech& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResearchingTech* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResearchingTech";
  }
  protected:
  explicit ResearchingTech(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechIDFieldNumber = 1,
    kProgressFieldNumber = 2,
  };
  // string techID = 1;
  void clear_techid();
  const std::string& techid() const;
  void set_techid(const std::string& value);
  void set_techid(std::string&& value);
  void set_techid(const char* value);
  void set_techid(const char* value, size_t size);
  std::string* mutable_techid();
  std::string* release_techid();
  void set_allocated_techid(std::string* techid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_techid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_techid(
      std::string* techid);
  private:
  const std::string& _internal_techid() const;
  void _internal_set_techid(const std::string& value);
  std::string* _internal_mutable_techid();
  public:

  // int32 progress = 2;
  void clear_progress();
  ::PROTOBUF_NAMESPACE_ID::int32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_progress() const;
  void _internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ResearchingTech)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr techid_;
  ::PROTOBUF_NAMESPACE_ID::int32 progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdatePlayer) */ {
 public:
  inline UpdatePlayer() : UpdatePlayer(nullptr) {};
  virtual ~UpdatePlayer();

  UpdatePlayer(const UpdatePlayer& from);
  UpdatePlayer(UpdatePlayer&& from) noexcept
    : UpdatePlayer() {
    *this = ::std::move(from);
  }

  inline UpdatePlayer& operator=(const UpdatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayer& operator=(UpdatePlayer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdatePlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePlayer* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayer*>(
               &_UpdatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdatePlayer& a, UpdatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayer* New() const final {
    return CreateMaybeMessage<UpdatePlayer>(nullptr);
  }

  UpdatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlayer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdatePlayer& from);
  void MergeFrom(const UpdatePlayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdatePlayer";
  }
  protected:
  explicit UpdatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnlockedTechIDsFieldNumber = 11,
    kPossibleResearchesFieldNumber = 12,
    kUsernameFieldNumber = 2,
    kResearchingTechFieldNumber = 9,
    kIDFieldNumber = 1,
    kBaseRevenueFieldNumber = 3,
    kBeakerRevenueFieldNumber = 4,
    kGoldRevenueFieldNumber = 5,
    kExpensesFieldNumber = 6,
    kNetGoldFieldNumber = 7,
    kGoldFieldNumber = 8,
    kCapitalCityIDFieldNumber = 10,
  };
  // repeated string unlockedTechIDs = 11;
  int unlockedtechids_size() const;
  private:
  int _internal_unlockedtechids_size() const;
  public:
  void clear_unlockedtechids();
  const std::string& unlockedtechids(int index) const;
  std::string* mutable_unlockedtechids(int index);
  void set_unlockedtechids(int index, const std::string& value);
  void set_unlockedtechids(int index, std::string&& value);
  void set_unlockedtechids(int index, const char* value);
  void set_unlockedtechids(int index, const char* value, size_t size);
  std::string* add_unlockedtechids();
  void add_unlockedtechids(const std::string& value);
  void add_unlockedtechids(std::string&& value);
  void add_unlockedtechids(const char* value);
  void add_unlockedtechids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unlockedtechids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unlockedtechids();
  private:
  const std::string& _internal_unlockedtechids(int index) const;
  std::string* _internal_add_unlockedtechids();
  public:

  // repeated string possibleResearches = 12;
  int possibleresearches_size() const;
  private:
  int _internal_possibleresearches_size() const;
  public:
  void clear_possibleresearches();
  const std::string& possibleresearches(int index) const;
  std::string* mutable_possibleresearches(int index);
  void set_possibleresearches(int index, const std::string& value);
  void set_possibleresearches(int index, std::string&& value);
  void set_possibleresearches(int index, const char* value);
  void set_possibleresearches(int index, const char* value, size_t size);
  std::string* add_possibleresearches();
  void add_possibleresearches(const std::string& value);
  void add_possibleresearches(std::string&& value);
  void add_possibleresearches(const char* value);
  void add_possibleresearches(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& possibleresearches() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_possibleresearches();
  private:
  const std::string& _internal_possibleresearches(int index) const;
  std::string* _internal_add_possibleresearches();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .ResearchingTech researchingTech = 9;
  bool has_researchingtech() const;
  private:
  bool _internal_has_researchingtech() const;
  public:
  void clear_researchingtech();
  const ::ResearchingTech& researchingtech() const;
  ::ResearchingTech* release_researchingtech();
  ::ResearchingTech* mutable_researchingtech();
  void set_allocated_researchingtech(::ResearchingTech* researchingtech);
  private:
  const ::ResearchingTech& _internal_researchingtech() const;
  ::ResearchingTech* _internal_mutable_researchingtech();
  public:
  void unsafe_arena_set_allocated_researchingtech(
      ::ResearchingTech* researchingtech);
  ::ResearchingTech* unsafe_arena_release_researchingtech();

  // int32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 baseRevenue = 3;
  void clear_baserevenue();
  ::PROTOBUF_NAMESPACE_ID::int32 baserevenue() const;
  void set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_baserevenue() const;
  void _internal_set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 beakerRevenue = 4;
  void clear_beakerrevenue();
  ::PROTOBUF_NAMESPACE_ID::int32 beakerrevenue() const;
  void set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_beakerrevenue() const;
  void _internal_set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 goldRevenue = 5;
  void clear_goldrevenue();
  ::PROTOBUF_NAMESPACE_ID::int32 goldrevenue() const;
  void set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_goldrevenue() const;
  void _internal_set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 expenses = 6;
  void clear_expenses();
  ::PROTOBUF_NAMESPACE_ID::int32 expenses() const;
  void set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_expenses() const;
  void _internal_set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 netGold = 7;
  void clear_netgold();
  ::PROTOBUF_NAMESPACE_ID::int32 netgold() const;
  void set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_netgold() const;
  void _internal_set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 gold = 8;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 capitalCityID = 10;
  void clear_capitalcityid();
  ::PROTOBUF_NAMESPACE_ID::int32 capitalcityid() const;
  void set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_capitalcityid() const;
  void _internal_set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:UpdatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unlockedtechids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> possibleresearches_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::ResearchingTech* researchingtech_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 baserevenue_;
  ::PROTOBUF_NAMESPACE_ID::int32 beakerrevenue_;
  ::PROTOBUF_NAMESPACE_ID::int32 goldrevenue_;
  ::PROTOBUF_NAMESPACE_ID::int32 expenses_;
  ::PROTOBUF_NAMESPACE_ID::int32 netgold_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  ::PROTOBUF_NAMESPACE_ID::int32 capitalcityid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class PathComputed PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PathComputed) */ {
 public:
  inline PathComputed() : PathComputed(nullptr) {};
  virtual ~PathComputed();

  PathComputed(const PathComputed& from);
  PathComputed(PathComputed&& from) noexcept
    : PathComputed() {
    *this = ::std::move(from);
  }

  inline PathComputed& operator=(const PathComputed& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathComputed& operator=(PathComputed&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PathComputed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathComputed* internal_default_instance() {
    return reinterpret_cast<const PathComputed*>(
               &_PathComputed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(PathComputed& a, PathComputed& b) {
    a.Swap(&b);
  }
  inline void Swap(PathComputed* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathComputed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PathComputed* New() const final {
    return CreateMaybeMessage<PathComputed>(nullptr);
  }

  PathComputed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PathComputed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PathComputed& from);
  void MergeFrom(const PathComputed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathComputed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PathComputed";
  }
  protected:
  explicit PathComputed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kPathIDFieldNumber = 1,
  };
  // .Path path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::Path& path() const;
  ::Path* release_path();
  ::Path* mutable_path();
  void set_allocated_path(::Path* path);
  private:
  const ::Path& _internal_path() const;
  ::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::Path* path);
  ::Path* unsafe_arena_release_path();

  // int32 pathID = 1;
  void clear_pathid();
  ::PROTOBUF_NAMESPACE_ID::int32 pathid() const;
  void set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pathid() const;
  void _internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PathComputed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Path* path_;
  ::PROTOBUF_NAMESPACE_ID::int32 pathid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class MoveUnit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MoveUnit) */ {
 public:
  inline MoveUnit() : MoveUnit(nullptr) {};
  virtual ~MoveUnit();

  MoveUnit(const MoveUnit& from);
  MoveUnit(MoveUnit&& from) noexcept
    : MoveUnit() {
    *this = ::std::move(from);
  }

  inline MoveUnit& operator=(const MoveUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveUnit& operator=(MoveUnit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveUnit* internal_default_instance() {
    return reinterpret_cast<const MoveUnit*>(
               &_MoveUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MoveUnit& a, MoveUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveUnit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveUnit* New() const final {
    return CreateMaybeMessage<MoveUnit>(nullptr);
  }

  MoveUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveUnit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveUnit& from);
  void MergeFrom(const MoveUnit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MoveUnit";
  }
  protected:
  explicit MoveUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPosFieldNumber = 2,
    kUnitIDFieldNumber = 1,
  };
  // .Pos newPos = 2;
  bool has_newpos() const;
  private:
  bool _internal_has_newpos() const;
  public:
  void clear_newpos();
  const ::Pos& newpos() const;
  ::Pos* release_newpos();
  ::Pos* mutable_newpos();
  void set_allocated_newpos(::Pos* newpos);
  private:
  const ::Pos& _internal_newpos() const;
  ::Pos* _internal_mutable_newpos();
  public:
  void unsafe_arena_set_allocated_newpos(
      ::Pos* newpos);
  ::Pos* unsafe_arena_release_newpos();

  // int32 unitID = 1;
  void clear_unitid();
  ::PROTOBUF_NAMESPACE_ID::int32 unitid() const;
  void set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_unitid() const;
  void _internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:MoveUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Pos* newpos_;
  ::PROTOBUF_NAMESPACE_ID::int32 unitid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetCityBuildTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetCityBuildTask) */ {
 public:
  inline SetCityBuildTask() : SetCityBuildTask(nullptr) {};
  virtual ~SetCityBuildTask();

  SetCityBuildTask(const SetCityBuildTask& from);
  SetCityBuildTask(SetCityBuildTask&& from) noexcept
    : SetCityBuildTask() {
    *this = ::std::move(from);
  }

  inline SetCityBuildTask& operator=(const SetCityBuildTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCityBuildTask& operator=(SetCityBuildTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetCityBuildTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetCityBuildTask* internal_default_instance() {
    return reinterpret_cast<const SetCityBuildTask*>(
               &_SetCityBuildTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SetCityBuildTask& a, SetCityBuildTask& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCityBuildTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCityBuildTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetCityBuildTask* New() const final {
    return CreateMaybeMessage<SetCityBuildTask>(nullptr);
  }

  SetCityBuildTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetCityBuildTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetCityBuildTask& from);
  void MergeFrom(const SetCityBuildTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCityBuildTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetCityBuildTask";
  }
  protected:
  explicit SetCityBuildTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 2,
    kCityIDFieldNumber = 1,
  };
  // .BuildTaskKind task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::BuildTaskKind& task() const;
  ::BuildTaskKind* release_task();
  ::BuildTaskKind* mutable_task();
  void set_allocated_task(::BuildTaskKind* task);
  private:
  const ::BuildTaskKind& _internal_task() const;
  ::BuildTaskKind* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::BuildTaskKind* task);
  ::BuildTaskKind* unsafe_arena_release_task();

  // int32 cityID = 1;
  void clear_cityid();
  ::PROTOBUF_NAMESPACE_ID::int32 cityid() const;
  void set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cityid() const;
  void _internal_set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SetCityBuildTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::BuildTaskKind* task_;
  ::PROTOBUF_NAMESPACE_ID::int32 cityid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetWorkerTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetWorkerTask) */ {
 public:
  inline SetWorkerTask() : SetWorkerTask(nullptr) {};
  virtual ~SetWorkerTask();

  SetWorkerTask(const SetWorkerTask& from);
  SetWorkerTask(SetWorkerTask&& from) noexcept
    : SetWorkerTask() {
    *this = ::std::move(from);
  }

  inline SetWorkerTask& operator=(const SetWorkerTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetWorkerTask& operator=(SetWorkerTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetWorkerTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetWorkerTask* internal_default_instance() {
    return reinterpret_cast<const SetWorkerTask*>(
               &_SetWorkerTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SetWorkerTask& a, SetWorkerTask& b) {
    a.Swap(&b);
  }
  inline void Swap(SetWorkerTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetWorkerTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetWorkerTask* New() const final {
    return CreateMaybeMessage<SetWorkerTask>(nullptr);
  }

  SetWorkerTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetWorkerTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetWorkerTask& from);
  void MergeFrom(const SetWorkerTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetWorkerTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetWorkerTask";
  }
  protected:
  explicit SetWorkerTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 2,
    kWorkerIDFieldNumber = 1,
  };
  // .WorkerTask task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::WorkerTask& task() const;
  ::WorkerTask* release_task();
  ::WorkerTask* mutable_task();
  void set_allocated_task(::WorkerTask* task);
  private:
  const ::WorkerTask& _internal_task() const;
  ::WorkerTask* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::WorkerTask* task);
  ::WorkerTask* unsafe_arena_release_task();

  // int32 workerID = 1;
  void clear_workerid();
  ::PROTOBUF_NAMESPACE_ID::int32 workerid() const;
  void set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_workerid() const;
  void _internal_set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SetWorkerTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::WorkerTask* task_;
  ::PROTOBUF_NAMESPACE_ID::int32 workerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class ComputePath PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ComputePath) */ {
 public:
  inline ComputePath() : ComputePath(nullptr) {};
  virtual ~ComputePath();

  ComputePath(const ComputePath& from);
  ComputePath(ComputePath&& from) noexcept
    : ComputePath() {
    *this = ::std::move(from);
  }

  inline ComputePath& operator=(const ComputePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputePath& operator=(ComputePath&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ComputePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComputePath* internal_default_instance() {
    return reinterpret_cast<const ComputePath*>(
               &_ComputePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ComputePath& a, ComputePath& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputePath* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComputePath* New() const final {
    return CreateMaybeMessage<ComputePath>(nullptr);
  }

  ComputePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComputePath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ComputePath& from);
  void MergeFrom(const ComputePath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputePath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ComputePath";
  }
  protected:
  explicit ComputePath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kUnitIDFieldNumber = 1,
    kPathIDFieldNumber = 4,
  };
  // .Pos from = 2;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::Pos& from() const;
  ::Pos* release_from();
  ::Pos* mutable_from();
  void set_allocated_from(::Pos* from);
  private:
  const ::Pos& _internal_from() const;
  ::Pos* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::Pos* from);
  ::Pos* unsafe_arena_release_from();

  // .Pos to = 3;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::Pos& to() const;
  ::Pos* release_to();
  ::Pos* mutable_to();
  void set_allocated_to(::Pos* to);
  private:
  const ::Pos& _internal_to() const;
  ::Pos* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::Pos* to);
  ::Pos* unsafe_arena_release_to();

  // int32 unitID = 1;
  void clear_unitid();
  ::PROTOBUF_NAMESPACE_ID::int32 unitid() const;
  void set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_unitid() const;
  void _internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 pathID = 4;
  void clear_pathid();
  ::PROTOBUF_NAMESPACE_ID::int32 pathid() const;
  void set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pathid() const;
  void _internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ComputePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Pos* from_;
  ::Pos* to_;
  ::PROTOBUF_NAMESPACE_ID::int32 unitid_;
  ::PROTOBUF_NAMESPACE_ID::int32 pathid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetEconomySettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetEconomySettings) */ {
 public:
  inline SetEconomySettings() : SetEconomySettings(nullptr) {};
  virtual ~SetEconomySettings();

  SetEconomySettings(const SetEconomySettings& from);
  SetEconomySettings(SetEconomySettings&& from) noexcept
    : SetEconomySettings() {
    *this = ::std::move(from);
  }

  inline SetEconomySettings& operator=(const SetEconomySettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEconomySettings& operator=(SetEconomySettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetEconomySettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetEconomySettings* internal_default_instance() {
    return reinterpret_cast<const SetEconomySettings*>(
               &_SetEconomySettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SetEconomySettings& a, SetEconomySettings& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEconomySettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEconomySettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetEconomySettings* New() const final {
    return CreateMaybeMessage<SetEconomySettings>(nullptr);
  }

  SetEconomySettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetEconomySettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetEconomySettings& from);
  void MergeFrom(const SetEconomySettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEconomySettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetEconomySettings";
  }
  protected:
  explicit SetEconomySettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeakerPercentFieldNumber = 1,
  };
  // int32 beakerPercent = 1;
  void clear_beakerpercent();
  ::PROTOBUF_NAMESPACE_ID::int32 beakerpercent() const;
  void set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_beakerpercent() const;
  void _internal_set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SetEconomySettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 beakerpercent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// -------------------------------------------------------------------

class SetResearch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetResearch) */ {
 public:
  inline SetResearch() : SetResearch(nullptr) {};
  virtual ~SetResearch();

  SetResearch(const SetResearch& from);
  SetResearch(SetResearch&& from) noexcept
    : SetResearch() {
    *this = ::std::move(from);
  }

  inline SetResearch& operator=(const SetResearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResearch& operator=(SetResearch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetResearch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetResearch* internal_default_instance() {
    return reinterpret_cast<const SetResearch*>(
               &_SetResearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SetResearch& a, SetResearch& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResearch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetResearch* New() const final {
    return CreateMaybeMessage<SetResearch>(nullptr);
  }

  SetResearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetResearch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetResearch& from);
  void MergeFrom(const SetResearch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResearch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetResearch";
  }
  protected:
  explicit SetResearch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_riposte_2eproto);
    return ::descriptor_table_riposte_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechIDFieldNumber = 1,
  };
  // string techID = 1;
  void clear_techid();
  const std::string& techid() const;
  void set_techid(const std::string& value);
  void set_techid(std::string&& value);
  void set_techid(const char* value);
  void set_techid(const char* value, size_t size);
  std::string* mutable_techid();
  std::string* release_techid();
  void set_allocated_techid(std::string* techid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_techid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_techid(
      std::string* techid);
  private:
  const std::string& _internal_techid() const;
  void _internal_set_techid(const std::string& value);
  std::string* _internal_mutable_techid();
  public:

  // @@protoc_insertion_point(class_scope:SetResearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr techid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_riposte_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Pos

// uint32 x = 1;
inline void Pos::clear_x() {
  x_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::x() const {
  // @@protoc_insertion_point(field_get:Pos.x)
  return _internal_x();
}
inline void Pos::_internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  x_ = value;
}
inline void Pos::set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Pos.x)
}

// uint32 y = 2;
inline void Pos::clear_y() {
  y_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pos::y() const {
  // @@protoc_insertion_point(field_get:Pos.y)
  return _internal_y();
}
inline void Pos::_internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  y_ = value;
}
inline void Pos::set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Pos.y)
}

// -------------------------------------------------------------------

// AnyClient

// .ClientInfo clientInfo = 1;
inline bool AnyClient::_internal_has_clientinfo() const {
  return packet_case() == kClientInfo;
}
inline bool AnyClient::has_clientinfo() const {
  return _internal_has_clientinfo();
}
inline void AnyClient::set_has_clientinfo() {
  _oneof_case_[0] = kClientInfo;
}
inline void AnyClient::clear_clientinfo() {
  if (_internal_has_clientinfo()) {
    if (GetArena() == nullptr) {
      delete packet_.clientinfo_;
    }
    clear_has_packet();
  }
}
inline ::ClientInfo* AnyClient::release_clientinfo() {
  // @@protoc_insertion_point(field_release:AnyClient.clientInfo)
  if (_internal_has_clientinfo()) {
    clear_has_packet();
      ::ClientInfo* temp = packet_.clientinfo_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.clientinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientInfo& AnyClient::_internal_clientinfo() const {
  return _internal_has_clientinfo()
      ? *packet_.clientinfo_
      : *reinterpret_cast< ::ClientInfo*>(&::_ClientInfo_default_instance_);
}
inline const ::ClientInfo& AnyClient::clientinfo() const {
  // @@protoc_insertion_point(field_get:AnyClient.clientInfo)
  return _internal_clientinfo();
}
inline ::ClientInfo* AnyClient::unsafe_arena_release_clientinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyClient.clientInfo)
  if (_internal_has_clientinfo()) {
    clear_has_packet();
    ::ClientInfo* temp = packet_.clientinfo_;
    packet_.clientinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyClient::unsafe_arena_set_allocated_clientinfo(::ClientInfo* clientinfo) {
  clear_packet();
  if (clientinfo) {
    set_has_clientinfo();
    packet_.clientinfo_ = clientinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyClient.clientInfo)
}
inline ::ClientInfo* AnyClient::_internal_mutable_clientinfo() {
  if (!_internal_has_clientinfo()) {
    clear_packet();
    set_has_clientinfo();
    packet_.clientinfo_ = CreateMaybeMessage< ::ClientInfo >(GetArena());
  }
  return packet_.clientinfo_;
}
inline ::ClientInfo* AnyClient::mutable_clientinfo() {
  // @@protoc_insertion_point(field_mutable:AnyClient.clientInfo)
  return _internal_mutable_clientinfo();
}

inline bool AnyClient::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void AnyClient::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline AnyClient::PacketCase AnyClient::packet_case() const {
  return AnyClient::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnyServer

// .ServerInfo serverInfo = 1;
inline bool AnyServer::_internal_has_serverinfo() const {
  return packet_case() == kServerInfo;
}
inline bool AnyServer::has_serverinfo() const {
  return _internal_has_serverinfo();
}
inline void AnyServer::set_has_serverinfo() {
  _oneof_case_[0] = kServerInfo;
}
inline void AnyServer::clear_serverinfo() {
  if (_internal_has_serverinfo()) {
    if (GetArena() == nullptr) {
      delete packet_.serverinfo_;
    }
    clear_has_packet();
  }
}
inline ::ServerInfo* AnyServer::release_serverinfo() {
  // @@protoc_insertion_point(field_release:AnyServer.serverInfo)
  if (_internal_has_serverinfo()) {
    clear_has_packet();
      ::ServerInfo* temp = packet_.serverinfo_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.serverinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerInfo& AnyServer::_internal_serverinfo() const {
  return _internal_has_serverinfo()
      ? *packet_.serverinfo_
      : *reinterpret_cast< ::ServerInfo*>(&::_ServerInfo_default_instance_);
}
inline const ::ServerInfo& AnyServer::serverinfo() const {
  // @@protoc_insertion_point(field_get:AnyServer.serverInfo)
  return _internal_serverinfo();
}
inline ::ServerInfo* AnyServer::unsafe_arena_release_serverinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.serverInfo)
  if (_internal_has_serverinfo()) {
    clear_has_packet();
    ::ServerInfo* temp = packet_.serverinfo_;
    packet_.serverinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_serverinfo(::ServerInfo* serverinfo) {
  clear_packet();
  if (serverinfo) {
    set_has_serverinfo();
    packet_.serverinfo_ = serverinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.serverInfo)
}
inline ::ServerInfo* AnyServer::_internal_mutable_serverinfo() {
  if (!_internal_has_serverinfo()) {
    clear_packet();
    set_has_serverinfo();
    packet_.serverinfo_ = CreateMaybeMessage< ::ServerInfo >(GetArena());
  }
  return packet_.serverinfo_;
}
inline ::ServerInfo* AnyServer::mutable_serverinfo() {
  // @@protoc_insertion_point(field_mutable:AnyServer.serverInfo)
  return _internal_mutable_serverinfo();
}

// .StartGame startGame = 2;
inline bool AnyServer::_internal_has_startgame() const {
  return packet_case() == kStartGame;
}
inline bool AnyServer::has_startgame() const {
  return _internal_has_startgame();
}
inline void AnyServer::set_has_startgame() {
  _oneof_case_[0] = kStartGame;
}
inline void AnyServer::clear_startgame() {
  if (_internal_has_startgame()) {
    if (GetArena() == nullptr) {
      delete packet_.startgame_;
    }
    clear_has_packet();
  }
}
inline ::StartGame* AnyServer::release_startgame() {
  // @@protoc_insertion_point(field_release:AnyServer.startGame)
  if (_internal_has_startgame()) {
    clear_has_packet();
      ::StartGame* temp = packet_.startgame_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.startgame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StartGame& AnyServer::_internal_startgame() const {
  return _internal_has_startgame()
      ? *packet_.startgame_
      : *reinterpret_cast< ::StartGame*>(&::_StartGame_default_instance_);
}
inline const ::StartGame& AnyServer::startgame() const {
  // @@protoc_insertion_point(field_get:AnyServer.startGame)
  return _internal_startgame();
}
inline ::StartGame* AnyServer::unsafe_arena_release_startgame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.startGame)
  if (_internal_has_startgame()) {
    clear_has_packet();
    ::StartGame* temp = packet_.startgame_;
    packet_.startgame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_startgame(::StartGame* startgame) {
  clear_packet();
  if (startgame) {
    set_has_startgame();
    packet_.startgame_ = startgame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.startGame)
}
inline ::StartGame* AnyServer::_internal_mutable_startgame() {
  if (!_internal_has_startgame()) {
    clear_packet();
    set_has_startgame();
    packet_.startgame_ = CreateMaybeMessage< ::StartGame >(GetArena());
  }
  return packet_.startgame_;
}
inline ::StartGame* AnyServer::mutable_startgame() {
  // @@protoc_insertion_point(field_mutable:AnyServer.startGame)
  return _internal_mutable_startgame();
}

// .LobbyError lobbyError = 3;
inline bool AnyServer::_internal_has_lobbyerror() const {
  return packet_case() == kLobbyError;
}
inline bool AnyServer::has_lobbyerror() const {
  return _internal_has_lobbyerror();
}
inline void AnyServer::set_has_lobbyerror() {
  _oneof_case_[0] = kLobbyError;
}
inline void AnyServer::clear_lobbyerror() {
  if (_internal_has_lobbyerror()) {
    if (GetArena() == nullptr) {
      delete packet_.lobbyerror_;
    }
    clear_has_packet();
  }
}
inline ::LobbyError* AnyServer::release_lobbyerror() {
  // @@protoc_insertion_point(field_release:AnyServer.lobbyError)
  if (_internal_has_lobbyerror()) {
    clear_has_packet();
      ::LobbyError* temp = packet_.lobbyerror_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.lobbyerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LobbyError& AnyServer::_internal_lobbyerror() const {
  return _internal_has_lobbyerror()
      ? *packet_.lobbyerror_
      : *reinterpret_cast< ::LobbyError*>(&::_LobbyError_default_instance_);
}
inline const ::LobbyError& AnyServer::lobbyerror() const {
  // @@protoc_insertion_point(field_get:AnyServer.lobbyError)
  return _internal_lobbyerror();
}
inline ::LobbyError* AnyServer::unsafe_arena_release_lobbyerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.lobbyError)
  if (_internal_has_lobbyerror()) {
    clear_has_packet();
    ::LobbyError* temp = packet_.lobbyerror_;
    packet_.lobbyerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_lobbyerror(::LobbyError* lobbyerror) {
  clear_packet();
  if (lobbyerror) {
    set_has_lobbyerror();
    packet_.lobbyerror_ = lobbyerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.lobbyError)
}
inline ::LobbyError* AnyServer::_internal_mutable_lobbyerror() {
  if (!_internal_has_lobbyerror()) {
    clear_packet();
    set_has_lobbyerror();
    packet_.lobbyerror_ = CreateMaybeMessage< ::LobbyError >(GetArena());
  }
  return packet_.lobbyerror_;
}
inline ::LobbyError* AnyServer::mutable_lobbyerror() {
  // @@protoc_insertion_point(field_mutable:AnyServer.lobbyError)
  return _internal_mutable_lobbyerror();
}

// .UpdateGlobalData updateGlobalData = 4;
inline bool AnyServer::_internal_has_updateglobaldata() const {
  return packet_case() == kUpdateGlobalData;
}
inline bool AnyServer::has_updateglobaldata() const {
  return _internal_has_updateglobaldata();
}
inline void AnyServer::set_has_updateglobaldata() {
  _oneof_case_[0] = kUpdateGlobalData;
}
inline void AnyServer::clear_updateglobaldata() {
  if (_internal_has_updateglobaldata()) {
    if (GetArena() == nullptr) {
      delete packet_.updateglobaldata_;
    }
    clear_has_packet();
  }
}
inline ::UpdateGlobalData* AnyServer::release_updateglobaldata() {
  // @@protoc_insertion_point(field_release:AnyServer.updateGlobalData)
  if (_internal_has_updateglobaldata()) {
    clear_has_packet();
      ::UpdateGlobalData* temp = packet_.updateglobaldata_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updateglobaldata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateGlobalData& AnyServer::_internal_updateglobaldata() const {
  return _internal_has_updateglobaldata()
      ? *packet_.updateglobaldata_
      : *reinterpret_cast< ::UpdateGlobalData*>(&::_UpdateGlobalData_default_instance_);
}
inline const ::UpdateGlobalData& AnyServer::updateglobaldata() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateGlobalData)
  return _internal_updateglobaldata();
}
inline ::UpdateGlobalData* AnyServer::unsafe_arena_release_updateglobaldata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateGlobalData)
  if (_internal_has_updateglobaldata()) {
    clear_has_packet();
    ::UpdateGlobalData* temp = packet_.updateglobaldata_;
    packet_.updateglobaldata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updateglobaldata(::UpdateGlobalData* updateglobaldata) {
  clear_packet();
  if (updateglobaldata) {
    set_has_updateglobaldata();
    packet_.updateglobaldata_ = updateglobaldata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateGlobalData)
}
inline ::UpdateGlobalData* AnyServer::_internal_mutable_updateglobaldata() {
  if (!_internal_has_updateglobaldata()) {
    clear_packet();
    set_has_updateglobaldata();
    packet_.updateglobaldata_ = CreateMaybeMessage< ::UpdateGlobalData >(GetArena());
  }
  return packet_.updateglobaldata_;
}
inline ::UpdateGlobalData* AnyServer::mutable_updateglobaldata() {
  // @@protoc_insertion_point(field_mutable:AnyServer.updateGlobalData)
  return _internal_mutable_updateglobaldata();
}

// .UpdateMap updateMap = 5;
inline bool AnyServer::_internal_has_updatemap() const {
  return packet_case() == kUpdateMap;
}
inline bool AnyServer::has_updatemap() const {
  return _internal_has_updatemap();
}
inline void AnyServer::set_has_updatemap() {
  _oneof_case_[0] = kUpdateMap;
}
inline void AnyServer::clear_updatemap() {
  if (_internal_has_updatemap()) {
    if (GetArena() == nullptr) {
      delete packet_.updatemap_;
    }
    clear_has_packet();
  }
}
inline ::UpdateMap* AnyServer::release_updatemap() {
  // @@protoc_insertion_point(field_release:AnyServer.updateMap)
  if (_internal_has_updatemap()) {
    clear_has_packet();
      ::UpdateMap* temp = packet_.updatemap_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updatemap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateMap& AnyServer::_internal_updatemap() const {
  return _internal_has_updatemap()
      ? *packet_.updatemap_
      : *reinterpret_cast< ::UpdateMap*>(&::_UpdateMap_default_instance_);
}
inline const ::UpdateMap& AnyServer::updatemap() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateMap)
  return _internal_updatemap();
}
inline ::UpdateMap* AnyServer::unsafe_arena_release_updatemap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateMap)
  if (_internal_has_updatemap()) {
    clear_has_packet();
    ::UpdateMap* temp = packet_.updatemap_;
    packet_.updatemap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updatemap(::UpdateMap* updatemap) {
  clear_packet();
  if (updatemap) {
    set_has_updatemap();
    packet_.updatemap_ = updatemap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateMap)
}
inline ::UpdateMap* AnyServer::_internal_mutable_updatemap() {
  if (!_internal_has_updatemap()) {
    clear_packet();
    set_has_updatemap();
    packet_.updatemap_ = CreateMaybeMessage< ::UpdateMap >(GetArena());
  }
  return packet_.updatemap_;
}
inline ::UpdateMap* AnyServer::mutable_updatemap() {
  // @@protoc_insertion_point(field_mutable:AnyServer.updateMap)
  return _internal_mutable_updatemap();
}

// .UpdateCity updateCity = 6;
inline bool AnyServer::_internal_has_updatecity() const {
  return packet_case() == kUpdateCity;
}
inline bool AnyServer::has_updatecity() const {
  return _internal_has_updatecity();
}
inline void AnyServer::set_has_updatecity() {
  _oneof_case_[0] = kUpdateCity;
}
inline void AnyServer::clear_updatecity() {
  if (_internal_has_updatecity()) {
    if (GetArena() == nullptr) {
      delete packet_.updatecity_;
    }
    clear_has_packet();
  }
}
inline ::UpdateCity* AnyServer::release_updatecity() {
  // @@protoc_insertion_point(field_release:AnyServer.updateCity)
  if (_internal_has_updatecity()) {
    clear_has_packet();
      ::UpdateCity* temp = packet_.updatecity_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updatecity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateCity& AnyServer::_internal_updatecity() const {
  return _internal_has_updatecity()
      ? *packet_.updatecity_
      : *reinterpret_cast< ::UpdateCity*>(&::_UpdateCity_default_instance_);
}
inline const ::UpdateCity& AnyServer::updatecity() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateCity)
  return _internal_updatecity();
}
inline ::UpdateCity* AnyServer::unsafe_arena_release_updatecity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateCity)
  if (_internal_has_updatecity()) {
    clear_has_packet();
    ::UpdateCity* temp = packet_.updatecity_;
    packet_.updatecity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updatecity(::UpdateCity* updatecity) {
  clear_packet();
  if (updatecity) {
    set_has_updatecity();
    packet_.updatecity_ = updatecity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateCity)
}
inline ::UpdateCity* AnyServer::_internal_mutable_updatecity() {
  if (!_internal_has_updatecity()) {
    clear_packet();
    set_has_updatecity();
    packet_.updatecity_ = CreateMaybeMessage< ::UpdateCity >(GetArena());
  }
  return packet_.updatecity_;
}
inline ::UpdateCity* AnyServer::mutable_updatecity() {
  // @@protoc_insertion_point(field_mutable:AnyServer.updateCity)
  return _internal_mutable_updatecity();
}

// .UpdateUnit updateUnit = 7;
inline bool AnyServer::_internal_has_updateunit() const {
  return packet_case() == kUpdateUnit;
}
inline bool AnyServer::has_updateunit() const {
  return _internal_has_updateunit();
}
inline void AnyServer::set_has_updateunit() {
  _oneof_case_[0] = kUpdateUnit;
}
inline void AnyServer::clear_updateunit() {
  if (_internal_has_updateunit()) {
    if (GetArena() == nullptr) {
      delete packet_.updateunit_;
    }
    clear_has_packet();
  }
}
inline ::UpdateUnit* AnyServer::release_updateunit() {
  // @@protoc_insertion_point(field_release:AnyServer.updateUnit)
  if (_internal_has_updateunit()) {
    clear_has_packet();
      ::UpdateUnit* temp = packet_.updateunit_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updateunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateUnit& AnyServer::_internal_updateunit() const {
  return _internal_has_updateunit()
      ? *packet_.updateunit_
      : *reinterpret_cast< ::UpdateUnit*>(&::_UpdateUnit_default_instance_);
}
inline const ::UpdateUnit& AnyServer::updateunit() const {
  // @@protoc_insertion_point(field_get:AnyServer.updateUnit)
  return _internal_updateunit();
}
inline ::UpdateUnit* AnyServer::unsafe_arena_release_updateunit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updateUnit)
  if (_internal_has_updateunit()) {
    clear_has_packet();
    ::UpdateUnit* temp = packet_.updateunit_;
    packet_.updateunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updateunit(::UpdateUnit* updateunit) {
  clear_packet();
  if (updateunit) {
    set_has_updateunit();
    packet_.updateunit_ = updateunit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updateUnit)
}
inline ::UpdateUnit* AnyServer::_internal_mutable_updateunit() {
  if (!_internal_has_updateunit()) {
    clear_packet();
    set_has_updateunit();
    packet_.updateunit_ = CreateMaybeMessage< ::UpdateUnit >(GetArena());
  }
  return packet_.updateunit_;
}
inline ::UpdateUnit* AnyServer::mutable_updateunit() {
  // @@protoc_insertion_point(field_mutable:AnyServer.updateUnit)
  return _internal_mutable_updateunit();
}

// .UpdatePlayer updatePlayer = 8;
inline bool AnyServer::_internal_has_updateplayer() const {
  return packet_case() == kUpdatePlayer;
}
inline bool AnyServer::has_updateplayer() const {
  return _internal_has_updateplayer();
}
inline void AnyServer::set_has_updateplayer() {
  _oneof_case_[0] = kUpdatePlayer;
}
inline void AnyServer::clear_updateplayer() {
  if (_internal_has_updateplayer()) {
    if (GetArena() == nullptr) {
      delete packet_.updateplayer_;
    }
    clear_has_packet();
  }
}
inline ::UpdatePlayer* AnyServer::release_updateplayer() {
  // @@protoc_insertion_point(field_release:AnyServer.updatePlayer)
  if (_internal_has_updateplayer()) {
    clear_has_packet();
      ::UpdatePlayer* temp = packet_.updateplayer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.updateplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdatePlayer& AnyServer::_internal_updateplayer() const {
  return _internal_has_updateplayer()
      ? *packet_.updateplayer_
      : *reinterpret_cast< ::UpdatePlayer*>(&::_UpdatePlayer_default_instance_);
}
inline const ::UpdatePlayer& AnyServer::updateplayer() const {
  // @@protoc_insertion_point(field_get:AnyServer.updatePlayer)
  return _internal_updateplayer();
}
inline ::UpdatePlayer* AnyServer::unsafe_arena_release_updateplayer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.updatePlayer)
  if (_internal_has_updateplayer()) {
    clear_has_packet();
    ::UpdatePlayer* temp = packet_.updateplayer_;
    packet_.updateplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_updateplayer(::UpdatePlayer* updateplayer) {
  clear_packet();
  if (updateplayer) {
    set_has_updateplayer();
    packet_.updateplayer_ = updateplayer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.updatePlayer)
}
inline ::UpdatePlayer* AnyServer::_internal_mutable_updateplayer() {
  if (!_internal_has_updateplayer()) {
    clear_packet();
    set_has_updateplayer();
    packet_.updateplayer_ = CreateMaybeMessage< ::UpdatePlayer >(GetArena());
  }
  return packet_.updateplayer_;
}
inline ::UpdatePlayer* AnyServer::mutable_updateplayer() {
  // @@protoc_insertion_point(field_mutable:AnyServer.updatePlayer)
  return _internal_mutable_updateplayer();
}

// .PathComputed pathComputed = 9;
inline bool AnyServer::_internal_has_pathcomputed() const {
  return packet_case() == kPathComputed;
}
inline bool AnyServer::has_pathcomputed() const {
  return _internal_has_pathcomputed();
}
inline void AnyServer::set_has_pathcomputed() {
  _oneof_case_[0] = kPathComputed;
}
inline void AnyServer::clear_pathcomputed() {
  if (_internal_has_pathcomputed()) {
    if (GetArena() == nullptr) {
      delete packet_.pathcomputed_;
    }
    clear_has_packet();
  }
}
inline ::PathComputed* AnyServer::release_pathcomputed() {
  // @@protoc_insertion_point(field_release:AnyServer.pathComputed)
  if (_internal_has_pathcomputed()) {
    clear_has_packet();
      ::PathComputed* temp = packet_.pathcomputed_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.pathcomputed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PathComputed& AnyServer::_internal_pathcomputed() const {
  return _internal_has_pathcomputed()
      ? *packet_.pathcomputed_
      : *reinterpret_cast< ::PathComputed*>(&::_PathComputed_default_instance_);
}
inline const ::PathComputed& AnyServer::pathcomputed() const {
  // @@protoc_insertion_point(field_get:AnyServer.pathComputed)
  return _internal_pathcomputed();
}
inline ::PathComputed* AnyServer::unsafe_arena_release_pathcomputed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AnyServer.pathComputed)
  if (_internal_has_pathcomputed()) {
    clear_has_packet();
    ::PathComputed* temp = packet_.pathcomputed_;
    packet_.pathcomputed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyServer::unsafe_arena_set_allocated_pathcomputed(::PathComputed* pathcomputed) {
  clear_packet();
  if (pathcomputed) {
    set_has_pathcomputed();
    packet_.pathcomputed_ = pathcomputed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnyServer.pathComputed)
}
inline ::PathComputed* AnyServer::_internal_mutable_pathcomputed() {
  if (!_internal_has_pathcomputed()) {
    clear_packet();
    set_has_pathcomputed();
    packet_.pathcomputed_ = CreateMaybeMessage< ::PathComputed >(GetArena());
  }
  return packet_.pathcomputed_;
}
inline ::PathComputed* AnyServer::mutable_pathcomputed() {
  // @@protoc_insertion_point(field_mutable:AnyServer.pathComputed)
  return _internal_mutable_pathcomputed();
}

inline bool AnyServer::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void AnyServer::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline AnyServer::PacketCase AnyServer::packet_case() const {
  return AnyServer::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientInfo

// string username = 1;
inline void ClientInfo::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientInfo::username() const {
  // @@protoc_insertion_point(field_get:ClientInfo.username)
  return _internal_username();
}
inline void ClientInfo::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:ClientInfo.username)
}
inline std::string* ClientInfo::mutable_username() {
  // @@protoc_insertion_point(field_mutable:ClientInfo.username)
  return _internal_mutable_username();
}
inline const std::string& ClientInfo::_internal_username() const {
  return username_.Get();
}
inline void ClientInfo::_internal_set_username(const std::string& value) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientInfo::set_username(std::string&& value) {
  
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ClientInfo.username)
}
inline void ClientInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ClientInfo.username)
}
inline void ClientInfo::set_username(const char* value,
    size_t size) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ClientInfo.username)
}
inline std::string* ClientInfo::_internal_mutable_username() {
  
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientInfo::release_username() {
  // @@protoc_insertion_point(field_release:ClientInfo.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ClientInfo.username)
}
inline std::string* ClientInfo::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientInfo.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ClientInfo::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    
  } else {
    
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientInfo.username)
}

// -------------------------------------------------------------------

// ServerInfo

// int32 playerID = 1;
inline void ServerInfo::clear_playerid() {
  playerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfo::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfo::playerid() const {
  // @@protoc_insertion_point(field_get:ServerInfo.playerID)
  return _internal_playerid();
}
inline void ServerInfo::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playerid_ = value;
}
inline void ServerInfo::set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:ServerInfo.playerID)
}

// repeated .PlayerInfo currentPlayers = 2;
inline int ServerInfo::_internal_currentplayers_size() const {
  return currentplayers_.size();
}
inline int ServerInfo::currentplayers_size() const {
  return _internal_currentplayers_size();
}
inline void ServerInfo::clear_currentplayers() {
  currentplayers_.Clear();
}
inline ::PlayerInfo* ServerInfo::mutable_currentplayers(int index) {
  // @@protoc_insertion_point(field_mutable:ServerInfo.currentPlayers)
  return currentplayers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
ServerInfo::mutable_currentplayers() {
  // @@protoc_insertion_point(field_mutable_list:ServerInfo.currentPlayers)
  return &currentplayers_;
}
inline const ::PlayerInfo& ServerInfo::_internal_currentplayers(int index) const {
  return currentplayers_.Get(index);
}
inline const ::PlayerInfo& ServerInfo::currentplayers(int index) const {
  // @@protoc_insertion_point(field_get:ServerInfo.currentPlayers)
  return _internal_currentplayers(index);
}
inline ::PlayerInfo* ServerInfo::_internal_add_currentplayers() {
  return currentplayers_.Add();
}
inline ::PlayerInfo* ServerInfo::add_currentplayers() {
  // @@protoc_insertion_point(field_add:ServerInfo.currentPlayers)
  return _internal_add_currentplayers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
ServerInfo::currentplayers() const {
  // @@protoc_insertion_point(field_list:ServerInfo.currentPlayers)
  return currentplayers_;
}

// -------------------------------------------------------------------

// KickPlayer

// int32 ID = 1;
inline void KickPlayer::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KickPlayer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KickPlayer::id() const {
  // @@protoc_insertion_point(field_get:KickPlayer.ID)
  return _internal_id();
}
inline void KickPlayer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void KickPlayer::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:KickPlayer.ID)
}

// string reason = 2;
inline void KickPlayer::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& KickPlayer::reason() const {
  // @@protoc_insertion_point(field_get:KickPlayer.reason)
  return _internal_reason();
}
inline void KickPlayer::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:KickPlayer.reason)
}
inline std::string* KickPlayer::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:KickPlayer.reason)
  return _internal_mutable_reason();
}
inline const std::string& KickPlayer::_internal_reason() const {
  return reason_.Get();
}
inline void KickPlayer::_internal_set_reason(const std::string& value) {
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KickPlayer::set_reason(std::string&& value) {
  
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:KickPlayer.reason)
}
inline void KickPlayer::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:KickPlayer.reason)
}
inline void KickPlayer::set_reason(const char* value,
    size_t size) {
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:KickPlayer.reason)
}
inline std::string* KickPlayer::_internal_mutable_reason() {
  
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KickPlayer::release_reason() {
  // @@protoc_insertion_point(field_release:KickPlayer.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KickPlayer::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:KickPlayer.reason)
}
inline std::string* KickPlayer::unsafe_arena_release_reason() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KickPlayer.reason)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return reason_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void KickPlayer::unsafe_arena_set_allocated_reason(
    std::string* reason) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reason, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KickPlayer.reason)
}

// -------------------------------------------------------------------

// SetLeader

// string civID = 1;
inline void SetLeader::clear_civid() {
  civid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetLeader::civid() const {
  // @@protoc_insertion_point(field_get:SetLeader.civID)
  return _internal_civid();
}
inline void SetLeader::set_civid(const std::string& value) {
  _internal_set_civid(value);
  // @@protoc_insertion_point(field_set:SetLeader.civID)
}
inline std::string* SetLeader::mutable_civid() {
  // @@protoc_insertion_point(field_mutable:SetLeader.civID)
  return _internal_mutable_civid();
}
inline const std::string& SetLeader::_internal_civid() const {
  return civid_.Get();
}
inline void SetLeader::_internal_set_civid(const std::string& value) {
  
  civid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLeader::set_civid(std::string&& value) {
  
  civid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:SetLeader.civID)
}
inline void SetLeader::set_civid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  civid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:SetLeader.civID)
}
inline void SetLeader::set_civid(const char* value,
    size_t size) {
  
  civid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:SetLeader.civID)
}
inline std::string* SetLeader::_internal_mutable_civid() {
  
  return civid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLeader::release_civid() {
  // @@protoc_insertion_point(field_release:SetLeader.civID)
  return civid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLeader::set_allocated_civid(std::string* civid) {
  if (civid != nullptr) {
    
  } else {
    
  }
  civid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), civid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:SetLeader.civID)
}
inline std::string* SetLeader::unsafe_arena_release_civid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SetLeader.civID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return civid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLeader::unsafe_arena_set_allocated_civid(
    std::string* civid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (civid != nullptr) {
    
  } else {
    
  }
  civid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      civid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SetLeader.civID)
}

// string leader = 2;
inline void SetLeader::clear_leader() {
  leader_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetLeader::leader() const {
  // @@protoc_insertion_point(field_get:SetLeader.leader)
  return _internal_leader();
}
inline void SetLeader::set_leader(const std::string& value) {
  _internal_set_leader(value);
  // @@protoc_insertion_point(field_set:SetLeader.leader)
}
inline std::string* SetLeader::mutable_leader() {
  // @@protoc_insertion_point(field_mutable:SetLeader.leader)
  return _internal_mutable_leader();
}
inline const std::string& SetLeader::_internal_leader() const {
  return leader_.Get();
}
inline void SetLeader::_internal_set_leader(const std::string& value) {
  
  leader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLeader::set_leader(std::string&& value) {
  
  leader_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:SetLeader.leader)
}
inline void SetLeader::set_leader(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  leader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:SetLeader.leader)
}
inline void SetLeader::set_leader(const char* value,
    size_t size) {
  
  leader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:SetLeader.leader)
}
inline std::string* SetLeader::_internal_mutable_leader() {
  
  return leader_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLeader::release_leader() {
  // @@protoc_insertion_point(field_release:SetLeader.leader)
  return leader_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLeader::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    
  } else {
    
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:SetLeader.leader)
}
inline std::string* SetLeader::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SetLeader.leader)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return leader_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLeader::unsafe_arena_set_allocated_leader(
    std::string* leader) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (leader != nullptr) {
    
  } else {
    
  }
  leader_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      leader, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SetLeader.leader)
}

// -------------------------------------------------------------------

// AdminStartGame

// -------------------------------------------------------------------

// LobbyError

// string message = 1;
inline void LobbyError::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LobbyError::message() const {
  // @@protoc_insertion_point(field_get:LobbyError.message)
  return _internal_message();
}
inline void LobbyError::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:LobbyError.message)
}
inline std::string* LobbyError::mutable_message() {
  // @@protoc_insertion_point(field_mutable:LobbyError.message)
  return _internal_mutable_message();
}
inline const std::string& LobbyError::_internal_message() const {
  return message_.Get();
}
inline void LobbyError::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LobbyError::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:LobbyError.message)
}
inline void LobbyError::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:LobbyError.message)
}
inline void LobbyError::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:LobbyError.message)
}
inline std::string* LobbyError::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LobbyError::release_message() {
  // @@protoc_insertion_point(field_release:LobbyError.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LobbyError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:LobbyError.message)
}
inline std::string* LobbyError::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:LobbyError.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LobbyError::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LobbyError.message)
}

// -------------------------------------------------------------------

// StartGame

// -------------------------------------------------------------------

// PlayerInfo

// string username = 1;
inline void PlayerInfo::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PlayerInfo::username() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.username)
  return _internal_username();
}
inline void PlayerInfo::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.username)
}
inline std::string* PlayerInfo::mutable_username() {
  // @@protoc_insertion_point(field_mutable:PlayerInfo.username)
  return _internal_mutable_username();
}
inline const std::string& PlayerInfo::_internal_username() const {
  return username_.Get();
}
inline void PlayerInfo::_internal_set_username(const std::string& value) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerInfo::set_username(std::string&& value) {
  
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:PlayerInfo.username)
}
inline void PlayerInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:PlayerInfo.username)
}
inline void PlayerInfo::set_username(const char* value,
    size_t size) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:PlayerInfo.username)
}
inline std::string* PlayerInfo::_internal_mutable_username() {
  
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerInfo::release_username() {
  // @@protoc_insertion_point(field_release:PlayerInfo.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:PlayerInfo.username)
}
inline std::string* PlayerInfo::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PlayerInfo.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PlayerInfo::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    
  } else {
    
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerInfo.username)
}

// string civID = 2;
inline void PlayerInfo::clear_civid() {
  civid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PlayerInfo::civid() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.civID)
  return _internal_civid();
}
inline void PlayerInfo::set_civid(const std::string& value) {
  _internal_set_civid(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.civID)
}
inline std::string* PlayerInfo::mutable_civid() {
  // @@protoc_insertion_point(field_mutable:PlayerInfo.civID)
  return _internal_mutable_civid();
}
inline const std::string& PlayerInfo::_internal_civid() const {
  return civid_.Get();
}
inline void PlayerInfo::_internal_set_civid(const std::string& value) {
  
  civid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerInfo::set_civid(std::string&& value) {
  
  civid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:PlayerInfo.civID)
}
inline void PlayerInfo::set_civid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  civid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:PlayerInfo.civID)
}
inline void PlayerInfo::set_civid(const char* value,
    size_t size) {
  
  civid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:PlayerInfo.civID)
}
inline std::string* PlayerInfo::_internal_mutable_civid() {
  
  return civid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerInfo::release_civid() {
  // @@protoc_insertion_point(field_release:PlayerInfo.civID)
  return civid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerInfo::set_allocated_civid(std::string* civid) {
  if (civid != nullptr) {
    
  } else {
    
  }
  civid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), civid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:PlayerInfo.civID)
}
inline std::string* PlayerInfo::unsafe_arena_release_civid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PlayerInfo.civID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return civid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PlayerInfo::unsafe_arena_set_allocated_civid(
    std::string* civid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (civid != nullptr) {
    
  } else {
    
  }
  civid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      civid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerInfo.civID)
}

// string leaderName = 3;
inline void PlayerInfo::clear_leadername() {
  leadername_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PlayerInfo::leadername() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.leaderName)
  return _internal_leadername();
}
inline void PlayerInfo::set_leadername(const std::string& value) {
  _internal_set_leadername(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.leaderName)
}
inline std::string* PlayerInfo::mutable_leadername() {
  // @@protoc_insertion_point(field_mutable:PlayerInfo.leaderName)
  return _internal_mutable_leadername();
}
inline const std::string& PlayerInfo::_internal_leadername() const {
  return leadername_.Get();
}
inline void PlayerInfo::_internal_set_leadername(const std::string& value) {
  
  leadername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerInfo::set_leadername(std::string&& value) {
  
  leadername_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:PlayerInfo.leaderName)
}
inline void PlayerInfo::set_leadername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  leadername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:PlayerInfo.leaderName)
}
inline void PlayerInfo::set_leadername(const char* value,
    size_t size) {
  
  leadername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:PlayerInfo.leaderName)
}
inline std::string* PlayerInfo::_internal_mutable_leadername() {
  
  return leadername_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerInfo::release_leadername() {
  // @@protoc_insertion_point(field_release:PlayerInfo.leaderName)
  return leadername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerInfo::set_allocated_leadername(std::string* leadername) {
  if (leadername != nullptr) {
    
  } else {
    
  }
  leadername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leadername,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:PlayerInfo.leaderName)
}
inline std::string* PlayerInfo::unsafe_arena_release_leadername() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PlayerInfo.leaderName)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return leadername_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PlayerInfo::unsafe_arena_set_allocated_leadername(
    std::string* leadername) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (leadername != nullptr) {
    
  } else {
    
  }
  leadername_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      leadername, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerInfo.leaderName)
}

// int32 score = 4;
inline void PlayerInfo::clear_score() {
  score_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_score() const {
  return score_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::score() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.score)
  return _internal_score();
}
inline void PlayerInfo::_internal_set_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  score_ = value;
}
inline void PlayerInfo::set_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.score)
}

// int32 id = 5;
inline void PlayerInfo::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.id)
  return _internal_id();
}
inline void PlayerInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void PlayerInfo::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.id)
}

// bool isAdmin = 6;
inline void PlayerInfo::clear_isadmin() {
  isadmin_ = false;
}
inline bool PlayerInfo::_internal_isadmin() const {
  return isadmin_;
}
inline bool PlayerInfo::isadmin() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.isAdmin)
  return _internal_isadmin();
}
inline void PlayerInfo::_internal_set_isadmin(bool value) {
  
  isadmin_ = value;
}
inline void PlayerInfo::set_isadmin(bool value) {
  _internal_set_isadmin(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.isAdmin)
}

// -------------------------------------------------------------------

// UpdateGlobalData

// repeated .PlayerInfo players = 1;
inline int UpdateGlobalData::_internal_players_size() const {
  return players_.size();
}
inline int UpdateGlobalData::players_size() const {
  return _internal_players_size();
}
inline void UpdateGlobalData::clear_players() {
  players_.Clear();
}
inline ::PlayerInfo* UpdateGlobalData::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateGlobalData.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
UpdateGlobalData::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:UpdateGlobalData.players)
  return &players_;
}
inline const ::PlayerInfo& UpdateGlobalData::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::PlayerInfo& UpdateGlobalData::players(int index) const {
  // @@protoc_insertion_point(field_get:UpdateGlobalData.players)
  return _internal_players(index);
}
inline ::PlayerInfo* UpdateGlobalData::_internal_add_players() {
  return players_.Add();
}
inline ::PlayerInfo* UpdateGlobalData::add_players() {
  // @@protoc_insertion_point(field_add:UpdateGlobalData.players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
UpdateGlobalData::players() const {
  // @@protoc_insertion_point(field_list:UpdateGlobalData.players)
  return players_;
}

// int32 turn = 2;
inline void UpdateGlobalData::clear_turn() {
  turn_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateGlobalData::_internal_turn() const {
  return turn_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateGlobalData::turn() const {
  // @@protoc_insertion_point(field_get:UpdateGlobalData.turn)
  return _internal_turn();
}
inline void UpdateGlobalData::_internal_set_turn(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  turn_ = value;
}
inline void UpdateGlobalData::set_turn(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_turn(value);
  // @@protoc_insertion_point(field_set:UpdateGlobalData.turn)
}

// .Era era = 3;
inline void UpdateGlobalData::clear_era() {
  era_ = 0;
}
inline ::Era UpdateGlobalData::_internal_era() const {
  return static_cast< ::Era >(era_);
}
inline ::Era UpdateGlobalData::era() const {
  // @@protoc_insertion_point(field_get:UpdateGlobalData.era)
  return _internal_era();
}
inline void UpdateGlobalData::_internal_set_era(::Era value) {
  
  era_ = value;
}
inline void UpdateGlobalData::set_era(::Era value) {
  _internal_set_era(value);
  // @@protoc_insertion_point(field_set:UpdateGlobalData.era)
}

// -------------------------------------------------------------------

// Improvement

// string id = 1;
inline void Improvement::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Improvement::id() const {
  // @@protoc_insertion_point(field_get:Improvement.id)
  return _internal_id();
}
inline void Improvement::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Improvement.id)
}
inline std::string* Improvement::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Improvement.id)
  return _internal_mutable_id();
}
inline const std::string& Improvement::_internal_id() const {
  return id_.Get();
}
inline void Improvement::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Improvement::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Improvement.id)
}
inline void Improvement::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:Improvement.id)
}
inline void Improvement::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Improvement.id)
}
inline std::string* Improvement::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Improvement::release_id() {
  // @@protoc_insertion_point(field_release:Improvement.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Improvement::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Improvement.id)
}
inline std::string* Improvement::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Improvement.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Improvement::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Improvement.id)
}

// string cottageLevel = 2;
inline void Improvement::clear_cottagelevel() {
  cottagelevel_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Improvement::cottagelevel() const {
  // @@protoc_insertion_point(field_get:Improvement.cottageLevel)
  return _internal_cottagelevel();
}
inline void Improvement::set_cottagelevel(const std::string& value) {
  _internal_set_cottagelevel(value);
  // @@protoc_insertion_point(field_set:Improvement.cottageLevel)
}
inline std::string* Improvement::mutable_cottagelevel() {
  // @@protoc_insertion_point(field_mutable:Improvement.cottageLevel)
  return _internal_mutable_cottagelevel();
}
inline const std::string& Improvement::_internal_cottagelevel() const {
  return cottagelevel_.Get();
}
inline void Improvement::_internal_set_cottagelevel(const std::string& value) {
  
  cottagelevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Improvement::set_cottagelevel(std::string&& value) {
  
  cottagelevel_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Improvement.cottageLevel)
}
inline void Improvement::set_cottagelevel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cottagelevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:Improvement.cottageLevel)
}
inline void Improvement::set_cottagelevel(const char* value,
    size_t size) {
  
  cottagelevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Improvement.cottageLevel)
}
inline std::string* Improvement::_internal_mutable_cottagelevel() {
  
  return cottagelevel_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Improvement::release_cottagelevel() {
  // @@protoc_insertion_point(field_release:Improvement.cottageLevel)
  return cottagelevel_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Improvement::set_allocated_cottagelevel(std::string* cottagelevel) {
  if (cottagelevel != nullptr) {
    
  } else {
    
  }
  cottagelevel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cottagelevel,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Improvement.cottageLevel)
}
inline std::string* Improvement::unsafe_arena_release_cottagelevel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Improvement.cottageLevel)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return cottagelevel_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Improvement::unsafe_arena_set_allocated_cottagelevel(
    std::string* cottagelevel) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (cottagelevel != nullptr) {
    
  } else {
    
  }
  cottagelevel_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      cottagelevel, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Improvement.cottageLevel)
}

// -------------------------------------------------------------------

// Yield

// int32 hammers = 1;
inline void Yield::clear_hammers() {
  hammers_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::_internal_hammers() const {
  return hammers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::hammers() const {
  // @@protoc_insertion_point(field_get:Yield.hammers)
  return _internal_hammers();
}
inline void Yield::_internal_set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hammers_ = value;
}
inline void Yield::set_hammers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hammers(value);
  // @@protoc_insertion_point(field_set:Yield.hammers)
}

// int32 commerce = 2;
inline void Yield::clear_commerce() {
  commerce_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::_internal_commerce() const {
  return commerce_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::commerce() const {
  // @@protoc_insertion_point(field_get:Yield.commerce)
  return _internal_commerce();
}
inline void Yield::_internal_set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  commerce_ = value;
}
inline void Yield::set_commerce(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_commerce(value);
  // @@protoc_insertion_point(field_set:Yield.commerce)
}

// int32 food = 3;
inline void Yield::clear_food() {
  food_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::_internal_food() const {
  return food_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Yield::food() const {
  // @@protoc_insertion_point(field_get:Yield.food)
  return _internal_food();
}
inline void Yield::_internal_set_food(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  food_ = value;
}
inline void Yield::set_food(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_food(value);
  // @@protoc_insertion_point(field_set:Yield.food)
}

// -------------------------------------------------------------------

// Tile

// .Terrain terrain = 1;
inline void Tile::clear_terrain() {
  terrain_ = 0;
}
inline ::Terrain Tile::_internal_terrain() const {
  return static_cast< ::Terrain >(terrain_);
}
inline ::Terrain Tile::terrain() const {
  // @@protoc_insertion_point(field_get:Tile.terrain)
  return _internal_terrain();
}
inline void Tile::_internal_set_terrain(::Terrain value) {
  
  terrain_ = value;
}
inline void Tile::set_terrain(::Terrain value) {
  _internal_set_terrain(value);
  // @@protoc_insertion_point(field_set:Tile.terrain)
}

// bool forested = 2;
inline void Tile::clear_forested() {
  forested_ = false;
}
inline bool Tile::_internal_forested() const {
  return forested_;
}
inline bool Tile::forested() const {
  // @@protoc_insertion_point(field_get:Tile.forested)
  return _internal_forested();
}
inline void Tile::_internal_set_forested(bool value) {
  
  forested_ = value;
}
inline void Tile::set_forested(bool value) {
  _internal_set_forested(value);
  // @@protoc_insertion_point(field_set:Tile.forested)
}

// bool hilled = 3;
inline void Tile::clear_hilled() {
  hilled_ = false;
}
inline bool Tile::_internal_hilled() const {
  return hilled_;
}
inline bool Tile::hilled() const {
  // @@protoc_insertion_point(field_get:Tile.hilled)
  return _internal_hilled();
}
inline void Tile::_internal_set_hilled(bool value) {
  
  hilled_ = value;
}
inline void Tile::set_hilled(bool value) {
  _internal_set_hilled(value);
  // @@protoc_insertion_point(field_set:Tile.hilled)
}

// repeated .Improvement improvements = 4;
inline int Tile::_internal_improvements_size() const {
  return improvements_.size();
}
inline int Tile::improvements_size() const {
  return _internal_improvements_size();
}
inline void Tile::clear_improvements() {
  improvements_.Clear();
}
inline ::Improvement* Tile::mutable_improvements(int index) {
  // @@protoc_insertion_point(field_mutable:Tile.improvements)
  return improvements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >*
Tile::mutable_improvements() {
  // @@protoc_insertion_point(field_mutable_list:Tile.improvements)
  return &improvements_;
}
inline const ::Improvement& Tile::_internal_improvements(int index) const {
  return improvements_.Get(index);
}
inline const ::Improvement& Tile::improvements(int index) const {
  // @@protoc_insertion_point(field_get:Tile.improvements)
  return _internal_improvements(index);
}
inline ::Improvement* Tile::_internal_add_improvements() {
  return improvements_.Add();
}
inline ::Improvement* Tile::add_improvements() {
  // @@protoc_insertion_point(field_add:Tile.improvements)
  return _internal_add_improvements();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Improvement >&
Tile::improvements() const {
  // @@protoc_insertion_point(field_list:Tile.improvements)
  return improvements_;
}

// .Yield yield = 5;
inline bool Tile::_internal_has_yield() const {
  return this != internal_default_instance() && yield_ != nullptr;
}
inline bool Tile::has_yield() const {
  return _internal_has_yield();
}
inline void Tile::clear_yield() {
  if (GetArena() == nullptr && yield_ != nullptr) {
    delete yield_;
  }
  yield_ = nullptr;
}
inline const ::Yield& Tile::_internal_yield() const {
  const ::Yield* p = yield_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Yield*>(
      &::_Yield_default_instance_);
}
inline const ::Yield& Tile::yield() const {
  // @@protoc_insertion_point(field_get:Tile.yield)
  return _internal_yield();
}
inline void Tile::unsafe_arena_set_allocated_yield(
    ::Yield* yield) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(yield_);
  }
  yield_ = yield;
  if (yield) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tile.yield)
}
inline ::Yield* Tile::release_yield() {
  auto temp = unsafe_arena_release_yield();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Yield* Tile::unsafe_arena_release_yield() {
  // @@protoc_insertion_point(field_release:Tile.yield)
  
  ::Yield* temp = yield_;
  yield_ = nullptr;
  return temp;
}
inline ::Yield* Tile::_internal_mutable_yield() {
  
  if (yield_ == nullptr) {
    auto* p = CreateMaybeMessage<::Yield>(GetArena());
    yield_ = p;
  }
  return yield_;
}
inline ::Yield* Tile::mutable_yield() {
  // @@protoc_insertion_point(field_mutable:Tile.yield)
  return _internal_mutable_yield();
}
inline void Tile::set_allocated_yield(::Yield* yield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete yield_;
  }
  if (yield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(yield);
    if (message_arena != submessage_arena) {
      yield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield, submessage_arena);
    }
    
  } else {
    
  }
  yield_ = yield;
  // @@protoc_insertion_point(field_set_allocated:Tile.yield)
}

// int32 ownerID = 6;
inline void Tile::clear_ownerid() {
  ownerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tile::_internal_ownerid() const {
  return ownerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tile::ownerid() const {
  // @@protoc_insertion_point(field_get:Tile.ownerID)
  return _internal_ownerid();
}
inline void Tile::_internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ownerid_ = value;
}
inline void Tile::set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Tile.ownerID)
}

// bool hasOwner = 7;
inline void Tile::clear_hasowner() {
  hasowner_ = false;
}
inline bool Tile::_internal_hasowner() const {
  return hasowner_;
}
inline bool Tile::hasowner() const {
  // @@protoc_insertion_point(field_get:Tile.hasOwner)
  return _internal_hasowner();
}
inline void Tile::_internal_set_hasowner(bool value) {
  
  hasowner_ = value;
}
inline void Tile::set_hasowner(bool value) {
  _internal_set_hasowner(value);
  // @@protoc_insertion_point(field_set:Tile.hasOwner)
}

// -------------------------------------------------------------------

// UpdateMap

// uint32 width = 1;
inline void UpdateMap::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::width() const {
  // @@protoc_insertion_point(field_get:UpdateMap.width)
  return _internal_width();
}
inline void UpdateMap::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void UpdateMap::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:UpdateMap.width)
}

// uint32 height = 2;
inline void UpdateMap::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateMap::height() const {
  // @@protoc_insertion_point(field_get:UpdateMap.height)
  return _internal_height();
}
inline void UpdateMap::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void UpdateMap::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:UpdateMap.height)
}

// repeated .Tile tiles = 3;
inline int UpdateMap::_internal_tiles_size() const {
  return tiles_.size();
}
inline int UpdateMap::tiles_size() const {
  return _internal_tiles_size();
}
inline void UpdateMap::clear_tiles() {
  tiles_.Clear();
}
inline ::Tile* UpdateMap::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateMap.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
UpdateMap::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:UpdateMap.tiles)
  return &tiles_;
}
inline const ::Tile& UpdateMap::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::Tile& UpdateMap::tiles(int index) const {
  // @@protoc_insertion_point(field_get:UpdateMap.tiles)
  return _internal_tiles(index);
}
inline ::Tile* UpdateMap::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::Tile* UpdateMap::add_tiles() {
  // @@protoc_insertion_point(field_add:UpdateMap.tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
UpdateMap::tiles() const {
  // @@protoc_insertion_point(field_list:UpdateMap.tiles)
  return tiles_;
}

// repeated .Visibility visibility = 4;
inline int UpdateMap::_internal_visibility_size() const {
  return visibility_.size();
}
inline int UpdateMap::visibility_size() const {
  return _internal_visibility_size();
}
inline void UpdateMap::clear_visibility() {
  visibility_.Clear();
}
inline ::Visibility UpdateMap::_internal_visibility(int index) const {
  return static_cast< ::Visibility >(visibility_.Get(index));
}
inline ::Visibility UpdateMap::visibility(int index) const {
  // @@protoc_insertion_point(field_get:UpdateMap.visibility)
  return _internal_visibility(index);
}
inline void UpdateMap::set_visibility(int index, ::Visibility value) {
  visibility_.Set(index, value);
  // @@protoc_insertion_point(field_set:UpdateMap.visibility)
}
inline void UpdateMap::_internal_add_visibility(::Visibility value) {
  visibility_.Add(value);
}
inline void UpdateMap::add_visibility(::Visibility value) {
  // @@protoc_insertion_point(field_add:UpdateMap.visibility)
  _internal_add_visibility(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UpdateMap::visibility() const {
  // @@protoc_insertion_point(field_list:UpdateMap.visibility)
  return visibility_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UpdateMap::_internal_mutable_visibility() {
  return &visibility_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UpdateMap::mutable_visibility() {
  // @@protoc_insertion_point(field_mutable_list:UpdateMap.visibility)
  return _internal_mutable_visibility();
}

// -------------------------------------------------------------------

// UnitBuildTask

// string unitKindID = 1;
inline void UnitBuildTask::clear_unitkindid() {
  unitkindid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UnitBuildTask::unitkindid() const {
  // @@protoc_insertion_point(field_get:UnitBuildTask.unitKindID)
  return _internal_unitkindid();
}
inline void UnitBuildTask::set_unitkindid(const std::string& value) {
  _internal_set_unitkindid(value);
  // @@protoc_insertion_point(field_set:UnitBuildTask.unitKindID)
}
inline std::string* UnitBuildTask::mutable_unitkindid() {
  // @@protoc_insertion_point(field_mutable:UnitBuildTask.unitKindID)
  return _internal_mutable_unitkindid();
}
inline const std::string& UnitBuildTask::_internal_unitkindid() const {
  return unitkindid_.Get();
}
inline void UnitBuildTask::_internal_set_unitkindid(const std::string& value) {
  
  unitkindid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitBuildTask::set_unitkindid(std::string&& value) {
  
  unitkindid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UnitBuildTask.unitKindID)
}
inline void UnitBuildTask::set_unitkindid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  unitkindid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UnitBuildTask.unitKindID)
}
inline void UnitBuildTask::set_unitkindid(const char* value,
    size_t size) {
  
  unitkindid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UnitBuildTask.unitKindID)
}
inline std::string* UnitBuildTask::_internal_mutable_unitkindid() {
  
  return unitkindid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitBuildTask::release_unitkindid() {
  // @@protoc_insertion_point(field_release:UnitBuildTask.unitKindID)
  return unitkindid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitBuildTask::set_allocated_unitkindid(std::string* unitkindid) {
  if (unitkindid != nullptr) {
    
  } else {
    
  }
  unitkindid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unitkindid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UnitBuildTask.unitKindID)
}
inline std::string* UnitBuildTask::unsafe_arena_release_unitkindid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UnitBuildTask.unitKindID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return unitkindid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UnitBuildTask::unsafe_arena_set_allocated_unitkindid(
    std::string* unitkindid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (unitkindid != nullptr) {
    
  } else {
    
  }
  unitkindid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      unitkindid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UnitBuildTask.unitKindID)
}

// -------------------------------------------------------------------

// BuildingBuildTask

// string buildingID = 1;
inline void BuildingBuildTask::clear_buildingid() {
  buildingid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BuildingBuildTask::buildingid() const {
  // @@protoc_insertion_point(field_get:BuildingBuildTask.buildingID)
  return _internal_buildingid();
}
inline void BuildingBuildTask::set_buildingid(const std::string& value) {
  _internal_set_buildingid(value);
  // @@protoc_insertion_point(field_set:BuildingBuildTask.buildingID)
}
inline std::string* BuildingBuildTask::mutable_buildingid() {
  // @@protoc_insertion_point(field_mutable:BuildingBuildTask.buildingID)
  return _internal_mutable_buildingid();
}
inline const std::string& BuildingBuildTask::_internal_buildingid() const {
  return buildingid_.Get();
}
inline void BuildingBuildTask::_internal_set_buildingid(const std::string& value) {
  
  buildingid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BuildingBuildTask::set_buildingid(std::string&& value) {
  
  buildingid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:BuildingBuildTask.buildingID)
}
inline void BuildingBuildTask::set_buildingid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  buildingid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:BuildingBuildTask.buildingID)
}
inline void BuildingBuildTask::set_buildingid(const char* value,
    size_t size) {
  
  buildingid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:BuildingBuildTask.buildingID)
}
inline std::string* BuildingBuildTask::_internal_mutable_buildingid() {
  
  return buildingid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BuildingBuildTask::release_buildingid() {
  // @@protoc_insertion_point(field_release:BuildingBuildTask.buildingID)
  return buildingid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BuildingBuildTask::set_allocated_buildingid(std::string* buildingid) {
  if (buildingid != nullptr) {
    
  } else {
    
  }
  buildingid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buildingid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:BuildingBuildTask.buildingID)
}
inline std::string* BuildingBuildTask::unsafe_arena_release_buildingid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BuildingBuildTask.buildingID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return buildingid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BuildingBuildTask::unsafe_arena_set_allocated_buildingid(
    std::string* buildingid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (buildingid != nullptr) {
    
  } else {
    
  }
  buildingid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      buildingid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildingBuildTask.buildingID)
}

// -------------------------------------------------------------------

// BuildTaskKind

// .UnitBuildTask unit = 1;
inline bool BuildTaskKind::_internal_has_unit() const {
  return task_case() == kUnit;
}
inline bool BuildTaskKind::has_unit() const {
  return _internal_has_unit();
}
inline void BuildTaskKind::set_has_unit() {
  _oneof_case_[0] = kUnit;
}
inline void BuildTaskKind::clear_unit() {
  if (_internal_has_unit()) {
    if (GetArena() == nullptr) {
      delete task_.unit_;
    }
    clear_has_task();
  }
}
inline ::UnitBuildTask* BuildTaskKind::release_unit() {
  // @@protoc_insertion_point(field_release:BuildTaskKind.unit)
  if (_internal_has_unit()) {
    clear_has_task();
      ::UnitBuildTask* temp = task_.unit_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UnitBuildTask& BuildTaskKind::_internal_unit() const {
  return _internal_has_unit()
      ? *task_.unit_
      : *reinterpret_cast< ::UnitBuildTask*>(&::_UnitBuildTask_default_instance_);
}
inline const ::UnitBuildTask& BuildTaskKind::unit() const {
  // @@protoc_insertion_point(field_get:BuildTaskKind.unit)
  return _internal_unit();
}
inline ::UnitBuildTask* BuildTaskKind::unsafe_arena_release_unit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BuildTaskKind.unit)
  if (_internal_has_unit()) {
    clear_has_task();
    ::UnitBuildTask* temp = task_.unit_;
    task_.unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuildTaskKind::unsafe_arena_set_allocated_unit(::UnitBuildTask* unit) {
  clear_task();
  if (unit) {
    set_has_unit();
    task_.unit_ = unit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildTaskKind.unit)
}
inline ::UnitBuildTask* BuildTaskKind::_internal_mutable_unit() {
  if (!_internal_has_unit()) {
    clear_task();
    set_has_unit();
    task_.unit_ = CreateMaybeMessage< ::UnitBuildTask >(GetArena());
  }
  return task_.unit_;
}
inline ::UnitBuildTask* BuildTaskKind::mutable_unit() {
  // @@protoc_insertion_point(field_mutable:BuildTaskKind.unit)
  return _internal_mutable_unit();
}

// .BuildingBuildTask building = 2;
inline bool BuildTaskKind::_internal_has_building() const {
  return task_case() == kBuilding;
}
inline bool BuildTaskKind::has_building() const {
  return _internal_has_building();
}
inline void BuildTaskKind::set_has_building() {
  _oneof_case_[0] = kBuilding;
}
inline void BuildTaskKind::clear_building() {
  if (_internal_has_building()) {
    if (GetArena() == nullptr) {
      delete task_.building_;
    }
    clear_has_task();
  }
}
inline ::BuildingBuildTask* BuildTaskKind::release_building() {
  // @@protoc_insertion_point(field_release:BuildTaskKind.building)
  if (_internal_has_building()) {
    clear_has_task();
      ::BuildingBuildTask* temp = task_.building_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.building_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::BuildingBuildTask& BuildTaskKind::_internal_building() const {
  return _internal_has_building()
      ? *task_.building_
      : *reinterpret_cast< ::BuildingBuildTask*>(&::_BuildingBuildTask_default_instance_);
}
inline const ::BuildingBuildTask& BuildTaskKind::building() const {
  // @@protoc_insertion_point(field_get:BuildTaskKind.building)
  return _internal_building();
}
inline ::BuildingBuildTask* BuildTaskKind::unsafe_arena_release_building() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BuildTaskKind.building)
  if (_internal_has_building()) {
    clear_has_task();
    ::BuildingBuildTask* temp = task_.building_;
    task_.building_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuildTaskKind::unsafe_arena_set_allocated_building(::BuildingBuildTask* building) {
  clear_task();
  if (building) {
    set_has_building();
    task_.building_ = building;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildTaskKind.building)
}
inline ::BuildingBuildTask* BuildTaskKind::_internal_mutable_building() {
  if (!_internal_has_building()) {
    clear_task();
    set_has_building();
    task_.building_ = CreateMaybeMessage< ::BuildingBuildTask >(GetArena());
  }
  return task_.building_;
}
inline ::BuildingBuildTask* BuildTaskKind::mutable_building() {
  // @@protoc_insertion_point(field_mutable:BuildTaskKind.building)
  return _internal_mutable_building();
}

inline bool BuildTaskKind::has_task() const {
  return task_case() != TASK_NOT_SET;
}
inline void BuildTaskKind::clear_has_task() {
  _oneof_case_[0] = TASK_NOT_SET;
}
inline BuildTaskKind::TaskCase BuildTaskKind::task_case() const {
  return BuildTaskKind::TaskCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BuildTask

// .BuildTaskKind kind = 1;
inline bool BuildTask::_internal_has_kind() const {
  return this != internal_default_instance() && kind_ != nullptr;
}
inline bool BuildTask::has_kind() const {
  return _internal_has_kind();
}
inline void BuildTask::clear_kind() {
  if (GetArena() == nullptr && kind_ != nullptr) {
    delete kind_;
  }
  kind_ = nullptr;
}
inline const ::BuildTaskKind& BuildTask::_internal_kind() const {
  const ::BuildTaskKind* p = kind_;
  return p != nullptr ? *p : *reinterpret_cast<const ::BuildTaskKind*>(
      &::_BuildTaskKind_default_instance_);
}
inline const ::BuildTaskKind& BuildTask::kind() const {
  // @@protoc_insertion_point(field_get:BuildTask.kind)
  return _internal_kind();
}
inline void BuildTask::unsafe_arena_set_allocated_kind(
    ::BuildTaskKind* kind) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kind_);
  }
  kind_ = kind;
  if (kind) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildTask.kind)
}
inline ::BuildTaskKind* BuildTask::release_kind() {
  auto temp = unsafe_arena_release_kind();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::BuildTaskKind* BuildTask::unsafe_arena_release_kind() {
  // @@protoc_insertion_point(field_release:BuildTask.kind)
  
  ::BuildTaskKind* temp = kind_;
  kind_ = nullptr;
  return temp;
}
inline ::BuildTaskKind* BuildTask::_internal_mutable_kind() {
  
  if (kind_ == nullptr) {
    auto* p = CreateMaybeMessage<::BuildTaskKind>(GetArena());
    kind_ = p;
  }
  return kind_;
}
inline ::BuildTaskKind* BuildTask::mutable_kind() {
  // @@protoc_insertion_point(field_mutable:BuildTask.kind)
  return _internal_mutable_kind();
}
inline void BuildTask::set_allocated_kind(::BuildTaskKind* kind) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete kind_;
  }
  if (kind) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(kind);
    if (message_arena != submessage_arena) {
      kind = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kind, submessage_arena);
    }
    
  } else {
    
  }
  kind_ = kind;
  // @@protoc_insertion_point(field_set_allocated:BuildTask.kind)
}

// int32 progress = 2;
inline void BuildTask::clear_progress() {
  progress_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::_internal_progress() const {
  return progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::progress() const {
  // @@protoc_insertion_point(field_get:BuildTask.progress)
  return _internal_progress();
}
inline void BuildTask::_internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  progress_ = value;
}
inline void BuildTask::set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:BuildTask.progress)
}

// int32 cost = 3;
inline void BuildTask::clear_cost() {
  cost_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::_internal_cost() const {
  return cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildTask::cost() const {
  // @@protoc_insertion_point(field_get:BuildTask.cost)
  return _internal_cost();
}
inline void BuildTask::_internal_set_cost(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cost_ = value;
}
inline void BuildTask::set_cost(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:BuildTask.cost)
}

// -------------------------------------------------------------------

// UpdateCity

// .Pos pos = 1;
inline bool UpdateCity::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool UpdateCity::has_pos() const {
  return _internal_has_pos();
}
inline void UpdateCity::clear_pos() {
  if (GetArena() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::Pos& UpdateCity::_internal_pos() const {
  const ::Pos* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Pos*>(
      &::_Pos_default_instance_);
}
inline const ::Pos& UpdateCity::pos() const {
  // @@protoc_insertion_point(field_get:UpdateCity.pos)
  return _internal_pos();
}
inline void UpdateCity::unsafe_arena_set_allocated_pos(
    ::Pos* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateCity.pos)
}
inline ::Pos* UpdateCity::release_pos() {
  auto temp = unsafe_arena_release_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Pos* UpdateCity::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:UpdateCity.pos)
  
  ::Pos* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::Pos* UpdateCity::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::Pos* UpdateCity::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:UpdateCity.pos)
  return _internal_mutable_pos();
}
inline void UpdateCity::set_allocated_pos(::Pos* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:UpdateCity.pos)
}

// string name = 2;
inline void UpdateCity::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdateCity::name() const {
  // @@protoc_insertion_point(field_get:UpdateCity.name)
  return _internal_name();
}
inline void UpdateCity::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:UpdateCity.name)
}
inline std::string* UpdateCity::mutable_name() {
  // @@protoc_insertion_point(field_mutable:UpdateCity.name)
  return _internal_mutable_name();
}
inline const std::string& UpdateCity::_internal_name() const {
  return name_.Get();
}
inline void UpdateCity::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateCity::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UpdateCity.name)
}
inline void UpdateCity::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UpdateCity.name)
}
inline void UpdateCity::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UpdateCity.name)
}
inline std::string* UpdateCity::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdateCity::release_name() {
  // @@protoc_insertion_point(field_release:UpdateCity.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateCity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UpdateCity.name)
}
inline std::string* UpdateCity::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UpdateCity.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdateCity::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateCity.name)
}

// int32 ownerID = 3;
inline void UpdateCity::clear_ownerid() {
  ownerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_ownerid() const {
  return ownerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::ownerid() const {
  // @@protoc_insertion_point(field_get:UpdateCity.ownerID)
  return _internal_ownerid();
}
inline void UpdateCity::_internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ownerid_ = value;
}
inline void UpdateCity::set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:UpdateCity.ownerID)
}

// .BuildTask buildTask = 4;
inline bool UpdateCity::_internal_has_buildtask() const {
  return this != internal_default_instance() && buildtask_ != nullptr;
}
inline bool UpdateCity::has_buildtask() const {
  return _internal_has_buildtask();
}
inline void UpdateCity::clear_buildtask() {
  if (GetArena() == nullptr && buildtask_ != nullptr) {
    delete buildtask_;
  }
  buildtask_ = nullptr;
}
inline const ::BuildTask& UpdateCity::_internal_buildtask() const {
  const ::BuildTask* p = buildtask_;
  return p != nullptr ? *p : *reinterpret_cast<const ::BuildTask*>(
      &::_BuildTask_default_instance_);
}
inline const ::BuildTask& UpdateCity::buildtask() const {
  // @@protoc_insertion_point(field_get:UpdateCity.buildTask)
  return _internal_buildtask();
}
inline void UpdateCity::unsafe_arena_set_allocated_buildtask(
    ::BuildTask* buildtask) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(buildtask_);
  }
  buildtask_ = buildtask;
  if (buildtask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateCity.buildTask)
}
inline ::BuildTask* UpdateCity::release_buildtask() {
  auto temp = unsafe_arena_release_buildtask();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::BuildTask* UpdateCity::unsafe_arena_release_buildtask() {
  // @@protoc_insertion_point(field_release:UpdateCity.buildTask)
  
  ::BuildTask* temp = buildtask_;
  buildtask_ = nullptr;
  return temp;
}
inline ::BuildTask* UpdateCity::_internal_mutable_buildtask() {
  
  if (buildtask_ == nullptr) {
    auto* p = CreateMaybeMessage<::BuildTask>(GetArena());
    buildtask_ = p;
  }
  return buildtask_;
}
inline ::BuildTask* UpdateCity::mutable_buildtask() {
  // @@protoc_insertion_point(field_mutable:UpdateCity.buildTask)
  return _internal_mutable_buildtask();
}
inline void UpdateCity::set_allocated_buildtask(::BuildTask* buildtask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete buildtask_;
  }
  if (buildtask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(buildtask);
    if (message_arena != submessage_arena) {
      buildtask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildtask, submessage_arena);
    }
    
  } else {
    
  }
  buildtask_ = buildtask;
  // @@protoc_insertion_point(field_set_allocated:UpdateCity.buildTask)
}

// int32 hammersPerTurn = 5;
inline void UpdateCity::clear_hammersperturn() {
  hammersperturn_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_hammersperturn() const {
  return hammersperturn_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::hammersperturn() const {
  // @@protoc_insertion_point(field_get:UpdateCity.hammersPerTurn)
  return _internal_hammersperturn();
}
inline void UpdateCity::_internal_set_hammersperturn(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hammersperturn_ = value;
}
inline void UpdateCity::set_hammersperturn(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hammersperturn(value);
  // @@protoc_insertion_point(field_set:UpdateCity.hammersPerTurn)
}

// int32 culture = 6;
inline void UpdateCity::clear_culture() {
  culture_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_culture() const {
  return culture_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::culture() const {
  // @@protoc_insertion_point(field_get:UpdateCity.culture)
  return _internal_culture();
}
inline void UpdateCity::_internal_set_culture(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  culture_ = value;
}
inline void UpdateCity::set_culture(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_culture(value);
  // @@protoc_insertion_point(field_set:UpdateCity.culture)
}

// int32 cultureNeeded = 7;
inline void UpdateCity::clear_cultureneeded() {
  cultureneeded_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_cultureneeded() const {
  return cultureneeded_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::cultureneeded() const {
  // @@protoc_insertion_point(field_get:UpdateCity.cultureNeeded)
  return _internal_cultureneeded();
}
inline void UpdateCity::_internal_set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cultureneeded_ = value;
}
inline void UpdateCity::set_cultureneeded(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cultureneeded(value);
  // @@protoc_insertion_point(field_set:UpdateCity.cultureNeeded)
}

// int32 ID = 8;
inline void UpdateCity::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateCity::id() const {
  // @@protoc_insertion_point(field_get:UpdateCity.ID)
  return _internal_id();
}
inline void UpdateCity::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void UpdateCity::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:UpdateCity.ID)
}

// repeated string buildingNames = 9;
inline int UpdateCity::_internal_buildingnames_size() const {
  return buildingnames_.size();
}
inline int UpdateCity::buildingnames_size() const {
  return _internal_buildingnames_size();
}
inline void UpdateCity::clear_buildingnames() {
  buildingnames_.Clear();
}
inline std::string* UpdateCity::add_buildingnames() {
  // @@protoc_insertion_point(field_add_mutable:UpdateCity.buildingNames)
  return _internal_add_buildingnames();
}
inline const std::string& UpdateCity::_internal_buildingnames(int index) const {
  return buildingnames_.Get(index);
}
inline const std::string& UpdateCity::buildingnames(int index) const {
  // @@protoc_insertion_point(field_get:UpdateCity.buildingNames)
  return _internal_buildingnames(index);
}
inline std::string* UpdateCity::mutable_buildingnames(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateCity.buildingNames)
  return buildingnames_.Mutable(index);
}
inline void UpdateCity::set_buildingnames(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:UpdateCity.buildingNames)
  buildingnames_.Mutable(index)->assign(value);
}
inline void UpdateCity::set_buildingnames(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:UpdateCity.buildingNames)
  buildingnames_.Mutable(index)->assign(std::move(value));
}
inline void UpdateCity::set_buildingnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buildingnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdateCity.buildingNames)
}
inline void UpdateCity::set_buildingnames(int index, const char* value, size_t size) {
  buildingnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdateCity.buildingNames)
}
inline std::string* UpdateCity::_internal_add_buildingnames() {
  return buildingnames_.Add();
}
inline void UpdateCity::add_buildingnames(const std::string& value) {
  buildingnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:UpdateCity.buildingNames)
}
inline void UpdateCity::add_buildingnames(std::string&& value) {
  buildingnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:UpdateCity.buildingNames)
}
inline void UpdateCity::add_buildingnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buildingnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:UpdateCity.buildingNames)
}
inline void UpdateCity::add_buildingnames(const char* value, size_t size) {
  buildingnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:UpdateCity.buildingNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateCity::buildingnames() const {
  // @@protoc_insertion_point(field_list:UpdateCity.buildingNames)
  return buildingnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateCity::mutable_buildingnames() {
  // @@protoc_insertion_point(field_mutable_list:UpdateCity.buildingNames)
  return &buildingnames_;
}

// -------------------------------------------------------------------

// Path

// repeated uint32 positions = 1;
inline int Path::_internal_positions_size() const {
  return positions_.size();
}
inline int Path::positions_size() const {
  return _internal_positions_size();
}
inline void Path::clear_positions() {
  positions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Path::_internal_positions(int index) const {
  return positions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Path::positions(int index) const {
  // @@protoc_insertion_point(field_get:Path.positions)
  return _internal_positions(index);
}
inline void Path::set_positions(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  positions_.Set(index, value);
  // @@protoc_insertion_point(field_set:Path.positions)
}
inline void Path::_internal_add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  positions_.Add(value);
}
inline void Path::add_positions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_positions(value);
  // @@protoc_insertion_point(field_add:Path.positions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Path::_internal_positions() const {
  return positions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Path::positions() const {
  // @@protoc_insertion_point(field_list:Path.positions)
  return _internal_positions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Path::_internal_mutable_positions() {
  return &positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Path::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:Path.positions)
  return _internal_mutable_positions();
}

// -------------------------------------------------------------------

// FoundCityCapability

// -------------------------------------------------------------------

// WorkerTaskImprovement

// string improvementID = 1;
inline void WorkerTaskImprovement::clear_improvementid() {
  improvementid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkerTaskImprovement::improvementid() const {
  // @@protoc_insertion_point(field_get:WorkerTaskImprovement.improvementID)
  return _internal_improvementid();
}
inline void WorkerTaskImprovement::set_improvementid(const std::string& value) {
  _internal_set_improvementid(value);
  // @@protoc_insertion_point(field_set:WorkerTaskImprovement.improvementID)
}
inline std::string* WorkerTaskImprovement::mutable_improvementid() {
  // @@protoc_insertion_point(field_mutable:WorkerTaskImprovement.improvementID)
  return _internal_mutable_improvementid();
}
inline const std::string& WorkerTaskImprovement::_internal_improvementid() const {
  return improvementid_.Get();
}
inline void WorkerTaskImprovement::_internal_set_improvementid(const std::string& value) {
  
  improvementid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkerTaskImprovement::set_improvementid(std::string&& value) {
  
  improvementid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:WorkerTaskImprovement.improvementID)
}
inline void WorkerTaskImprovement::set_improvementid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  improvementid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:WorkerTaskImprovement.improvementID)
}
inline void WorkerTaskImprovement::set_improvementid(const char* value,
    size_t size) {
  
  improvementid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:WorkerTaskImprovement.improvementID)
}
inline std::string* WorkerTaskImprovement::_internal_mutable_improvementid() {
  
  return improvementid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkerTaskImprovement::release_improvementid() {
  // @@protoc_insertion_point(field_release:WorkerTaskImprovement.improvementID)
  return improvementid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkerTaskImprovement::set_allocated_improvementid(std::string* improvementid) {
  if (improvementid != nullptr) {
    
  } else {
    
  }
  improvementid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), improvementid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:WorkerTaskImprovement.improvementID)
}
inline std::string* WorkerTaskImprovement::unsafe_arena_release_improvementid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:WorkerTaskImprovement.improvementID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return improvementid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkerTaskImprovement::unsafe_arena_set_allocated_improvementid(
    std::string* improvementid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (improvementid != nullptr) {
    
  } else {
    
  }
  improvementid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      improvementid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerTaskImprovement.improvementID)
}

// -------------------------------------------------------------------

// WorkerTaskKind

// .WorkerTaskImprovement buildImprovement = 1;
inline bool WorkerTaskKind::_internal_has_buildimprovement() const {
  return kind_case() == kBuildImprovement;
}
inline bool WorkerTaskKind::has_buildimprovement() const {
  return _internal_has_buildimprovement();
}
inline void WorkerTaskKind::set_has_buildimprovement() {
  _oneof_case_[0] = kBuildImprovement;
}
inline void WorkerTaskKind::clear_buildimprovement() {
  if (_internal_has_buildimprovement()) {
    if (GetArena() == nullptr) {
      delete kind_.buildimprovement_;
    }
    clear_has_kind();
  }
}
inline ::WorkerTaskImprovement* WorkerTaskKind::release_buildimprovement() {
  // @@protoc_insertion_point(field_release:WorkerTaskKind.buildImprovement)
  if (_internal_has_buildimprovement()) {
    clear_has_kind();
      ::WorkerTaskImprovement* temp = kind_.buildimprovement_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.buildimprovement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::WorkerTaskImprovement& WorkerTaskKind::_internal_buildimprovement() const {
  return _internal_has_buildimprovement()
      ? *kind_.buildimprovement_
      : *reinterpret_cast< ::WorkerTaskImprovement*>(&::_WorkerTaskImprovement_default_instance_);
}
inline const ::WorkerTaskImprovement& WorkerTaskKind::buildimprovement() const {
  // @@protoc_insertion_point(field_get:WorkerTaskKind.buildImprovement)
  return _internal_buildimprovement();
}
inline ::WorkerTaskImprovement* WorkerTaskKind::unsafe_arena_release_buildimprovement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:WorkerTaskKind.buildImprovement)
  if (_internal_has_buildimprovement()) {
    clear_has_kind();
    ::WorkerTaskImprovement* temp = kind_.buildimprovement_;
    kind_.buildimprovement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerTaskKind::unsafe_arena_set_allocated_buildimprovement(::WorkerTaskImprovement* buildimprovement) {
  clear_kind();
  if (buildimprovement) {
    set_has_buildimprovement();
    kind_.buildimprovement_ = buildimprovement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerTaskKind.buildImprovement)
}
inline ::WorkerTaskImprovement* WorkerTaskKind::_internal_mutable_buildimprovement() {
  if (!_internal_has_buildimprovement()) {
    clear_kind();
    set_has_buildimprovement();
    kind_.buildimprovement_ = CreateMaybeMessage< ::WorkerTaskImprovement >(GetArena());
  }
  return kind_.buildimprovement_;
}
inline ::WorkerTaskImprovement* WorkerTaskKind::mutable_buildimprovement() {
  // @@protoc_insertion_point(field_mutable:WorkerTaskKind.buildImprovement)
  return _internal_mutable_buildimprovement();
}

inline bool WorkerTaskKind::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void WorkerTaskKind::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline WorkerTaskKind::KindCase WorkerTaskKind::kind_case() const {
  return WorkerTaskKind::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorkerTask

// string name = 1;
inline void WorkerTask::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkerTask::name() const {
  // @@protoc_insertion_point(field_get:WorkerTask.name)
  return _internal_name();
}
inline void WorkerTask::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:WorkerTask.name)
}
inline std::string* WorkerTask::mutable_name() {
  // @@protoc_insertion_point(field_mutable:WorkerTask.name)
  return _internal_mutable_name();
}
inline const std::string& WorkerTask::_internal_name() const {
  return name_.Get();
}
inline void WorkerTask::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkerTask::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:WorkerTask.name)
}
inline void WorkerTask::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:WorkerTask.name)
}
inline void WorkerTask::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:WorkerTask.name)
}
inline std::string* WorkerTask::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkerTask::release_name() {
  // @@protoc_insertion_point(field_release:WorkerTask.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkerTask::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:WorkerTask.name)
}
inline std::string* WorkerTask::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:WorkerTask.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkerTask::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerTask.name)
}

// int32 turnsLeft = 2;
inline void WorkerTask::clear_turnsleft() {
  turnsleft_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerTask::_internal_turnsleft() const {
  return turnsleft_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerTask::turnsleft() const {
  // @@protoc_insertion_point(field_get:WorkerTask.turnsLeft)
  return _internal_turnsleft();
}
inline void WorkerTask::_internal_set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  turnsleft_ = value;
}
inline void WorkerTask::set_turnsleft(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_turnsleft(value);
  // @@protoc_insertion_point(field_set:WorkerTask.turnsLeft)
}

// .WorkerTaskKind kind = 3;
inline bool WorkerTask::_internal_has_kind() const {
  return this != internal_default_instance() && kind_ != nullptr;
}
inline bool WorkerTask::has_kind() const {
  return _internal_has_kind();
}
inline void WorkerTask::clear_kind() {
  if (GetArena() == nullptr && kind_ != nullptr) {
    delete kind_;
  }
  kind_ = nullptr;
}
inline const ::WorkerTaskKind& WorkerTask::_internal_kind() const {
  const ::WorkerTaskKind* p = kind_;
  return p != nullptr ? *p : *reinterpret_cast<const ::WorkerTaskKind*>(
      &::_WorkerTaskKind_default_instance_);
}
inline const ::WorkerTaskKind& WorkerTask::kind() const {
  // @@protoc_insertion_point(field_get:WorkerTask.kind)
  return _internal_kind();
}
inline void WorkerTask::unsafe_arena_set_allocated_kind(
    ::WorkerTaskKind* kind) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kind_);
  }
  kind_ = kind;
  if (kind) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerTask.kind)
}
inline ::WorkerTaskKind* WorkerTask::release_kind() {
  auto temp = unsafe_arena_release_kind();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::WorkerTaskKind* WorkerTask::unsafe_arena_release_kind() {
  // @@protoc_insertion_point(field_release:WorkerTask.kind)
  
  ::WorkerTaskKind* temp = kind_;
  kind_ = nullptr;
  return temp;
}
inline ::WorkerTaskKind* WorkerTask::_internal_mutable_kind() {
  
  if (kind_ == nullptr) {
    auto* p = CreateMaybeMessage<::WorkerTaskKind>(GetArena());
    kind_ = p;
  }
  return kind_;
}
inline ::WorkerTaskKind* WorkerTask::mutable_kind() {
  // @@protoc_insertion_point(field_mutable:WorkerTask.kind)
  return _internal_mutable_kind();
}
inline void WorkerTask::set_allocated_kind(::WorkerTaskKind* kind) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete kind_;
  }
  if (kind) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(kind);
    if (message_arena != submessage_arena) {
      kind = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kind, submessage_arena);
    }
    
  } else {
    
  }
  kind_ = kind;
  // @@protoc_insertion_point(field_set_allocated:WorkerTask.kind)
}

// -------------------------------------------------------------------

// WorkerCapability

// .WorkerTask currentTask = 1;
inline bool WorkerCapability::_internal_has_currenttask() const {
  return this != internal_default_instance() && currenttask_ != nullptr;
}
inline bool WorkerCapability::has_currenttask() const {
  return _internal_has_currenttask();
}
inline void WorkerCapability::clear_currenttask() {
  if (GetArena() == nullptr && currenttask_ != nullptr) {
    delete currenttask_;
  }
  currenttask_ = nullptr;
}
inline const ::WorkerTask& WorkerCapability::_internal_currenttask() const {
  const ::WorkerTask* p = currenttask_;
  return p != nullptr ? *p : *reinterpret_cast<const ::WorkerTask*>(
      &::_WorkerTask_default_instance_);
}
inline const ::WorkerTask& WorkerCapability::currenttask() const {
  // @@protoc_insertion_point(field_get:WorkerCapability.currentTask)
  return _internal_currenttask();
}
inline void WorkerCapability::unsafe_arena_set_allocated_currenttask(
    ::WorkerTask* currenttask) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currenttask_);
  }
  currenttask_ = currenttask;
  if (currenttask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerCapability.currentTask)
}
inline ::WorkerTask* WorkerCapability::release_currenttask() {
  auto temp = unsafe_arena_release_currenttask();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::WorkerTask* WorkerCapability::unsafe_arena_release_currenttask() {
  // @@protoc_insertion_point(field_release:WorkerCapability.currentTask)
  
  ::WorkerTask* temp = currenttask_;
  currenttask_ = nullptr;
  return temp;
}
inline ::WorkerTask* WorkerCapability::_internal_mutable_currenttask() {
  
  if (currenttask_ == nullptr) {
    auto* p = CreateMaybeMessage<::WorkerTask>(GetArena());
    currenttask_ = p;
  }
  return currenttask_;
}
inline ::WorkerTask* WorkerCapability::mutable_currenttask() {
  // @@protoc_insertion_point(field_mutable:WorkerCapability.currentTask)
  return _internal_mutable_currenttask();
}
inline void WorkerCapability::set_allocated_currenttask(::WorkerTask* currenttask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete currenttask_;
  }
  if (currenttask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(currenttask);
    if (message_arena != submessage_arena) {
      currenttask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currenttask, submessage_arena);
    }
    
  } else {
    
  }
  currenttask_ = currenttask;
  // @@protoc_insertion_point(field_set_allocated:WorkerCapability.currentTask)
}

// repeated .WorkerTask possibleTasks = 2;
inline int WorkerCapability::_internal_possibletasks_size() const {
  return possibletasks_.size();
}
inline int WorkerCapability::possibletasks_size() const {
  return _internal_possibletasks_size();
}
inline void WorkerCapability::clear_possibletasks() {
  possibletasks_.Clear();
}
inline ::WorkerTask* WorkerCapability::mutable_possibletasks(int index) {
  // @@protoc_insertion_point(field_mutable:WorkerCapability.possibleTasks)
  return possibletasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >*
WorkerCapability::mutable_possibletasks() {
  // @@protoc_insertion_point(field_mutable_list:WorkerCapability.possibleTasks)
  return &possibletasks_;
}
inline const ::WorkerTask& WorkerCapability::_internal_possibletasks(int index) const {
  return possibletasks_.Get(index);
}
inline const ::WorkerTask& WorkerCapability::possibletasks(int index) const {
  // @@protoc_insertion_point(field_get:WorkerCapability.possibleTasks)
  return _internal_possibletasks(index);
}
inline ::WorkerTask* WorkerCapability::_internal_add_possibletasks() {
  return possibletasks_.Add();
}
inline ::WorkerTask* WorkerCapability::add_possibletasks() {
  // @@protoc_insertion_point(field_add:WorkerCapability.possibleTasks)
  return _internal_add_possibletasks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WorkerTask >&
WorkerCapability::possibletasks() const {
  // @@protoc_insertion_point(field_list:WorkerCapability.possibleTasks)
  return possibletasks_;
}

// -------------------------------------------------------------------

// CarryUnitsCapability

// repeated int32 carryingUnitIDs = 1;
inline int CarryUnitsCapability::_internal_carryingunitids_size() const {
  return carryingunitids_.size();
}
inline int CarryUnitsCapability::carryingunitids_size() const {
  return _internal_carryingunitids_size();
}
inline void CarryUnitsCapability::clear_carryingunitids() {
  carryingunitids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CarryUnitsCapability::_internal_carryingunitids(int index) const {
  return carryingunitids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CarryUnitsCapability::carryingunitids(int index) const {
  // @@protoc_insertion_point(field_get:CarryUnitsCapability.carryingUnitIDs)
  return _internal_carryingunitids(index);
}
inline void CarryUnitsCapability::set_carryingunitids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  carryingunitids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CarryUnitsCapability.carryingUnitIDs)
}
inline void CarryUnitsCapability::_internal_add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  carryingunitids_.Add(value);
}
inline void CarryUnitsCapability::add_carryingunitids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_carryingunitids(value);
  // @@protoc_insertion_point(field_add:CarryUnitsCapability.carryingUnitIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CarryUnitsCapability::_internal_carryingunitids() const {
  return carryingunitids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CarryUnitsCapability::carryingunitids() const {
  // @@protoc_insertion_point(field_list:CarryUnitsCapability.carryingUnitIDs)
  return _internal_carryingunitids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CarryUnitsCapability::_internal_mutable_carryingunitids() {
  return &carryingunitids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CarryUnitsCapability::mutable_carryingunitids() {
  // @@protoc_insertion_point(field_mutable_list:CarryUnitsCapability.carryingUnitIDs)
  return _internal_mutable_carryingunitids();
}

// -------------------------------------------------------------------

// Capability

// .FoundCityCapability foundCity = 1;
inline bool Capability::_internal_has_foundcity() const {
  return cap_case() == kFoundCity;
}
inline bool Capability::has_foundcity() const {
  return _internal_has_foundcity();
}
inline void Capability::set_has_foundcity() {
  _oneof_case_[0] = kFoundCity;
}
inline void Capability::clear_foundcity() {
  if (_internal_has_foundcity()) {
    if (GetArena() == nullptr) {
      delete cap_.foundcity_;
    }
    clear_has_cap();
  }
}
inline ::FoundCityCapability* Capability::release_foundcity() {
  // @@protoc_insertion_point(field_release:Capability.foundCity)
  if (_internal_has_foundcity()) {
    clear_has_cap();
      ::FoundCityCapability* temp = cap_.foundcity_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cap_.foundcity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FoundCityCapability& Capability::_internal_foundcity() const {
  return _internal_has_foundcity()
      ? *cap_.foundcity_
      : *reinterpret_cast< ::FoundCityCapability*>(&::_FoundCityCapability_default_instance_);
}
inline const ::FoundCityCapability& Capability::foundcity() const {
  // @@protoc_insertion_point(field_get:Capability.foundCity)
  return _internal_foundcity();
}
inline ::FoundCityCapability* Capability::unsafe_arena_release_foundcity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Capability.foundCity)
  if (_internal_has_foundcity()) {
    clear_has_cap();
    ::FoundCityCapability* temp = cap_.foundcity_;
    cap_.foundcity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Capability::unsafe_arena_set_allocated_foundcity(::FoundCityCapability* foundcity) {
  clear_cap();
  if (foundcity) {
    set_has_foundcity();
    cap_.foundcity_ = foundcity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Capability.foundCity)
}
inline ::FoundCityCapability* Capability::_internal_mutable_foundcity() {
  if (!_internal_has_foundcity()) {
    clear_cap();
    set_has_foundcity();
    cap_.foundcity_ = CreateMaybeMessage< ::FoundCityCapability >(GetArena());
  }
  return cap_.foundcity_;
}
inline ::FoundCityCapability* Capability::mutable_foundcity() {
  // @@protoc_insertion_point(field_mutable:Capability.foundCity)
  return _internal_mutable_foundcity();
}

// .WorkerCapability worker = 2;
inline bool Capability::_internal_has_worker() const {
  return cap_case() == kWorker;
}
inline bool Capability::has_worker() const {
  return _internal_has_worker();
}
inline void Capability::set_has_worker() {
  _oneof_case_[0] = kWorker;
}
inline void Capability::clear_worker() {
  if (_internal_has_worker()) {
    if (GetArena() == nullptr) {
      delete cap_.worker_;
    }
    clear_has_cap();
  }
}
inline ::WorkerCapability* Capability::release_worker() {
  // @@protoc_insertion_point(field_release:Capability.worker)
  if (_internal_has_worker()) {
    clear_has_cap();
      ::WorkerCapability* temp = cap_.worker_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cap_.worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::WorkerCapability& Capability::_internal_worker() const {
  return _internal_has_worker()
      ? *cap_.worker_
      : *reinterpret_cast< ::WorkerCapability*>(&::_WorkerCapability_default_instance_);
}
inline const ::WorkerCapability& Capability::worker() const {
  // @@protoc_insertion_point(field_get:Capability.worker)
  return _internal_worker();
}
inline ::WorkerCapability* Capability::unsafe_arena_release_worker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Capability.worker)
  if (_internal_has_worker()) {
    clear_has_cap();
    ::WorkerCapability* temp = cap_.worker_;
    cap_.worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Capability::unsafe_arena_set_allocated_worker(::WorkerCapability* worker) {
  clear_cap();
  if (worker) {
    set_has_worker();
    cap_.worker_ = worker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Capability.worker)
}
inline ::WorkerCapability* Capability::_internal_mutable_worker() {
  if (!_internal_has_worker()) {
    clear_cap();
    set_has_worker();
    cap_.worker_ = CreateMaybeMessage< ::WorkerCapability >(GetArena());
  }
  return cap_.worker_;
}
inline ::WorkerCapability* Capability::mutable_worker() {
  // @@protoc_insertion_point(field_mutable:Capability.worker)
  return _internal_mutable_worker();
}

// .CarryUnitsCapability carryUnits = 3;
inline bool Capability::_internal_has_carryunits() const {
  return cap_case() == kCarryUnits;
}
inline bool Capability::has_carryunits() const {
  return _internal_has_carryunits();
}
inline void Capability::set_has_carryunits() {
  _oneof_case_[0] = kCarryUnits;
}
inline void Capability::clear_carryunits() {
  if (_internal_has_carryunits()) {
    if (GetArena() == nullptr) {
      delete cap_.carryunits_;
    }
    clear_has_cap();
  }
}
inline ::CarryUnitsCapability* Capability::release_carryunits() {
  // @@protoc_insertion_point(field_release:Capability.carryUnits)
  if (_internal_has_carryunits()) {
    clear_has_cap();
      ::CarryUnitsCapability* temp = cap_.carryunits_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cap_.carryunits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CarryUnitsCapability& Capability::_internal_carryunits() const {
  return _internal_has_carryunits()
      ? *cap_.carryunits_
      : *reinterpret_cast< ::CarryUnitsCapability*>(&::_CarryUnitsCapability_default_instance_);
}
inline const ::CarryUnitsCapability& Capability::carryunits() const {
  // @@protoc_insertion_point(field_get:Capability.carryUnits)
  return _internal_carryunits();
}
inline ::CarryUnitsCapability* Capability::unsafe_arena_release_carryunits() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Capability.carryUnits)
  if (_internal_has_carryunits()) {
    clear_has_cap();
    ::CarryUnitsCapability* temp = cap_.carryunits_;
    cap_.carryunits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Capability::unsafe_arena_set_allocated_carryunits(::CarryUnitsCapability* carryunits) {
  clear_cap();
  if (carryunits) {
    set_has_carryunits();
    cap_.carryunits_ = carryunits;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Capability.carryUnits)
}
inline ::CarryUnitsCapability* Capability::_internal_mutable_carryunits() {
  if (!_internal_has_carryunits()) {
    clear_cap();
    set_has_carryunits();
    cap_.carryunits_ = CreateMaybeMessage< ::CarryUnitsCapability >(GetArena());
  }
  return cap_.carryunits_;
}
inline ::CarryUnitsCapability* Capability::mutable_carryunits() {
  // @@protoc_insertion_point(field_mutable:Capability.carryUnits)
  return _internal_mutable_carryunits();
}

inline bool Capability::has_cap() const {
  return cap_case() != CAP_NOT_SET;
}
inline void Capability::clear_has_cap() {
  _oneof_case_[0] = CAP_NOT_SET;
}
inline Capability::CapCase Capability::cap_case() const {
  return Capability::CapCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateUnit

// .Pos pos = 1;
inline bool UpdateUnit::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool UpdateUnit::has_pos() const {
  return _internal_has_pos();
}
inline void UpdateUnit::clear_pos() {
  if (GetArena() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::Pos& UpdateUnit::_internal_pos() const {
  const ::Pos* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Pos*>(
      &::_Pos_default_instance_);
}
inline const ::Pos& UpdateUnit::pos() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.pos)
  return _internal_pos();
}
inline void UpdateUnit::unsafe_arena_set_allocated_pos(
    ::Pos* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateUnit.pos)
}
inline ::Pos* UpdateUnit::release_pos() {
  auto temp = unsafe_arena_release_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Pos* UpdateUnit::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:UpdateUnit.pos)
  
  ::Pos* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::Pos* UpdateUnit::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::Pos* UpdateUnit::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:UpdateUnit.pos)
  return _internal_mutable_pos();
}
inline void UpdateUnit::set_allocated_pos(::Pos* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:UpdateUnit.pos)
}

// string kindID = 2;
inline void UpdateUnit::clear_kindid() {
  kindid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdateUnit::kindid() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.kindID)
  return _internal_kindid();
}
inline void UpdateUnit::set_kindid(const std::string& value) {
  _internal_set_kindid(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.kindID)
}
inline std::string* UpdateUnit::mutable_kindid() {
  // @@protoc_insertion_point(field_mutable:UpdateUnit.kindID)
  return _internal_mutable_kindid();
}
inline const std::string& UpdateUnit::_internal_kindid() const {
  return kindid_.Get();
}
inline void UpdateUnit::_internal_set_kindid(const std::string& value) {
  
  kindid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateUnit::set_kindid(std::string&& value) {
  
  kindid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UpdateUnit.kindID)
}
inline void UpdateUnit::set_kindid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  kindid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UpdateUnit.kindID)
}
inline void UpdateUnit::set_kindid(const char* value,
    size_t size) {
  
  kindid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UpdateUnit.kindID)
}
inline std::string* UpdateUnit::_internal_mutable_kindid() {
  
  return kindid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdateUnit::release_kindid() {
  // @@protoc_insertion_point(field_release:UpdateUnit.kindID)
  return kindid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateUnit::set_allocated_kindid(std::string* kindid) {
  if (kindid != nullptr) {
    
  } else {
    
  }
  kindid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kindid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UpdateUnit.kindID)
}
inline std::string* UpdateUnit::unsafe_arena_release_kindid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UpdateUnit.kindID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return kindid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdateUnit::unsafe_arena_set_allocated_kindid(
    std::string* kindid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (kindid != nullptr) {
    
  } else {
    
  }
  kindid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      kindid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateUnit.kindID)
}

// int32 ownerID = 3;
inline void UpdateUnit::clear_ownerid() {
  ownerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateUnit::_internal_ownerid() const {
  return ownerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateUnit::ownerid() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.ownerID)
  return _internal_ownerid();
}
inline void UpdateUnit::_internal_set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ownerid_ = value;
}
inline void UpdateUnit::set_ownerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.ownerID)
}

// double health = 4;
inline void UpdateUnit::clear_health() {
  health_ = 0;
}
inline double UpdateUnit::_internal_health() const {
  return health_;
}
inline double UpdateUnit::health() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.health)
  return _internal_health();
}
inline void UpdateUnit::_internal_set_health(double value) {
  
  health_ = value;
}
inline void UpdateUnit::set_health(double value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.health)
}

// double movementLeft = 5;
inline void UpdateUnit::clear_movementleft() {
  movementleft_ = 0;
}
inline double UpdateUnit::_internal_movementleft() const {
  return movementleft_;
}
inline double UpdateUnit::movementleft() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.movementLeft)
  return _internal_movementleft();
}
inline void UpdateUnit::_internal_set_movementleft(double value) {
  
  movementleft_ = value;
}
inline void UpdateUnit::set_movementleft(double value) {
  _internal_set_movementleft(value);
  // @@protoc_insertion_point(field_set:UpdateUnit.movementLeft)
}

// .Path followingPath = 6;
inline bool UpdateUnit::_internal_has_followingpath() const {
  return this != internal_default_instance() && followingpath_ != nullptr;
}
inline bool UpdateUnit::has_followingpath() const {
  return _internal_has_followingpath();
}
inline void UpdateUnit::clear_followingpath() {
  if (GetArena() == nullptr && followingpath_ != nullptr) {
    delete followingpath_;
  }
  followingpath_ = nullptr;
}
inline const ::Path& UpdateUnit::_internal_followingpath() const {
  const ::Path* p = followingpath_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Path*>(
      &::_Path_default_instance_);
}
inline const ::Path& UpdateUnit::followingpath() const {
  // @@protoc_insertion_point(field_get:UpdateUnit.followingPath)
  return _internal_followingpath();
}
inline void UpdateUnit::unsafe_arena_set_allocated_followingpath(
    ::Path* followingpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(followingpath_);
  }
  followingpath_ = followingpath;
  if (followingpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateUnit.followingPath)
}
inline ::Path* UpdateUnit::release_followingpath() {
  auto temp = unsafe_arena_release_followingpath();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Path* UpdateUnit::unsafe_arena_release_followingpath() {
  // @@protoc_insertion_point(field_release:UpdateUnit.followingPath)
  
  ::Path* temp = followingpath_;
  followingpath_ = nullptr;
  return temp;
}
inline ::Path* UpdateUnit::_internal_mutable_followingpath() {
  
  if (followingpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Path>(GetArena());
    followingpath_ = p;
  }
  return followingpath_;
}
inline ::Path* UpdateUnit::mutable_followingpath() {
  // @@protoc_insertion_point(field_mutable:UpdateUnit.followingPath)
  return _internal_mutable_followingpath();
}
inline void UpdateUnit::set_allocated_followingpath(::Path* followingpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete followingpath_;
  }
  if (followingpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(followingpath);
    if (message_arena != submessage_arena) {
      followingpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, followingpath, submessage_arena);
    }
    
  } else {
    
  }
  followingpath_ = followingpath;
  // @@protoc_insertion_point(field_set_allocated:UpdateUnit.followingPath)
}

// repeated .Capability capabilities = 7;
inline int UpdateUnit::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int UpdateUnit::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void UpdateUnit::clear_capabilities() {
  capabilities_.Clear();
}
inline ::Capability* UpdateUnit::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateUnit.capabilities)
  return capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >*
UpdateUnit::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:UpdateUnit.capabilities)
  return &capabilities_;
}
inline const ::Capability& UpdateUnit::_internal_capabilities(int index) const {
  return capabilities_.Get(index);
}
inline const ::Capability& UpdateUnit::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:UpdateUnit.capabilities)
  return _internal_capabilities(index);
}
inline ::Capability* UpdateUnit::_internal_add_capabilities() {
  return capabilities_.Add();
}
inline ::Capability* UpdateUnit::add_capabilities() {
  // @@protoc_insertion_point(field_add:UpdateUnit.capabilities)
  return _internal_add_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Capability >&
UpdateUnit::capabilities() const {
  // @@protoc_insertion_point(field_list:UpdateUnit.capabilities)
  return capabilities_;
}

// -------------------------------------------------------------------

// ResearchingTech

// string techID = 1;
inline void ResearchingTech::clear_techid() {
  techid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ResearchingTech::techid() const {
  // @@protoc_insertion_point(field_get:ResearchingTech.techID)
  return _internal_techid();
}
inline void ResearchingTech::set_techid(const std::string& value) {
  _internal_set_techid(value);
  // @@protoc_insertion_point(field_set:ResearchingTech.techID)
}
inline std::string* ResearchingTech::mutable_techid() {
  // @@protoc_insertion_point(field_mutable:ResearchingTech.techID)
  return _internal_mutable_techid();
}
inline const std::string& ResearchingTech::_internal_techid() const {
  return techid_.Get();
}
inline void ResearchingTech::_internal_set_techid(const std::string& value) {
  
  techid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResearchingTech::set_techid(std::string&& value) {
  
  techid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ResearchingTech.techID)
}
inline void ResearchingTech::set_techid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  techid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ResearchingTech.techID)
}
inline void ResearchingTech::set_techid(const char* value,
    size_t size) {
  
  techid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ResearchingTech.techID)
}
inline std::string* ResearchingTech::_internal_mutable_techid() {
  
  return techid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResearchingTech::release_techid() {
  // @@protoc_insertion_point(field_release:ResearchingTech.techID)
  return techid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResearchingTech::set_allocated_techid(std::string* techid) {
  if (techid != nullptr) {
    
  } else {
    
  }
  techid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), techid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ResearchingTech.techID)
}
inline std::string* ResearchingTech::unsafe_arena_release_techid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ResearchingTech.techID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return techid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ResearchingTech::unsafe_arena_set_allocated_techid(
    std::string* techid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (techid != nullptr) {
    
  } else {
    
  }
  techid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      techid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ResearchingTech.techID)
}

// int32 progress = 2;
inline void ResearchingTech::clear_progress() {
  progress_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResearchingTech::_internal_progress() const {
  return progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResearchingTech::progress() const {
  // @@protoc_insertion_point(field_get:ResearchingTech.progress)
  return _internal_progress();
}
inline void ResearchingTech::_internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  progress_ = value;
}
inline void ResearchingTech::set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:ResearchingTech.progress)
}

// -------------------------------------------------------------------

// UpdatePlayer

// int32 ID = 1;
inline void UpdatePlayer::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::id() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.ID)
  return _internal_id();
}
inline void UpdatePlayer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void UpdatePlayer::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.ID)
}

// string username = 2;
inline void UpdatePlayer::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdatePlayer::username() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.username)
  return _internal_username();
}
inline void UpdatePlayer::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.username)
}
inline std::string* UpdatePlayer::mutable_username() {
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.username)
  return _internal_mutable_username();
}
inline const std::string& UpdatePlayer::_internal_username() const {
  return username_.Get();
}
inline void UpdatePlayer::_internal_set_username(const std::string& value) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdatePlayer::set_username(std::string&& value) {
  
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UpdatePlayer.username)
}
inline void UpdatePlayer::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UpdatePlayer.username)
}
inline void UpdatePlayer::set_username(const char* value,
    size_t size) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UpdatePlayer.username)
}
inline std::string* UpdatePlayer::_internal_mutable_username() {
  
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdatePlayer::release_username() {
  // @@protoc_insertion_point(field_release:UpdatePlayer.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdatePlayer::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UpdatePlayer.username)
}
inline std::string* UpdatePlayer::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UpdatePlayer.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdatePlayer::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    
  } else {
    
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdatePlayer.username)
}

// int32 baseRevenue = 3;
inline void UpdatePlayer::clear_baserevenue() {
  baserevenue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_baserevenue() const {
  return baserevenue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::baserevenue() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.baseRevenue)
  return _internal_baserevenue();
}
inline void UpdatePlayer::_internal_set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  baserevenue_ = value;
}
inline void UpdatePlayer::set_baserevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_baserevenue(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.baseRevenue)
}

// int32 beakerRevenue = 4;
inline void UpdatePlayer::clear_beakerrevenue() {
  beakerrevenue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_beakerrevenue() const {
  return beakerrevenue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::beakerrevenue() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.beakerRevenue)
  return _internal_beakerrevenue();
}
inline void UpdatePlayer::_internal_set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  beakerrevenue_ = value;
}
inline void UpdatePlayer::set_beakerrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_beakerrevenue(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.beakerRevenue)
}

// int32 goldRevenue = 5;
inline void UpdatePlayer::clear_goldrevenue() {
  goldrevenue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_goldrevenue() const {
  return goldrevenue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::goldrevenue() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.goldRevenue)
  return _internal_goldrevenue();
}
inline void UpdatePlayer::_internal_set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  goldrevenue_ = value;
}
inline void UpdatePlayer::set_goldrevenue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_goldrevenue(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.goldRevenue)
}

// int32 expenses = 6;
inline void UpdatePlayer::clear_expenses() {
  expenses_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_expenses() const {
  return expenses_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::expenses() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.expenses)
  return _internal_expenses();
}
inline void UpdatePlayer::_internal_set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  expenses_ = value;
}
inline void UpdatePlayer::set_expenses(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_expenses(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.expenses)
}

// int32 netGold = 7;
inline void UpdatePlayer::clear_netgold() {
  netgold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_netgold() const {
  return netgold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::netgold() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.netGold)
  return _internal_netgold();
}
inline void UpdatePlayer::_internal_set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  netgold_ = value;
}
inline void UpdatePlayer::set_netgold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_netgold(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.netGold)
}

// int32 gold = 8;
inline void UpdatePlayer::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::gold() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.gold)
  return _internal_gold();
}
inline void UpdatePlayer::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void UpdatePlayer::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.gold)
}

// .ResearchingTech researchingTech = 9;
inline bool UpdatePlayer::_internal_has_researchingtech() const {
  return this != internal_default_instance() && researchingtech_ != nullptr;
}
inline bool UpdatePlayer::has_researchingtech() const {
  return _internal_has_researchingtech();
}
inline void UpdatePlayer::clear_researchingtech() {
  if (GetArena() == nullptr && researchingtech_ != nullptr) {
    delete researchingtech_;
  }
  researchingtech_ = nullptr;
}
inline const ::ResearchingTech& UpdatePlayer::_internal_researchingtech() const {
  const ::ResearchingTech* p = researchingtech_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ResearchingTech*>(
      &::_ResearchingTech_default_instance_);
}
inline const ::ResearchingTech& UpdatePlayer::researchingtech() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.researchingTech)
  return _internal_researchingtech();
}
inline void UpdatePlayer::unsafe_arena_set_allocated_researchingtech(
    ::ResearchingTech* researchingtech) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(researchingtech_);
  }
  researchingtech_ = researchingtech;
  if (researchingtech) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdatePlayer.researchingTech)
}
inline ::ResearchingTech* UpdatePlayer::release_researchingtech() {
  auto temp = unsafe_arena_release_researchingtech();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ResearchingTech* UpdatePlayer::unsafe_arena_release_researchingtech() {
  // @@protoc_insertion_point(field_release:UpdatePlayer.researchingTech)
  
  ::ResearchingTech* temp = researchingtech_;
  researchingtech_ = nullptr;
  return temp;
}
inline ::ResearchingTech* UpdatePlayer::_internal_mutable_researchingtech() {
  
  if (researchingtech_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResearchingTech>(GetArena());
    researchingtech_ = p;
  }
  return researchingtech_;
}
inline ::ResearchingTech* UpdatePlayer::mutable_researchingtech() {
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.researchingTech)
  return _internal_mutable_researchingtech();
}
inline void UpdatePlayer::set_allocated_researchingtech(::ResearchingTech* researchingtech) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete researchingtech_;
  }
  if (researchingtech) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(researchingtech);
    if (message_arena != submessage_arena) {
      researchingtech = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, researchingtech, submessage_arena);
    }
    
  } else {
    
  }
  researchingtech_ = researchingtech;
  // @@protoc_insertion_point(field_set_allocated:UpdatePlayer.researchingTech)
}

// int32 capitalCityID = 10;
inline void UpdatePlayer::clear_capitalcityid() {
  capitalcityid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::_internal_capitalcityid() const {
  return capitalcityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdatePlayer::capitalcityid() const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.capitalCityID)
  return _internal_capitalcityid();
}
inline void UpdatePlayer::_internal_set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  capitalcityid_ = value;
}
inline void UpdatePlayer::set_capitalcityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_capitalcityid(value);
  // @@protoc_insertion_point(field_set:UpdatePlayer.capitalCityID)
}

// repeated string unlockedTechIDs = 11;
inline int UpdatePlayer::_internal_unlockedtechids_size() const {
  return unlockedtechids_.size();
}
inline int UpdatePlayer::unlockedtechids_size() const {
  return _internal_unlockedtechids_size();
}
inline void UpdatePlayer::clear_unlockedtechids() {
  unlockedtechids_.Clear();
}
inline std::string* UpdatePlayer::add_unlockedtechids() {
  // @@protoc_insertion_point(field_add_mutable:UpdatePlayer.unlockedTechIDs)
  return _internal_add_unlockedtechids();
}
inline const std::string& UpdatePlayer::_internal_unlockedtechids(int index) const {
  return unlockedtechids_.Get(index);
}
inline const std::string& UpdatePlayer::unlockedtechids(int index) const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.unlockedTechIDs)
  return _internal_unlockedtechids(index);
}
inline std::string* UpdatePlayer::mutable_unlockedtechids(int index) {
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.unlockedTechIDs)
  return unlockedtechids_.Mutable(index);
}
inline void UpdatePlayer::set_unlockedtechids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:UpdatePlayer.unlockedTechIDs)
  unlockedtechids_.Mutable(index)->assign(value);
}
inline void UpdatePlayer::set_unlockedtechids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:UpdatePlayer.unlockedTechIDs)
  unlockedtechids_.Mutable(index)->assign(std::move(value));
}
inline void UpdatePlayer::set_unlockedtechids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unlockedtechids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::set_unlockedtechids(int index, const char* value, size_t size) {
  unlockedtechids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdatePlayer.unlockedTechIDs)
}
inline std::string* UpdatePlayer::_internal_add_unlockedtechids() {
  return unlockedtechids_.Add();
}
inline void UpdatePlayer::add_unlockedtechids(const std::string& value) {
  unlockedtechids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::add_unlockedtechids(std::string&& value) {
  unlockedtechids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::add_unlockedtechids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unlockedtechids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:UpdatePlayer.unlockedTechIDs)
}
inline void UpdatePlayer::add_unlockedtechids(const char* value, size_t size) {
  unlockedtechids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:UpdatePlayer.unlockedTechIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdatePlayer::unlockedtechids() const {
  // @@protoc_insertion_point(field_list:UpdatePlayer.unlockedTechIDs)
  return unlockedtechids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdatePlayer::mutable_unlockedtechids() {
  // @@protoc_insertion_point(field_mutable_list:UpdatePlayer.unlockedTechIDs)
  return &unlockedtechids_;
}

// repeated string possibleResearches = 12;
inline int UpdatePlayer::_internal_possibleresearches_size() const {
  return possibleresearches_.size();
}
inline int UpdatePlayer::possibleresearches_size() const {
  return _internal_possibleresearches_size();
}
inline void UpdatePlayer::clear_possibleresearches() {
  possibleresearches_.Clear();
}
inline std::string* UpdatePlayer::add_possibleresearches() {
  // @@protoc_insertion_point(field_add_mutable:UpdatePlayer.possibleResearches)
  return _internal_add_possibleresearches();
}
inline const std::string& UpdatePlayer::_internal_possibleresearches(int index) const {
  return possibleresearches_.Get(index);
}
inline const std::string& UpdatePlayer::possibleresearches(int index) const {
  // @@protoc_insertion_point(field_get:UpdatePlayer.possibleResearches)
  return _internal_possibleresearches(index);
}
inline std::string* UpdatePlayer::mutable_possibleresearches(int index) {
  // @@protoc_insertion_point(field_mutable:UpdatePlayer.possibleResearches)
  return possibleresearches_.Mutable(index);
}
inline void UpdatePlayer::set_possibleresearches(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:UpdatePlayer.possibleResearches)
  possibleresearches_.Mutable(index)->assign(value);
}
inline void UpdatePlayer::set_possibleresearches(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:UpdatePlayer.possibleResearches)
  possibleresearches_.Mutable(index)->assign(std::move(value));
}
inline void UpdatePlayer::set_possibleresearches(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  possibleresearches_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::set_possibleresearches(int index, const char* value, size_t size) {
  possibleresearches_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdatePlayer.possibleResearches)
}
inline std::string* UpdatePlayer::_internal_add_possibleresearches() {
  return possibleresearches_.Add();
}
inline void UpdatePlayer::add_possibleresearches(const std::string& value) {
  possibleresearches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::add_possibleresearches(std::string&& value) {
  possibleresearches_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::add_possibleresearches(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  possibleresearches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:UpdatePlayer.possibleResearches)
}
inline void UpdatePlayer::add_possibleresearches(const char* value, size_t size) {
  possibleresearches_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:UpdatePlayer.possibleResearches)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdatePlayer::possibleresearches() const {
  // @@protoc_insertion_point(field_list:UpdatePlayer.possibleResearches)
  return possibleresearches_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdatePlayer::mutable_possibleresearches() {
  // @@protoc_insertion_point(field_mutable_list:UpdatePlayer.possibleResearches)
  return &possibleresearches_;
}

// -------------------------------------------------------------------

// PathComputed

// int32 pathID = 1;
inline void PathComputed::clear_pathid() {
  pathid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PathComputed::_internal_pathid() const {
  return pathid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PathComputed::pathid() const {
  // @@protoc_insertion_point(field_get:PathComputed.pathID)
  return _internal_pathid();
}
inline void PathComputed::_internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pathid_ = value;
}
inline void PathComputed::set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pathid(value);
  // @@protoc_insertion_point(field_set:PathComputed.pathID)
}

// .Path path = 2;
inline bool PathComputed::_internal_has_path() const {
  return this != internal_default_instance() && path_ != nullptr;
}
inline bool PathComputed::has_path() const {
  return _internal_has_path();
}
inline void PathComputed::clear_path() {
  if (GetArena() == nullptr && path_ != nullptr) {
    delete path_;
  }
  path_ = nullptr;
}
inline const ::Path& PathComputed::_internal_path() const {
  const ::Path* p = path_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Path*>(
      &::_Path_default_instance_);
}
inline const ::Path& PathComputed::path() const {
  // @@protoc_insertion_point(field_get:PathComputed.path)
  return _internal_path();
}
inline void PathComputed::unsafe_arena_set_allocated_path(
    ::Path* path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathComputed.path)
}
inline ::Path* PathComputed::release_path() {
  auto temp = unsafe_arena_release_path();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Path* PathComputed::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:PathComputed.path)
  
  ::Path* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::Path* PathComputed::_internal_mutable_path() {
  
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::Path>(GetArena());
    path_ = p;
  }
  return path_;
}
inline ::Path* PathComputed::mutable_path() {
  // @@protoc_insertion_point(field_mutable:PathComputed.path)
  return _internal_mutable_path();
}
inline void PathComputed::set_allocated_path(::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:PathComputed.path)
}

// -------------------------------------------------------------------

// MoveUnit

// int32 unitID = 1;
inline void MoveUnit::clear_unitid() {
  unitid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MoveUnit::_internal_unitid() const {
  return unitid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MoveUnit::unitid() const {
  // @@protoc_insertion_point(field_get:MoveUnit.unitID)
  return _internal_unitid();
}
inline void MoveUnit::_internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  unitid_ = value;
}
inline void MoveUnit::set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_unitid(value);
  // @@protoc_insertion_point(field_set:MoveUnit.unitID)
}

// .Pos newPos = 2;
inline bool MoveUnit::_internal_has_newpos() const {
  return this != internal_default_instance() && newpos_ != nullptr;
}
inline bool MoveUnit::has_newpos() const {
  return _internal_has_newpos();
}
inline void MoveUnit::clear_newpos() {
  if (GetArena() == nullptr && newpos_ != nullptr) {
    delete newpos_;
  }
  newpos_ = nullptr;
}
inline const ::Pos& MoveUnit::_internal_newpos() const {
  const ::Pos* p = newpos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Pos*>(
      &::_Pos_default_instance_);
}
inline const ::Pos& MoveUnit::newpos() const {
  // @@protoc_insertion_point(field_get:MoveUnit.newPos)
  return _internal_newpos();
}
inline void MoveUnit::unsafe_arena_set_allocated_newpos(
    ::Pos* newpos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newpos_);
  }
  newpos_ = newpos;
  if (newpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MoveUnit.newPos)
}
inline ::Pos* MoveUnit::release_newpos() {
  auto temp = unsafe_arena_release_newpos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Pos* MoveUnit::unsafe_arena_release_newpos() {
  // @@protoc_insertion_point(field_release:MoveUnit.newPos)
  
  ::Pos* temp = newpos_;
  newpos_ = nullptr;
  return temp;
}
inline ::Pos* MoveUnit::_internal_mutable_newpos() {
  
  if (newpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArena());
    newpos_ = p;
  }
  return newpos_;
}
inline ::Pos* MoveUnit::mutable_newpos() {
  // @@protoc_insertion_point(field_mutable:MoveUnit.newPos)
  return _internal_mutable_newpos();
}
inline void MoveUnit::set_allocated_newpos(::Pos* newpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete newpos_;
  }
  if (newpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(newpos);
    if (message_arena != submessage_arena) {
      newpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newpos, submessage_arena);
    }
    
  } else {
    
  }
  newpos_ = newpos;
  // @@protoc_insertion_point(field_set_allocated:MoveUnit.newPos)
}

// -------------------------------------------------------------------

// SetCityBuildTask

// int32 cityID = 1;
inline void SetCityBuildTask::clear_cityid() {
  cityid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetCityBuildTask::_internal_cityid() const {
  return cityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetCityBuildTask::cityid() const {
  // @@protoc_insertion_point(field_get:SetCityBuildTask.cityID)
  return _internal_cityid();
}
inline void SetCityBuildTask::_internal_set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cityid_ = value;
}
inline void SetCityBuildTask::set_cityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cityid(value);
  // @@protoc_insertion_point(field_set:SetCityBuildTask.cityID)
}

// .BuildTaskKind task = 2;
inline bool SetCityBuildTask::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool SetCityBuildTask::has_task() const {
  return _internal_has_task();
}
inline void SetCityBuildTask::clear_task() {
  if (GetArena() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::BuildTaskKind& SetCityBuildTask::_internal_task() const {
  const ::BuildTaskKind* p = task_;
  return p != nullptr ? *p : *reinterpret_cast<const ::BuildTaskKind*>(
      &::_BuildTaskKind_default_instance_);
}
inline const ::BuildTaskKind& SetCityBuildTask::task() const {
  // @@protoc_insertion_point(field_get:SetCityBuildTask.task)
  return _internal_task();
}
inline void SetCityBuildTask::unsafe_arena_set_allocated_task(
    ::BuildTaskKind* task) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SetCityBuildTask.task)
}
inline ::BuildTaskKind* SetCityBuildTask::release_task() {
  auto temp = unsafe_arena_release_task();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::BuildTaskKind* SetCityBuildTask::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:SetCityBuildTask.task)
  
  ::BuildTaskKind* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::BuildTaskKind* SetCityBuildTask::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::BuildTaskKind>(GetArena());
    task_ = p;
  }
  return task_;
}
inline ::BuildTaskKind* SetCityBuildTask::mutable_task() {
  // @@protoc_insertion_point(field_mutable:SetCityBuildTask.task)
  return _internal_mutable_task();
}
inline void SetCityBuildTask::set_allocated_task(::BuildTaskKind* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:SetCityBuildTask.task)
}

// -------------------------------------------------------------------

// SetWorkerTask

// int32 workerID = 1;
inline void SetWorkerTask::clear_workerid() {
  workerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetWorkerTask::_internal_workerid() const {
  return workerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetWorkerTask::workerid() const {
  // @@protoc_insertion_point(field_get:SetWorkerTask.workerID)
  return _internal_workerid();
}
inline void SetWorkerTask::_internal_set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  workerid_ = value;
}
inline void SetWorkerTask::set_workerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_workerid(value);
  // @@protoc_insertion_point(field_set:SetWorkerTask.workerID)
}

// .WorkerTask task = 2;
inline bool SetWorkerTask::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool SetWorkerTask::has_task() const {
  return _internal_has_task();
}
inline void SetWorkerTask::clear_task() {
  if (GetArena() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::WorkerTask& SetWorkerTask::_internal_task() const {
  const ::WorkerTask* p = task_;
  return p != nullptr ? *p : *reinterpret_cast<const ::WorkerTask*>(
      &::_WorkerTask_default_instance_);
}
inline const ::WorkerTask& SetWorkerTask::task() const {
  // @@protoc_insertion_point(field_get:SetWorkerTask.task)
  return _internal_task();
}
inline void SetWorkerTask::unsafe_arena_set_allocated_task(
    ::WorkerTask* task) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SetWorkerTask.task)
}
inline ::WorkerTask* SetWorkerTask::release_task() {
  auto temp = unsafe_arena_release_task();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::WorkerTask* SetWorkerTask::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:SetWorkerTask.task)
  
  ::WorkerTask* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::WorkerTask* SetWorkerTask::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::WorkerTask>(GetArena());
    task_ = p;
  }
  return task_;
}
inline ::WorkerTask* SetWorkerTask::mutable_task() {
  // @@protoc_insertion_point(field_mutable:SetWorkerTask.task)
  return _internal_mutable_task();
}
inline void SetWorkerTask::set_allocated_task(::WorkerTask* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:SetWorkerTask.task)
}

// -------------------------------------------------------------------

// ComputePath

// int32 unitID = 1;
inline void ComputePath::clear_unitid() {
  unitid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::_internal_unitid() const {
  return unitid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::unitid() const {
  // @@protoc_insertion_point(field_get:ComputePath.unitID)
  return _internal_unitid();
}
inline void ComputePath::_internal_set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  unitid_ = value;
}
inline void ComputePath::set_unitid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_unitid(value);
  // @@protoc_insertion_point(field_set:ComputePath.unitID)
}

// .Pos from = 2;
inline bool ComputePath::_internal_has_from() const {
  return this != internal_default_instance() && from_ != nullptr;
}
inline bool ComputePath::has_from() const {
  return _internal_has_from();
}
inline void ComputePath::clear_from() {
  if (GetArena() == nullptr && from_ != nullptr) {
    delete from_;
  }
  from_ = nullptr;
}
inline const ::Pos& ComputePath::_internal_from() const {
  const ::Pos* p = from_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Pos*>(
      &::_Pos_default_instance_);
}
inline const ::Pos& ComputePath::from() const {
  // @@protoc_insertion_point(field_get:ComputePath.from)
  return _internal_from();
}
inline void ComputePath::unsafe_arena_set_allocated_from(
    ::Pos* from) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_);
  }
  from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ComputePath.from)
}
inline ::Pos* ComputePath::release_from() {
  auto temp = unsafe_arena_release_from();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Pos* ComputePath::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:ComputePath.from)
  
  ::Pos* temp = from_;
  from_ = nullptr;
  return temp;
}
inline ::Pos* ComputePath::_internal_mutable_from() {
  
  if (from_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArena());
    from_ = p;
  }
  return from_;
}
inline ::Pos* ComputePath::mutable_from() {
  // @@protoc_insertion_point(field_mutable:ComputePath.from)
  return _internal_mutable_from();
}
inline void ComputePath::set_allocated_from(::Pos* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:ComputePath.from)
}

// .Pos to = 3;
inline bool ComputePath::_internal_has_to() const {
  return this != internal_default_instance() && to_ != nullptr;
}
inline bool ComputePath::has_to() const {
  return _internal_has_to();
}
inline void ComputePath::clear_to() {
  if (GetArena() == nullptr && to_ != nullptr) {
    delete to_;
  }
  to_ = nullptr;
}
inline const ::Pos& ComputePath::_internal_to() const {
  const ::Pos* p = to_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Pos*>(
      &::_Pos_default_instance_);
}
inline const ::Pos& ComputePath::to() const {
  // @@protoc_insertion_point(field_get:ComputePath.to)
  return _internal_to();
}
inline void ComputePath::unsafe_arena_set_allocated_to(
    ::Pos* to) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(to_);
  }
  to_ = to;
  if (to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ComputePath.to)
}
inline ::Pos* ComputePath::release_to() {
  auto temp = unsafe_arena_release_to();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Pos* ComputePath::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:ComputePath.to)
  
  ::Pos* temp = to_;
  to_ = nullptr;
  return temp;
}
inline ::Pos* ComputePath::_internal_mutable_to() {
  
  if (to_ == nullptr) {
    auto* p = CreateMaybeMessage<::Pos>(GetArena());
    to_ = p;
  }
  return to_;
}
inline ::Pos* ComputePath::mutable_to() {
  // @@protoc_insertion_point(field_mutable:ComputePath.to)
  return _internal_mutable_to();
}
inline void ComputePath::set_allocated_to(::Pos* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(to);
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  to_ = to;
  // @@protoc_insertion_point(field_set_allocated:ComputePath.to)
}

// int32 pathID = 4;
inline void ComputePath::clear_pathid() {
  pathid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::_internal_pathid() const {
  return pathid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ComputePath::pathid() const {
  // @@protoc_insertion_point(field_get:ComputePath.pathID)
  return _internal_pathid();
}
inline void ComputePath::_internal_set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pathid_ = value;
}
inline void ComputePath::set_pathid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pathid(value);
  // @@protoc_insertion_point(field_set:ComputePath.pathID)
}

// -------------------------------------------------------------------

// SetEconomySettings

// int32 beakerPercent = 1;
inline void SetEconomySettings::clear_beakerpercent() {
  beakerpercent_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetEconomySettings::_internal_beakerpercent() const {
  return beakerpercent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetEconomySettings::beakerpercent() const {
  // @@protoc_insertion_point(field_get:SetEconomySettings.beakerPercent)
  return _internal_beakerpercent();
}
inline void SetEconomySettings::_internal_set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  beakerpercent_ = value;
}
inline void SetEconomySettings::set_beakerpercent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_beakerpercent(value);
  // @@protoc_insertion_point(field_set:SetEconomySettings.beakerPercent)
}

// -------------------------------------------------------------------

// SetResearch

// string techID = 1;
inline void SetResearch::clear_techid() {
  techid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResearch::techid() const {
  // @@protoc_insertion_point(field_get:SetResearch.techID)
  return _internal_techid();
}
inline void SetResearch::set_techid(const std::string& value) {
  _internal_set_techid(value);
  // @@protoc_insertion_point(field_set:SetResearch.techID)
}
inline std::string* SetResearch::mutable_techid() {
  // @@protoc_insertion_point(field_mutable:SetResearch.techID)
  return _internal_mutable_techid();
}
inline const std::string& SetResearch::_internal_techid() const {
  return techid_.Get();
}
inline void SetResearch::_internal_set_techid(const std::string& value) {
  
  techid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResearch::set_techid(std::string&& value) {
  
  techid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:SetResearch.techID)
}
inline void SetResearch::set_techid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  techid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:SetResearch.techID)
}
inline void SetResearch::set_techid(const char* value,
    size_t size) {
  
  techid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:SetResearch.techID)
}
inline std::string* SetResearch::_internal_mutable_techid() {
  
  return techid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResearch::release_techid() {
  // @@protoc_insertion_point(field_release:SetResearch.techID)
  return techid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResearch::set_allocated_techid(std::string* techid) {
  if (techid != nullptr) {
    
  } else {
    
  }
  techid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), techid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:SetResearch.techID)
}
inline std::string* SetResearch::unsafe_arena_release_techid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SetResearch.techID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return techid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResearch::unsafe_arena_set_allocated_techid(
    std::string* techid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (techid != nullptr) {
    
  } else {
    
  }
  techid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      techid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SetResearch.techID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Era> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Era>() {
  return ::Era_descriptor();
}
template <> struct is_proto_enum< ::Terrain> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Terrain>() {
  return ::Terrain_descriptor();
}
template <> struct is_proto_enum< ::Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Visibility>() {
  return ::Visibility_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_riposte_2eproto
