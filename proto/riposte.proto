//
// Created by Caelum van Ispelen on 6/14/21.
//

// Defines the packets. All of them.
//
// The client connects to the server and sends ClientInfo.
// The server responds with ServerInfo.
//
// The client is now in a "Waiting for Game to Start" state.
// It remains in this state until the server sends StartGame as
// a result of one of the following events:
// * the game host starts the game
// * the game was in progress, and the client was allowed to rejoin
// (because its username matched one of the existing players)
//
// After receiving StartGame, the client is in the "playing" state.
//
// The server proceeds to send all of the data packets to initialize
// game state on the client, including:
// * UpdateGlobalData
// * UpdateMap
// * UpdateCity
// * UpdateUnit
// * UpdatePlayer
// etc.
//
// The server sends StartTurn whenever the client's turn begins.
// During a client's turn, it can send action packets such as:
// * MoveUnit
// * SetCityBuildTask
// * SetWorkerTask
// * ComputePath (server responds with PathComputed)
// * SetEconomy
// etc.
//
// The server responds to each of these packets with a data packet
// to acknowledge the updated game state and cause it to be displayed on the client.
// For example, it responds to MoveUnit with UpdateUnit set to the new position.
//
// When the client ends its turn, it sends EndTurn. Alternatively, the server
// can force-end a turn by sending the same packet to the client. After the turn
// ends, the client must wait for StartTurn before making further actions.

syntax = "proto3";

message Pos {
  uint32 x = 1;
  uint32 y = 2;
}

// Any packet sent by the client.
message AnyClient {
  int32 requestID = 1;
  oneof packet {
    ClientInfo clientInfo = 2;
    ComputePath computePath = 3;
    MoveUnits moveUnits = 4;
    EndTurn endTurn = 5;
    GetBuildTasks getBuildTasks = 6;
    SetCityBuildTask setCityBuildTask = 7;
    SetResearch setResearch = 8;
    GetPossibleTechs getPossibleTechs = 9;
    SetEconomySettings setEconomySettings = 10;
    DoUnitAction doUnitAction = 11;
    SetWorkerTask setWorkerTask = 12;
    DeclareWar declareWar = 13;
    ConfigureWorkedTiles configureWorkedTiles = 14;
    GameOptions gameOptions = 15;
    AdminStartGame adminStartGame = 16;
    SetLeader setLeader = 17;
  }
}

// Any packet sent by the server.
message AnyServer {
  // Corresponds to the requestID of the packet
  // the server is responding to, if any.
  // Otherwise, always equal to zero.
  int32 requestID = 1;
  oneof packet {
    ServerInfo serverInfo = 2;
    StartGame startGame = 3;
    LobbyError lobbyError = 4;
    UpdateGlobalData updateGlobalData = 5;
    UpdateMap updateMap = 6;
    UpdateCity updateCity = 7;
    UpdateUnit updateUnit = 8;
    UpdatePlayer updatePlayer = 9;
    PathComputed pathComputed = 10;
    ConfirmMoveUnits confirmMoveUnits = 11;
    PossibleCityBuildTasks possibleCityBuildTasks = 12;
    PossibleTechs possibleTechs = 13;
    DeleteUnit deleteUnit = 14;
    UpdateTile updateTile = 15;
    UpdateVisibility updateVisibility = 16;
    CombatEvent combatEvent = 17;
  }
}

// PRE-GAME

// Sent by the client upon connecting.
message ClientInfo {
  string username = 1;
}

message LobbyPlayer {
  string username = 1;
  bool isHuman = 2;
  string civID = 3;
  string leaderName = 4;
  int32 playerID = 5;
  // If `false`, then we're still waiting for a human player in this slot.
  bool exists = 6;
  bool isAdmin = 7;
}

// Response to ClientInfo. Indicates lobby data.
//
// Also sent whenever lobby data changes (a player leaves/joins, etc.)
message ServerInfo {
  // Players in the lobby.
  repeated LobbyPlayer players = 1;
  // The ID of the player in this connection.
  int32 thePlayerID = 2;
}

// Can only be sent by the admin.
message KickPlayer {
  int32 id = 1;
  string reason = 2;
}

// Might fail if another player has chosen the same leader.
//
// Initially, the player's leader is randomly chosen (sent in ServerInfo)
message SetLeader {
  string civID = 1;
  string leader = 2;
}

// Can only be sent by the admin.
// Might be rejected.
message AdminStartGame {}

// Sent by the server when an action cannot be performed
// (game cannot start, etc.)
message LobbyError {
  string message = 1;
}

// Updates game options. Can only be sent by the admin.
message GameOptions {
  uint32 mapWidth = 1;
  uint32 mapHeight = 2;
  uint32 numHumanPlayers = 3;
  uint32 numAIPlayers = 4;
}

// ---------------------
// SERVER
// ---------------------

// Enters the game state.
message StartGame {
  // empty
}

message PlayerInfo {
  // The player's username.
  string username = 1;
  string civID = 2;
  string leaderName = 3;
  int32 score = 4;
  // A unique ID.
  int32 id = 5;
  bool isAdmin = 6;
}

enum Era {
  Ancient = 0;
  Classical = 1;
  Medieval = 2;
  Renaissance = 3;
  Industrial = 4;
  Modern = 5;
  Future = 6;
}

// Sets global data for the entire game.
message UpdateGlobalData {
  // List of players in the game.
  repeated PlayerInfo players = 1;
  // The current turn number.
  int32 turn = 2;
  // The current era.
  Era era = 3;
  // The ID of the connected client.
  int32 playerID = 4;
}

enum Terrain {
  Grassland = 0;
  Desert = 1;
  Ocean = 2;
  Plains = 3;
}

message Improvement {
  // The type of improvement.
  string id = 1;
  // Only set for cottages
  string cottageLevel = 2;
}

message Yield {
  int32 hammers = 1;
  int32 commerce = 2;
  int32 food = 3;
}

message Tile {
  Terrain terrain = 1;
  bool forested = 2;
  bool hilled = 3;
  repeated Improvement improvements = 4;
  Yield yield = 5;
  int32 ownerID = 6;
  bool hasOwner = 7;
  bool isWorked = 8;
  string resourceID = 9;
}

// Sends all map tiles.
message UpdateMap {
  uint32 width = 1;
  uint32 height = 2;
  repeated Tile tiles = 3;
}

enum Visibility {
  Hidden = 0;
  Fogged = 1;
  Visible = 2;
}

// Updates the player's visibility map.
message UpdateVisibility {
  repeated Visibility visibility = 1;
}

// Updates a single tile.
message UpdateTile {
  Tile tile = 1;
  uint32 x = 2;
  uint32 y = 3;
}

message UnitBuildTask {
  string unitKindID = 1;
}

message BuildingBuildTask {
  string buildingName = 1;
}

message BuildTaskKind {
  oneof task {
    UnitBuildTask unit = 1;
    BuildingBuildTask building = 2;
  }
}

message BuildTask {
  BuildTaskKind kind = 1;
  int32 progress = 2;
  int32 cost = 3;
}

// Creates or updates a city.
message UpdateCity {
  Pos pos = 1;
  string name = 2;
  int32 ownerID = 3;
  BuildTask buildTask = 4;
  Yield yield = 5;
  int32 culture = 6;
  // Culture needed to advance to the next level
  int32 cultureNeeded = 7;
  int32 id = 8;
  repeated string buildingNames = 9;
  int32 population = 10;
  int32 storedFood = 11;
  int32 foodNeededForGrowth = 12;
  int32 consumedFood = 13;
  bool isCapital = 14;
  repeated Pos workedTiles = 15;
}

message Path {
  // Encoded as a series of [x, y], such
  // that the total length is the length of the path
  // times 2.
  repeated uint32 positions = 1;
}

message FoundCityCapability {}

message WorkerTaskImprovement {
  string improvementID = 1;
}

message WorkerTaskKind {
  oneof kind {
    WorkerTaskImprovement buildImprovement = 1;
  }
}

message WorkerTask {
  string name = 1;
  int32 turnsLeft = 2;
  WorkerTaskKind kind = 3;
  string presentParticiple = 4;
}

message WorkerCapability {
  WorkerTask currentTask = 1;
  repeated WorkerTask possibleTasks = 2;
}

message CarryUnitsCapability {
  repeated int32 carryingUnitIDs = 1;
}

message Capability {
  oneof cap {
    FoundCityCapability foundCity = 1;
    WorkerCapability worker = 2;
    CarryUnitsCapability carryUnits = 3;
  }
}

message UpdateUnit {
  Pos pos = 1;
  string kindID = 2;
  int32 ownerID = 3;
  // On [0, 1]
  double health = 4;
  double movementLeft = 5;
  Path followingPath = 6;
  repeated Capability capabilities = 7;
  int32 id = 8;
  double strength = 9;
  bool isFortified = 10;
}

message ResearchingTech {
  string techID = 1;
  int32 progress = 2;
}

// Updates the client's own player data.
message UpdatePlayer {
  int32 id = 1;
  string username = 2;

  int32 baseRevenue = 3;
  int32 beakerRevenue = 4;
  int32 goldRevenue = 5;
  int32 expenses = 6;
  int32 netGold = 7;

  int32 gold = 8;

  ResearchingTech researchingTech = 9;

  int32 capitalCityID = 10;

  repeated string unlockedTechIDs = 11;

  int32 beakerPercent = 12;

  repeated int32 atWarWithIDs = 13;
}

message PathComputed {
  Path path = 1;
}

// Response to MoveUnits.
message ConfirmMoveUnits {
  // Whether the units were moved at least one tile.
  bool success = 1;
}

message PossibleCityBuildTasks {
  repeated BuildTask tasks = 1;
}

message PossibleTechs {
  repeated string techs = 1;
}

message DeleteUnit {
  int32 unitID = 1;
}

// Informs the client of a combat event that occurred between two units.
//
// Only sent if combat happens during the player's turn, or if one of the player's
// units is involved. If it happens in between
// turns (e.g. because of AI vs AI combat) then this packet is not sent.
// However, DeleteUnit is always sent for the loser.
//
// If one of the client's units is involved in this combat event, the client should stop
// handling packets until it has finished displaying the combat animation. This ensures
// that cities won't turn, units won't die, and new combat animations won't be displayed until
// after the player has watched the animation.
//
// Following this packet, DeleteUnit is sent for the loser of the battle, if any,
// and UpdateUnit is sent for the winner.
message CombatEvent {
  int32 attackerID = 1;
  int32 defenderID = 2;

  // A list of rounds that occurred during combat.
  // Used to display the animation.
  repeated CombatRound rounds = 3;
}

// A round of combat during which one or both units suffered damage.
message CombatRound {
  // The attacker's health (0..1) at the end of this round.
  double attackerHealth = 1;
  // The defender's health (0..1) at the end of this round.
  double defenderHealth = 2;
}

// ---------------------
// CLIENT
// ---------------------

// Moves multiple units along a path.
// The units will all go to the same destination.
//
// Response: ConfirmMoveUnits
message MoveUnits {
  repeated int32 unitIDs = 1;
  Path pathToFollow = 2;
}

message SetCityBuildTask {
  int32 cityID = 1;
  BuildTaskKind task = 2;
}

message SetWorkerTask {
  int32 workerID = 1;
  WorkerTask task = 2;
}

message ComputePath {
  Pos from = 1;
  Pos to = 2;
  string unitKindID = 3;
}

message SetEconomySettings {
  int32 beakerPercent = 1;
}

message SetResearch {
  string techID = 1;
}

message EndTurn {

}

message GetBuildTasks {
  int32 cityID = 1;
}

message GetPossibleTechs {

}

enum UnitAction {
  Kill = 0;
  Fortify = 1;
  SkipTurn = 2;
  FortifyUntilHealed = 3;
  FoundCity = 4;
}

message DoUnitAction {
  int32 unitID = 1;
  UnitAction action = 2;
}

message DeclareWar {
  int32 onPlayerID = 1;
}

// Updates a city's worked tile overrides.
message ConfigureWorkedTiles {
  int32 cityID = 1;
  Pos tilePos = 2;
  bool shouldManuallyWork = 3;
}
